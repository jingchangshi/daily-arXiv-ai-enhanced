{"id": "2512.16038", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16038", "abs": "https://arxiv.org/abs/2512.16038", "authors": ["Eric Simon", "Renato B. Hoffmann", "Lucas Alf", "Dalvan Griebler"], "title": "LOG.io: Unified Rollback Recovery and Data Lineage Capture for Distributed Data Pipelines", "comment": null, "summary": "This paper introduces LOG.io, a comprehensive solution designed for correct rollback recovery and fine-grain data lineage capture in distributed data pipelines. It is tailored for serverless scalable architectures and uses a log-based rollback recovery protocol. LOG.io supports a general programming model, accommodating non-deterministic operators, interactions with external systems, and arbitrary custom code. It is non-blocking, allowing failed operators to recover independently without interrupting other active operators, thereby leveraging data parallelization, and it facilitates dynamic scaling of operators during pipeline execution. Performance evaluations, conducted within the SAP Data Intelligence system, compare LOG.io with the Asynchronous Barrier Snapshotting (ABS) protocol, originally implemented in Flink. Our experiments show that when there are straggler operators in a data pipeline and the throughput of events is moderate (e.g., 1 event every 100 ms), LOG.io performs as well as ABS during normal processing and outperforms ABS during recovery. Otherwise, ABS performs better than LOG.io for both normal processing and recovery. However, we show that in these cases, data parallelization can largely reduce the overhead of LOG.io while ABS does not improve. Finally, we show that the overhead of data lineage capture, at the granularity of the event and between any two operators in a pipeline, is marginal, with less than 1.5% in all our experiments.", "AI": {"tldr": "LOG.io \u662f\u4e00\u4e2a\u7528\u4e8e\u5206\u5e03\u5f0f\u6570\u636e\u6d41\u6c34\u7ebf\u7684\u56de\u6eda\u6062\u590d\u548c\u7ec6\u7c92\u5ea6\u6570\u636e\u8840\u7f18\u6355\u83b7\u7cfb\u7edf\uff0c\u91c7\u7528\u57fa\u4e8e\u65e5\u5fd7\u7684\u6062\u590d\u534f\u8bae\uff0c\u652f\u6301\u975e\u786e\u5b9a\u6027\u64cd\u4f5c\u7b26\u548c\u5916\u90e8\u7cfb\u7edf\u4ea4\u4e92\uff0c\u5728\u7279\u5b9a\u6761\u4ef6\u4e0b\uff08\u5b58\u5728\u6162\u901f\u64cd\u4f5c\u7b26\u3001\u4e2d\u7b49\u4e8b\u4ef6\u541e\u5410\u91cf\uff09\u6062\u590d\u6027\u80fd\u4f18\u4e8eABS\u534f\u8bae\u3002", "motivation": "\u5206\u5e03\u5f0f\u6570\u636e\u6d41\u6c34\u7ebf\u9700\u8981\u53ef\u9760\u7684\u6545\u969c\u6062\u590d\u673a\u5236\uff0c\u73b0\u6709\u89e3\u51b3\u65b9\u6848\u5982Flink\u7684ABS\u534f\u8bae\u5728\u7279\u5b9a\u573a\u666f\u4e0b\u5b58\u5728\u6027\u80fd\u9650\u5236\u3002\u9700\u8981\u4e00\u79cd\u652f\u6301\u975e\u786e\u5b9a\u6027\u64cd\u4f5c\u7b26\u3001\u5916\u90e8\u7cfb\u7edf\u4ea4\u4e92\u548c\u81ea\u5b9a\u4e49\u4ee3\u7801\u7684\u901a\u7528\u6062\u590d\u65b9\u6848\uff0c\u540c\u65f6\u5b9e\u73b0\u7ec6\u7c92\u5ea6\u6570\u636e\u8840\u7f18\u8ddf\u8e2a\u3002", "method": "\u91c7\u7528\u57fa\u4e8e\u65e5\u5fd7\u7684\u56de\u6eda\u6062\u590d\u534f\u8bae\uff0c\u652f\u6301\u975e\u963b\u585e\u6062\u590d\uff08\u5931\u8d25\u64cd\u4f5c\u7b26\u72ec\u7acb\u6062\u590d\u4e0d\u5f71\u54cd\u5176\u4ed6\u64cd\u4f5c\u7b26\uff09\uff0c\u652f\u6301\u6570\u636e\u5e76\u884c\u5316\u548c\u52a8\u6001\u6269\u7f29\u5bb9\u3002\u5728SAP Data Intelligence\u7cfb\u7edf\u4e2d\u5b9e\u73b0\u5e76\u4e0eABS\u534f\u8bae\u8fdb\u884c\u5bf9\u6bd4\u5b9e\u9a8c\u3002", "result": "\u5f53\u6d41\u6c34\u7ebf\u5b58\u5728\u6162\u901f\u64cd\u4f5c\u7b26\u4e14\u4e8b\u4ef6\u541e\u5410\u91cf\u4e2d\u7b49\uff08\u5982\u6bcf100ms\u4e00\u4e2a\u4e8b\u4ef6\uff09\u65f6\uff0cLOG.io\u5728\u6b63\u5e38\u5904\u7406\u65f6\u6027\u80fd\u4e0eABS\u76f8\u5f53\uff0c\u5728\u6062\u590d\u65f6\u4f18\u4e8eABS\u3002\u5176\u4ed6\u60c5\u51b5\u4e0bABS\u8868\u73b0\u66f4\u597d\uff0c\u4f46\u6570\u636e\u5e76\u884c\u5316\u80fd\u663e\u8457\u964d\u4f4eLOG.io\u5f00\u9500\u800cABS\u65e0\u6539\u5584\u3002\u6570\u636e\u8840\u7f18\u6355\u83b7\u5f00\u9500\u5728\u6240\u6709\u5b9e\u9a8c\u4e2d\u4f4e\u4e8e1.5%\u3002", "conclusion": "LOG.io\u4e3a\u5206\u5e03\u5f0f\u6570\u636e\u6d41\u6c34\u7ebf\u63d0\u4f9b\u4e86\u6709\u6548\u7684\u56de\u6eda\u6062\u590d\u548c\u7ec6\u7c92\u5ea6\u6570\u636e\u8840\u7f18\u6355\u83b7\u65b9\u6848\uff0c\u5728\u7279\u5b9a\u573a\u666f\u4e0b\u6062\u590d\u6027\u80fd\u4f18\u4e8e\u73b0\u6709\u65b9\u6848\uff0c\u4e14\u6570\u636e\u8840\u7f18\u8ddf\u8e2a\u5f00\u9500\u53ef\u5ffd\u7565\u4e0d\u8ba1\u3002"}}
{"id": "2512.16056", "categories": ["cs.DC", "cs.NI", "cs.PF"], "pdf": "https://arxiv.org/pdf/2512.16056", "abs": "https://arxiv.org/abs/2512.16056", "authors": ["Lingfeng Tang", "Daoping Zhang", "Junjie Chen", "Peihao Huang", "Feng Jin", "Chengguang Xu", "Yuxin Chen", "Feiqiang Sun", "Guo Chen"], "title": "MultiPath Transfer Engine: Breaking GPU and Host-Memory Bandwidth Bottlenecks in LLM Services", "comment": null, "summary": "The limited bandwidth of PCIe has emerged as the critical bottleneck for large language model (LLM) performance, such as prefix cache fetching and model switching. Although intra-server multipath data transfer between GPU and host memory is theoretically possible, heterogeneous protocols such as PCIe and NVLink currently limit the bandwidth between host memory and GPUs to that of a single PICe link. This limitation resuals in underutilized intra-server bandwidth. To address this issue, we propose Multipath Memory Access (MMA), a scheme that, to the best of our knowledge, is the first to enalbe efficient multipath data transfer between GPU and host memory. MMA supports seamless deployment via dynamic library injection, enabling LLM applications to benefit from MMA without requiring any code modification. In our testbed, MMA significantly improves the data transfer bandwidth between the GPU and memory, achieving a peak bandwidth of 245 GB/s-representing a 4.62x speedup compared to the natice single-path bandwidth. End-to-end evaluations demonstrate that MMA reduces the time-to-first-token (TTFT) for LLM serving by 1.14x to 2.38x and decreases model-switching latency in vLLM's sleep mode by 1.12x to 2.48x.", "AI": {"tldr": "MMA\u901a\u8fc7\u591a\u8def\u5f84\u5185\u5b58\u8bbf\u95ee\u6280\u672f\uff0c\u5229\u7528\u670d\u52a1\u5668\u5185\u672a\u5145\u5206\u5229\u7528\u7684\u5e26\u5bbd\uff0c\u663e\u8457\u63d0\u5347GPU\u4e0e\u4e3b\u673a\u5185\u5b58\u95f4\u7684\u6570\u636e\u4f20\u8f93\u6027\u80fd\uff0c\u4ece\u800c\u6539\u5584LLM\u670d\u52a1\u7684\u9996\u4ee4\u724c\u65f6\u95f4\u548c\u6a21\u578b\u5207\u6362\u5ef6\u8fdf\u3002", "motivation": "PCIe\u5e26\u5bbd\u5df2\u6210\u4e3a\u5927\u8bed\u8a00\u6a21\u578b\u6027\u80fd\u7684\u5173\u952e\u74f6\u9888\uff0c\u7279\u522b\u662f\u5728\u524d\u7f00\u7f13\u5b58\u83b7\u53d6\u548c\u6a21\u578b\u5207\u6362\u573a\u666f\u4e2d\u3002\u867d\u7136\u7406\u8bba\u4e0a\u53ef\u4ee5\u5728GPU\u548c\u4e3b\u673a\u5185\u5b58\u4e4b\u95f4\u8fdb\u884c\u591a\u8def\u5f84\u6570\u636e\u4f20\u8f93\uff0c\u4f46PCIe\u548cNVLink\u7b49\u5f02\u6784\u534f\u8bae\u9650\u5236\u4e86\u5e26\u5bbd\u53ea\u80fd\u8fbe\u5230\u5355\u4e2aPCIe\u94fe\u8def\u7684\u6c34\u5e73\uff0c\u5bfc\u81f4\u670d\u52a1\u5668\u5185\u5e26\u5bbd\u672a\u5145\u5206\u5229\u7528\u3002", "method": "\u63d0\u51fa\u591a\u8def\u5f84\u5185\u5b58\u8bbf\u95ee\uff08MMA\uff09\u65b9\u6848\uff0c\u9996\u6b21\u5b9e\u73b0GPU\u4e0e\u4e3b\u673a\u5185\u5b58\u95f4\u7684\u9ad8\u6548\u591a\u8def\u5f84\u6570\u636e\u4f20\u8f93\u3002\u901a\u8fc7\u52a8\u6001\u5e93\u6ce8\u5165\u5b9e\u73b0\u65e0\u7f1d\u90e8\u7f72\uff0c\u4f7fLLM\u5e94\u7528\u65e0\u9700\u4ee3\u7801\u4fee\u6539\u5373\u53ef\u53d7\u76ca\u4e8eMMA\u6280\u672f\u3002", "result": "\u5728\u6d4b\u8bd5\u5e73\u53f0\u4e2d\uff0cMMA\u663e\u8457\u63d0\u5347GPU\u4e0e\u5185\u5b58\u95f4\u7684\u6570\u636e\u4f20\u8f93\u5e26\u5bbd\uff0c\u5cf0\u503c\u5e26\u5bbd\u8fbe\u5230245GB/s\uff0c\u76f8\u6bd4\u539f\u751f\u5355\u8def\u5f84\u5e26\u5bbd\u5b9e\u73b04.62\u500d\u52a0\u901f\u3002\u7aef\u5230\u7aef\u8bc4\u4f30\u663e\u793a\uff0cMMA\u5c06LLM\u670d\u52a1\u7684\u9996\u4ee4\u724c\u65f6\u95f4\u51cf\u5c111.14-2.38\u500d\uff0c\u5e76\u5c06vLLM\u7761\u7720\u6a21\u5f0f\u4e0b\u7684\u6a21\u578b\u5207\u6362\u5ef6\u8fdf\u964d\u4f4e1.12-2.48\u500d\u3002", "conclusion": "MMA\u901a\u8fc7\u6709\u6548\u5229\u7528\u670d\u52a1\u5668\u5185\u672a\u5145\u5206\u5229\u7528\u7684\u5e26\u5bbd\uff0c\u6210\u529f\u89e3\u51b3\u4e86PCIe\u5e26\u5bbd\u74f6\u9888\u95ee\u9898\uff0c\u663e\u8457\u63d0\u5347\u4e86\u5927\u8bed\u8a00\u6a21\u578b\u670d\u52a1\u7684\u6027\u80fd\uff0c\u7279\u522b\u662f\u5728\u9996\u4ee4\u724c\u65f6\u95f4\u548c\u6a21\u578b\u5207\u6362\u5ef6\u8fdf\u65b9\u9762\u53d6\u5f97\u4e86\u5b9e\u8d28\u6027\u6539\u8fdb\u3002"}}
{"id": "2512.16058", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16058", "abs": "https://arxiv.org/abs/2512.16058", "authors": ["Yifei Qiu", "Tianle Liao", "Xin Jin", "Shaohua Wu", "Dusit Niyato", "Qinyu Zhang"], "title": "Twinning for Space-Air-Ground-Sea Integrated Networks: Beyond Conventional Digital Twin Towards Goal-Oriented Semantic Twin", "comment": null, "summary": "A space-air-ground-sea integrated network (SAGSIN) has emerged as a cornerstone of 6G systems, establishing a unified global architecture by integrating multi-domain network resources. Motivated by the demand for real-time situational awareness and intelligent operational maintenance, digital twin (DT) technology was initially regarded as a promising solution, owing to its capability to create virtual replicas and emulate physical system behaviors. However, in the context of SAGSIN, the high-fidelity, full-scale modeling paradigm inherent to conventional DTs encounters fundamental limitations, including prohibitive computational overhead, delayed model synchronization, and cross-system semantic gaps. To address these limitations, this survey paper proposes a novel twinning framework: goal-oriented semantic twin (GOST). Unlike DTs that pursue physical mirroring, GOST prioritizes ``utility'' over ``fidelity,'' leveraging semantic technologies and goal-oriented principles to construct lightweight, task-specific representations. This paper systematically articulates the GOST framework through three layers: knowledge-based semantics, data-driven semantics, and goal-oriented principles. Furthermore, we provide a comprehensive tutorial on constructing GOST by detailing its core enabling technologies and introduce a multidimensional evaluation framework for GOST. We present a case study targeting collaborative tracking tasks in remote satellite-UAV networks, demonstrating that GOST significantly outperforms conventional DTs in timeliness of perceptual data and collaborative tracking. Finally, we outline research directions, establishing GOST as a transformative twinning paradigm to guide the development of SAGSIN.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u9762\u5411\u76ee\u6807\u7684\u8bed\u4e49\u5b6a\u751f\uff08GOST\uff09\u6846\u67b6\uff0c\u7528\u4e8e\u89e3\u51b3\u7a7a\u95f4-\u7a7a\u4e2d-\u5730\u9762-\u6d77\u6d0b\u4e00\u4f53\u5316\u7f51\u7edc\uff08SAGSIN\uff09\u4e2d\u4f20\u7edf\u6570\u5b57\u5b6a\u751f\u9762\u4e34\u7684\u9ad8\u8ba1\u7b97\u5f00\u9500\u3001\u6a21\u578b\u540c\u6b65\u5ef6\u8fdf\u548c\u8de8\u7cfb\u7edf\u8bed\u4e49\u9e3f\u6c9f\u7b49\u95ee\u9898\u3002", "motivation": "\u4f20\u7edf\u6570\u5b57\u5b6a\u751f\u6280\u672f\u5728SAGSIN\u73af\u5883\u4e2d\u9762\u4e34\u6839\u672c\u6027\u9650\u5236\uff0c\u5305\u62ec\u8ba1\u7b97\u5f00\u9500\u8fc7\u9ad8\u3001\u6a21\u578b\u540c\u6b65\u5ef6\u8fdf\u548c\u8de8\u7cfb\u7edf\u8bed\u4e49\u9e3f\u6c9f\u3002\u9700\u8981\u4e00\u79cd\u65b0\u7684\u5b6a\u751f\u6846\u67b6\u6765\u652f\u6301\u5b9e\u65f6\u6001\u52bf\u611f\u77e5\u548c\u667a\u80fd\u8fd0\u7ef4\u7ef4\u62a4\u3002", "method": "\u63d0\u51fa\u9762\u5411\u76ee\u6807\u7684\u8bed\u4e49\u5b6a\u751f\uff08GOST\uff09\u6846\u67b6\uff0c\u901a\u8fc7\u4e09\u5c42\u7ed3\u6784\u5b9e\u73b0\uff1a\u57fa\u4e8e\u77e5\u8bc6\u7684\u8bed\u4e49\u5c42\u3001\u6570\u636e\u9a71\u52a8\u7684\u8bed\u4e49\u5c42\u548c\u9762\u5411\u76ee\u6807\u7684\u539f\u5219\u5c42\u3002\u8be5\u6846\u67b6\u4f18\u5148\u8003\u8651\"\u6548\u7528\"\u800c\u975e\"\u4fdd\u771f\u5ea6\"\uff0c\u5229\u7528\u8bed\u4e49\u6280\u672f\u548c\u9762\u5411\u76ee\u6807\u539f\u5219\u6784\u5efa\u8f7b\u91cf\u7ea7\u3001\u4efb\u52a1\u7279\u5b9a\u7684\u8868\u793a\u3002", "result": "\u5728\u8fdc\u7a0b\u536b\u661f-\u65e0\u4eba\u673a\u7f51\u7edc\u7684\u534f\u540c\u8ddf\u8e2a\u4efb\u52a1\u6848\u4f8b\u7814\u7a76\u4e2d\uff0cGOST\u5728\u611f\u77e5\u6570\u636e\u65f6\u6548\u6027\u548c\u534f\u540c\u8ddf\u8e2a\u6027\u80fd\u65b9\u9762\u663e\u8457\u4f18\u4e8e\u4f20\u7edf\u6570\u5b57\u5b6a\u751f\u3002", "conclusion": "GOST\u4f5c\u4e3a\u4e00\u79cd\u53d8\u9769\u6027\u7684\u5b6a\u751f\u8303\u5f0f\uff0c\u901a\u8fc7\u8bed\u4e49\u6280\u672f\u548c\u9762\u5411\u76ee\u6807\u539f\u5219\u89e3\u51b3\u4e86SAGSIN\u4e2d\u4f20\u7edf\u6570\u5b57\u5b6a\u751f\u7684\u5c40\u9650\u6027\uff0c\u4e3a6G\u7cfb\u7edf\u7684\u53d1\u5c55\u63d0\u4f9b\u4e86\u6307\u5bfc\u65b9\u5411\u3002"}}
{"id": "2512.16066", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16066", "abs": "https://arxiv.org/abs/2512.16066", "authors": ["Syed Salauddin Mohammad Tariq", "Foyzul Hassan", "Amiangshu Bosu", "Probir Roy"], "title": "Cold-Start Anti-Patterns and Refactorings in Serverless Systems: An Empirical Study", "comment": null, "summary": "Serverless computing simplifies deployment and scaling, yet cold-start latency remains a major performance bottleneck. Unlike prior work that treats mitigation as a black-box optimization, we study cold starts as a developer-visible design problem. From 81 adjudicated issue reports across open-source serverless systems, we derive taxonomies of initialization anti-patterns, remediation strategies, and diagnostic challenges spanning design, packaging, and runtime layers. Building on these insights, we introduce SCABENCH, a reproducible benchmark, and INITSCOPE, a lightweight analysis framework linking what code is loaded with what is executed. On SCABENCH, INITSCOPE improved localization accuracy by up to 40% and reduced diagnostic effort by 64% compared with prior tools, while a developer study showed higher task accuracy and faster diagnosis. Together, these results advance evidence-driven, performance-aware practices for cold-start mitigation in serverless design. Availability: The research artifact is publicly accessible for future studies and improvements.", "AI": {"tldr": "\u8be5\u8bba\u6587\u9488\u5bf9\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u4e2d\u7684\u51b7\u542f\u52a8\u5ef6\u8fdf\u95ee\u9898\uff0c\u4ece\u5f00\u53d1\u8005\u53ef\u89c1\u7684\u8bbe\u8ba1\u89d2\u5ea6\u8fdb\u884c\u7814\u7a76\uff0c\u63d0\u51fa\u4e86SCABENCH\u57fa\u51c6\u6d4b\u8bd5\u548cINITSCOPE\u5206\u6790\u6846\u67b6\uff0c\u663e\u8457\u63d0\u5347\u4e86\u51b7\u542f\u52a8\u95ee\u9898\u7684\u8bca\u65ad\u6548\u7387\u548c\u51c6\u786e\u6027\u3002", "motivation": "\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u7b80\u5316\u4e86\u90e8\u7f72\u548c\u6269\u5c55\uff0c\u4f46\u51b7\u542f\u52a8\u5ef6\u8fdf\u4ecd\u7136\u662f\u4e3b\u8981\u7684\u6027\u80fd\u74f6\u9888\u3002\u73b0\u6709\u7814\u7a76\u5c06\u7f13\u89e3\u63aa\u65bd\u89c6\u4e3a\u9ed1\u76d2\u4f18\u5316\uff0c\u800c\u672c\u6587\u4ece\u5f00\u53d1\u8005\u53ef\u89c1\u7684\u8bbe\u8ba1\u95ee\u9898\u89d2\u5ea6\u7814\u7a76\u51b7\u542f\u52a8\uff0c\u901a\u8fc7\u5206\u679081\u4e2a\u5f00\u6e90\u65e0\u670d\u52a1\u5668\u7cfb\u7edf\u7684\u95ee\u9898\u62a5\u544a\u6765\u6df1\u5165\u7406\u89e3\u8be5\u95ee\u9898\u3002", "method": "1. \u5206\u679081\u4e2a\u5f00\u6e90\u65e0\u670d\u52a1\u5668\u7cfb\u7edf\u7684\u88c1\u51b3\u95ee\u9898\u62a5\u544a\uff0c\u63a8\u5bfc\u51fa\u521d\u59cb\u5316\u53cd\u6a21\u5f0f\u3001\u4fee\u590d\u7b56\u7565\u548c\u8bca\u65ad\u6311\u6218\u7684\u5206\u7c7b\u4f53\u7cfb\uff1b2. \u57fa\u4e8e\u8fd9\u4e9b\u6d1e\u5bdf\uff0c\u5f00\u53d1SCABENCH\u53ef\u91cd\u73b0\u57fa\u51c6\u6d4b\u8bd5\uff1b3. \u8bbe\u8ba1INITSCOPE\u8f7b\u91cf\u7ea7\u5206\u6790\u6846\u67b6\uff0c\u5c06\u52a0\u8f7d\u7684\u4ee3\u7801\u4e0e\u6267\u884c\u7684\u4ee3\u7801\u5173\u8054\u8d77\u6765\u3002", "result": "\u5728SCABENCH\u4e0a\uff0cINITSCOPE\u76f8\u6bd4\u73b0\u6709\u5de5\u5177\u5c06\u5b9a\u4f4d\u51c6\u786e\u7387\u63d0\u9ad8\u4e8640%\uff0c\u8bca\u65ad\u5de5\u4f5c\u91cf\u51cf\u5c11\u4e8664%\u3002\u5f00\u53d1\u8005\u7814\u7a76\u663e\u793a\u4efb\u52a1\u51c6\u786e\u7387\u66f4\u9ad8\u4e14\u8bca\u65ad\u901f\u5ea6\u66f4\u5feb\u3002\u7814\u7a76\u7ed3\u679c\u4e3a\u65e0\u670d\u52a1\u5668\u8bbe\u8ba1\u4e2d\u7684\u51b7\u542f\u52a8\u7f13\u89e3\u63d0\u4f9b\u4e86\u57fa\u4e8e\u8bc1\u636e\u7684\u6027\u80fd\u611f\u77e5\u5b9e\u8df5\u3002", "conclusion": "\u8be5\u7814\u7a76\u901a\u8fc7\u5c06\u51b7\u542f\u52a8\u89c6\u4e3a\u5f00\u53d1\u8005\u53ef\u89c1\u7684\u8bbe\u8ba1\u95ee\u9898\uff0c\u63d0\u51fa\u4e86\u7cfb\u7edf\u5316\u7684\u5206\u6790\u65b9\u6cd5\u548c\u5de5\u5177\uff0c\u663e\u8457\u6539\u5584\u4e86\u51b7\u542f\u52a8\u95ee\u9898\u7684\u8bca\u65ad\u6548\u7387\u548c\u51c6\u786e\u6027\uff0c\u63a8\u52a8\u4e86\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u4e2d\u57fa\u4e8e\u8bc1\u636e\u7684\u6027\u80fd\u611f\u77e5\u5b9e\u8df5\u53d1\u5c55\u3002"}}
{"id": "2512.15827", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.15827", "abs": "https://arxiv.org/abs/2512.15827", "authors": ["FNU Vikas", "Paul Gratz", "Daniel Jim\u00e9nez"], "title": "Workload Characterization for Branch Predictability", "comment": "This manuscript is an archival version of work conducted as part of the author's 2020 Master's at Texas A\\&M University under the supervision of Professors Paul Gratz and Daniel A.~Jim\u00e9nez. No part of this work was conducted at, funded by, or related to the author's current employer", "summary": "Conditional branch prediction predicts the likely direction of a conditional branch instruction to support ILP extraction. Branch prediction is a pattern recognition problem that learns mappings between a context to the branch outcome. An accurate predictor reduces the number of instructions executed on the wrong path resulting in an improvement of performance and energy consumption. In this paper, we present a workload characterization methodology for branch prediction. We propose two new workload-driven branch prediction accuracy identifiers -- branch working set size and branch predictability. These parameters are highly correlated with misprediction rates of modern branch prediction schemes (e.g. TAGE and perceptron). We define the branch working set of a trace as a group of most frequently occurring branch contexts, i.e. the 3-part tuple of branch address, and associated global and local history. We analyze the branch working set's size and predictability on a per-trace basis to study its relationship with a modern branch predictor's accuracy. We have characterized 2,451 workload traces into seven branch working set size and nine predictability categories after analyzing their branch behavior. We present further insights into the source of prediction accuracy and favored workload categories for modern branch predictors.", "AI": {"tldr": "\u8be5\u8bba\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u5206\u652f\u9884\u6d4b\u7684\u5de5\u4f5c\u8d1f\u8f7d\u7279\u5f81\u5316\u65b9\u6cd5\uff0c\u5f15\u5165\u5206\u652f\u5de5\u4f5c\u96c6\u5927\u5c0f\u548c\u5206\u652f\u53ef\u9884\u6d4b\u6027\u4e24\u4e2a\u65b0\u6307\u6807\uff0c\u7528\u4e8e\u5206\u6790\u73b0\u4ee3\u5206\u652f\u9884\u6d4b\u5668\u7684\u51c6\u786e\u6027\u3002", "motivation": "\u6761\u4ef6\u5206\u652f\u9884\u6d4b\u662f\u652f\u6301\u6307\u4ee4\u7ea7\u5e76\u884c\u63d0\u53d6\u7684\u5173\u952e\u6280\u672f\uff0c\u51c6\u786e\u7684\u9884\u6d4b\u5668\u80fd\u51cf\u5c11\u9519\u8bef\u8def\u5f84\u4e0a\u7684\u6307\u4ee4\u6267\u884c\uff0c\u63d0\u5347\u6027\u80fd\u548c\u964d\u4f4e\u80fd\u8017\u3002\u7136\u800c\uff0c\u9700\u8981\u66f4\u597d\u7684\u65b9\u6cd5\u6765\u5206\u6790\u548c\u7406\u89e3\u4e0d\u540c\u5de5\u4f5c\u8d1f\u8f7d\u5bf9\u5206\u652f\u9884\u6d4b\u51c6\u786e\u6027\u7684\u5f71\u54cd\u3002", "method": "\u63d0\u51fa\u5de5\u4f5c\u8d1f\u8f7d\u7279\u5f81\u5316\u65b9\u6cd5\uff0c\u5b9a\u4e49\u5206\u652f\u5de5\u4f5c\u96c6\u4e3a\u6700\u5e38\u51fa\u73b0\u7684\u5206\u652f\u4e0a\u4e0b\u6587\uff08\u5206\u652f\u5730\u5740\u3001\u5168\u5c40\u5386\u53f2\u3001\u5c40\u90e8\u5386\u53f2\u7684\u4e09\u5143\u7ec4\uff09\u3002\u901a\u8fc7\u5206\u6790\u5206\u652f\u5de5\u4f5c\u96c6\u7684\u5927\u5c0f\u548c\u53ef\u9884\u6d4b\u6027\uff0c\u7814\u7a76\u5176\u4e0e\u73b0\u4ee3\u5206\u652f\u9884\u6d4b\u5668\u51c6\u786e\u6027\u7684\u5173\u7cfb\u3002\u5bf92,451\u4e2a\u5de5\u4f5c\u8d1f\u8f7d\u8f68\u8ff9\u8fdb\u884c\u4e86\u7279\u5f81\u5316\u5206\u6790\u3002", "result": "\u5206\u652f\u5de5\u4f5c\u96c6\u5927\u5c0f\u548c\u5206\u652f\u53ef\u9884\u6d4b\u6027\u4e0e\u73b0\u4ee3\u5206\u652f\u9884\u6d4b\u65b9\u6848\uff08\u5982TAGE\u548c\u611f\u77e5\u5668\uff09\u7684\u8bef\u9884\u6d4b\u7387\u9ad8\u5ea6\u76f8\u5173\u3002\u5c06\u5de5\u4f5c\u8d1f\u8f7d\u8f68\u8ff9\u5206\u4e3a7\u4e2a\u5206\u652f\u5de5\u4f5c\u96c6\u5927\u5c0f\u7c7b\u522b\u548c9\u4e2a\u53ef\u9884\u6d4b\u6027\u7c7b\u522b\uff0c\u63d0\u4f9b\u4e86\u5173\u4e8e\u9884\u6d4b\u51c6\u786e\u6027\u6765\u6e90\u548c\u73b0\u4ee3\u5206\u652f\u9884\u6d4b\u5668\u504f\u597d\u7684\u5de5\u4f5c\u8d1f\u8f7d\u7c7b\u522b\u7684\u6df1\u5165\u89c1\u89e3\u3002", "conclusion": "\u63d0\u51fa\u7684\u5de5\u4f5c\u8d1f\u8f7d\u7279\u5f81\u5316\u65b9\u6cd5\u548c\u4e24\u4e2a\u65b0\u6307\u6807\u80fd\u6709\u6548\u5206\u6790\u5206\u652f\u9884\u6d4b\u51c6\u786e\u6027\uff0c\u4e3a\u7406\u89e3\u73b0\u4ee3\u5206\u652f\u9884\u6d4b\u5668\u5728\u4e0d\u540c\u5de5\u4f5c\u8d1f\u8f7d\u4e0b\u7684\u8868\u73b0\u63d0\u4f9b\u4e86\u7cfb\u7edf\u6846\u67b6\uff0c\u6709\u52a9\u4e8e\u4f18\u5316\u9884\u6d4b\u5668\u8bbe\u8ba1\u548c\u6027\u80fd\u8bc4\u4f30\u3002"}}
{"id": "2512.15766", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2512.15766", "abs": "https://arxiv.org/abs/2512.15766", "authors": ["Yijie Zhi", "Yayu Cao", "Jianhua Dai", "Xiaoyang Han", "Jingwen Pu", "Qingran Wu", "Sheng Cheng", "Ming Cai"], "title": "LOOPRAG: Enhancing Loop Transformation Optimization with Retrieval-Augmented Large Language Models", "comment": "Accepted to ASPLOS 2026", "summary": "Loop transformations are semantics-preserving optimization techniques, widely used to maximize objectives such as parallelism. Despite decades of research, applying the optimal composition of loop transformations remains challenging due to inherent complexities, including cost modeling for optimization objectives. Recent studies have explored the potential of Large Language Models (LLMs) for code optimization. However, our key observation is that LLMs often struggle with effective loop transformation optimization, frequently leading to errors or suboptimal optimization, thereby missing opportunities for performance improvements. To bridge this gap, we propose LOOPRAG, a novel retrieval-augmented generation framework designed to guide LLMs in performing effective loop optimization on Static Control Part. We introduce a parameter-driven method to harness loop properties, which trigger various loop transformations, and generate diverse yet legal example codes serving as a demonstration source. To effectively obtain the most informative demonstrations, we propose a loop-aware algorithm based on loop features, which balances similarity and diversity for code retrieval. To enhance correct and efficient code generation, we introduce a feedback-based iterative mechanism that incorporates compilation, testing and performance results as feedback to guide LLMs. Each optimized code undergoes mutation, coverage and differential testing for equivalence checking. We evaluate LOOPRAG on PolyBench, TSVC and LORE benchmark suites, and compare it against compilers (GCC-Graphite, Clang-Polly, Perspective and ICX) and representative LLMs (DeepSeek and GPT-4). The results demonstrate average speedups over base compilers of up to 11.20$\\times$, 14.34$\\times$, and 9.29$\\times$ for PolyBench, TSVC, and LORE, respectively, and speedups over base LLMs of up to 11.97$\\times$, 5.61$\\times$, and 11.59$\\times$.", "AI": {"tldr": "LOOPRAG\uff1a\u57fa\u4e8e\u68c0\u7d22\u589e\u5f3a\u751f\u6210\u7684\u5faa\u73af\u4f18\u5316\u6846\u67b6\uff0c\u5229\u7528\u53c2\u6570\u9a71\u52a8\u65b9\u6cd5\u751f\u6210\u591a\u6837\u5316\u5408\u6cd5\u793a\u4f8b\uff0c\u901a\u8fc7\u5faa\u73af\u611f\u77e5\u68c0\u7d22\u7b97\u6cd5\u548c\u53cd\u9988\u8fed\u4ee3\u673a\u5236\u6307\u5bfcLLM\u8fdb\u884c\u6709\u6548\u7684\u5faa\u73af\u53d8\u6362\u4f18\u5316\u3002", "motivation": "\u4f20\u7edf\u5faa\u73af\u53d8\u6362\u4f18\u5316\u590d\u6742\u4e14\u96be\u4ee5\u627e\u5230\u6700\u4f18\u7ec4\u5408\uff0c\u73b0\u6709LLM\u5728\u5faa\u73af\u4f18\u5316\u4e2d\u5e38\u51fa\u9519\u6216\u6548\u679c\u4e0d\u4f73\uff0c\u9519\u5931\u6027\u80fd\u63d0\u5347\u673a\u4f1a\uff0c\u9700\u8981\u65b0\u65b9\u6cd5\u6307\u5bfcLLM\u8fdb\u884c\u6709\u6548\u5faa\u73af\u4f18\u5316\u3002", "method": "\u63d0\u51faLOOPRAG\u6846\u67b6\uff1a1) \u53c2\u6570\u9a71\u52a8\u65b9\u6cd5\u5229\u7528\u5faa\u73af\u5c5e\u6027\u89e6\u53d1\u53d8\u6362\u751f\u6210\u591a\u6837\u5316\u5408\u6cd5\u793a\u4f8b\uff1b2) \u57fa\u4e8e\u5faa\u73af\u7279\u5f81\u7684\u68c0\u7d22\u7b97\u6cd5\u5e73\u8861\u76f8\u4f3c\u6027\u4e0e\u591a\u6837\u6027\uff1b3) \u53cd\u9988\u8fed\u4ee3\u673a\u5236\u7ed3\u5408\u7f16\u8bd1\u3001\u6d4b\u8bd5\u548c\u6027\u80fd\u7ed3\u679c\u6307\u5bfcLLM\uff1b4) \u901a\u8fc7\u53d8\u5f02\u3001\u8986\u76d6\u548c\u5dee\u5206\u6d4b\u8bd5\u8fdb\u884c\u7b49\u4ef7\u6027\u68c0\u67e5\u3002", "result": "\u5728PolyBench\u3001TSVC\u548cLORE\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0c\u76f8\u6bd4\u57fa\u7840\u7f16\u8bd1\u5668\u5206\u522b\u83b7\u5f97\u6700\u9ad811.20\u00d7\u300114.34\u00d7\u548c9.29\u00d7\u52a0\u901f\uff0c\u76f8\u6bd4\u57fa\u7840LLM\u5206\u522b\u83b7\u5f97\u6700\u9ad811.97\u00d7\u30015.61\u00d7\u548c11.59\u00d7\u52a0\u901f\u3002", "conclusion": "LOOPRAG\u901a\u8fc7\u68c0\u7d22\u589e\u5f3a\u751f\u6210\u548c\u53cd\u9988\u8fed\u4ee3\u673a\u5236\u6709\u6548\u89e3\u51b3\u4e86LLM\u5728\u5faa\u73af\u4f18\u5316\u4e2d\u7684\u5c40\u9650\u6027\uff0c\u663e\u8457\u63d0\u5347\u4e86\u5faa\u73af\u53d8\u6362\u4f18\u5316\u7684\u6027\u80fd\uff0c\u4e3a\u4ee3\u7801\u4f18\u5316\u63d0\u4f9b\u4e86\u65b0\u65b9\u5411\u3002"}}
{"id": "2512.16099", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16099", "abs": "https://arxiv.org/abs/2512.16099", "authors": ["Hsu-Tzu Ting", "Jerry Chou", "Ming-Hung Chen", "I-Hsin Chung"], "title": "An Online Fragmentation-Aware Scheduler for Managing GPU-Sharing Workloads on Multi-Instance GPUs", "comment": "10 pages, 10 figures", "summary": "Modern GPU workloads increasingly demand efficient resource sharing, as many jobs do not require the full capacity of a GPU. Among sharing techniques, NVIDIA's Multi-Instance GPU (MIG) offers strong resource isolation by enabling hardware-level GPU partitioning. However, leveraging MIG effectively introduces new challenges. First, resource contention persists due to shared components such as PCIe bandwidth. Second, GPU fragmentation becomes a critical issue, which is different from prior fine-grained GPU sharing work due to MIG's limited number of valid MIG configurations. Fragmentation arises not only from spatial discontinuity but also from rigid profile placement constraints, especially after job arrivals and terminations. To address these issues, we propose an online scheduling framework that integrates conditional load balancing, dynamic partitioning, and job migration. Our approach dynamically adapts job placement to minimize contention and reorganizes GPU allocations to combat both internal and external fragmentation. Experimental results show that our method significantly improves system efficiency. When all techniques are applied, the makespan improves by up to 35%.", "AI": {"tldr": "\u63d0\u51fa\u5728\u7ebf\u8c03\u5ea6\u6846\u67b6\uff0c\u901a\u8fc7\u6761\u4ef6\u8d1f\u8f7d\u5747\u8861\u3001\u52a8\u6001\u5206\u533a\u548c\u4f5c\u4e1a\u8fc1\u79fb\uff0c\u89e3\u51b3NVIDIA MIG GPU\u5171\u4eab\u4e2d\u7684\u8d44\u6e90\u4e89\u7528\u548c\u788e\u7247\u5316\u95ee\u9898\uff0c\u63d0\u5347\u7cfb\u7edf\u6548\u738735%", "motivation": "\u73b0\u4ee3GPU\u5de5\u4f5c\u8d1f\u8f7d\u9700\u8981\u9ad8\u6548\u8d44\u6e90\u5171\u4eab\uff0c\u4f46NVIDIA MIG\u867d\u7136\u63d0\u4f9b\u786c\u4ef6\u7ea7GPU\u5206\u533a\uff0c\u4ecd\u9762\u4e34PCIe\u5e26\u5bbd\u7b49\u5171\u4eab\u7ec4\u4ef6\u7684\u8d44\u6e90\u4e89\u7528\u95ee\u9898\uff0c\u4ee5\u53ca\u7531\u4e8eMIG\u914d\u7f6e\u6709\u9650\u5bfc\u81f4\u7684GPU\u788e\u7247\u5316\u95ee\u9898\uff08\u5305\u62ec\u7a7a\u95f4\u4e0d\u8fde\u7eed\u6027\u548c\u521a\u6027\u914d\u7f6e\u7ea6\u675f\uff09", "method": "\u63d0\u51fa\u5728\u7ebf\u8c03\u5ea6\u6846\u67b6\uff0c\u96c6\u6210\u6761\u4ef6\u8d1f\u8f7d\u5747\u8861\u3001\u52a8\u6001\u5206\u533a\u548c\u4f5c\u4e1a\u8fc1\u79fb\u6280\u672f\uff0c\u52a8\u6001\u8c03\u6574\u4f5c\u4e1a\u653e\u7f6e\u4ee5\u51cf\u5c11\u4e89\u7528\uff0c\u5e76\u91cd\u65b0\u7ec4\u7ec7GPU\u5206\u914d\u4ee5\u5e94\u5bf9\u5185\u90e8\u548c\u5916\u90e8\u788e\u7247\u5316", "result": "\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u5f53\u5e94\u7528\u6240\u6709\u6280\u672f\u65f6\uff0cmakespan\uff08\u5b8c\u6210\u65f6\u95f4\uff09\u6700\u9ad8\u53ef\u63d0\u534735%\uff0c\u663e\u8457\u6539\u5584\u7cfb\u7edf\u6548\u7387", "conclusion": "\u63d0\u51fa\u7684\u5728\u7ebf\u8c03\u5ea6\u6846\u67b6\u80fd\u6709\u6548\u89e3\u51b3MIG GPU\u5171\u4eab\u4e2d\u7684\u8d44\u6e90\u4e89\u7528\u548c\u788e\u7247\u5316\u95ee\u9898\uff0c\u663e\u8457\u63d0\u5347GPU\u8d44\u6e90\u5229\u7528\u7387\u548c\u7cfb\u7edf\u6027\u80fd"}}
{"id": "2512.16045", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2512.16045", "abs": "https://arxiv.org/abs/2512.16045", "authors": ["Vincent T. Lee", "Tanfer Alan", "Sung Kim", "Ecenur Ustun", "Amr Suleiman", "Ajit Krisshna", "Tim Balbekov", "Armin Alaghi", "Richard Newcombe"], "title": "Full System Architecture Modeling for Wearable Egocentric Contextual AI", "comment": "13 pages, 3 tables, 6 figures, technical report", "summary": "The next generation of human-oriented computing will require always-on, spatially-aware wearable devices to capture egocentric vision and functional primitives (e.g., Where am I? What am I looking at?, etc.). These devices will sense an egocentric view of the world around us to observe all human-relevant signals across space and time to construct and maintain a user's personal context. This personal context, combined with advanced generative AI, will unlock a powerful new generation of contextual AI personal assistants and applications. However, designing a wearable system to support contextual AI is a daunting task because of the system's complexity and stringent power constraints due to weight and battery restrictions. To understand how to guide design for such systems, this work provides the first complete system architecture view of one such wearable contextual AI system (Aria2), along with the lessons we have learned through the system modeling and design space exploration process. We show that an end-to-end full system model view of such systems is vitally important, as no single component or category overwhelmingly dominates system power. This means long-range design decisions and power optimizations need to be made in the full system context to avoid running into limits caused by other system bottlenecks (i.e., Amdahl's law as applied to power) or as bottlenecks change. Finally, we reflect on lessons and insights for the road ahead, which will be important toward eventually enabling all-day, wearable, contextual AI systems.", "AI": {"tldr": "\u8bba\u6587\u4ecb\u7ecd\u4e86\u4e3a\u4e0b\u4e00\u4ee3\u60c5\u5883AI\u8bbe\u8ba1\u7684\u53ef\u7a7f\u6234\u7cfb\u7edfAria2\u7684\u5b8c\u6574\u67b6\u6784\uff0c\u5f3a\u8c03\u7aef\u5230\u7aef\u7cfb\u7edf\u5efa\u6a21\u7684\u91cd\u8981\u6027\uff0c\u56e0\u4e3a\u7cfb\u7edf\u529f\u8017\u6ca1\u6709\u5355\u4e00\u4e3b\u5bfc\u7ec4\u4ef6\uff0c\u9700\u8981\u5168\u5c40\u4f18\u5316\u4ee5\u907f\u514d\u74f6\u9888\u3002", "motivation": "\u4e0b\u4e00\u4ee3\u4ee5\u4eba\u4e3a\u672c\u7684\u8ba1\u7b97\u9700\u8981\u5168\u5929\u5019\u3001\u7a7a\u95f4\u611f\u77e5\u7684\u53ef\u7a7f\u6234\u8bbe\u5907\u6765\u6355\u83b7\u81ea\u6211\u4e2d\u5fc3\u89c6\u89c9\u548c\u529f\u80fd\u539f\u8bed\uff0c\u4ee5\u6784\u5efa\u7528\u6237\u4e2a\u4eba\u60c5\u5883\u3002\u7ed3\u5408\u751f\u6210\u5f0fAI\uff0c\u8fd9\u5c06\u89e3\u9501\u5f3a\u5927\u7684\u60c5\u5883AI\u4e2a\u4eba\u52a9\u624b\u3002\u7136\u800c\uff0c\u8bbe\u8ba1\u8fd9\u6837\u7684\u7cfb\u7edf\u9762\u4e34\u590d\u6742\u6027\u548c\u4e25\u683c\u7684\u529f\u8017\u9650\u5236\u6311\u6218\u3002", "method": "\u63d0\u51fa\u4e86\u9996\u4e2a\u5b8c\u6574\u7684\u53ef\u7a7f\u6234\u60c5\u5883AI\u7cfb\u7edf\uff08Aria2\uff09\u67b6\u6784\u89c6\u56fe\uff0c\u901a\u8fc7\u7cfb\u7edf\u5efa\u6a21\u548c\u8bbe\u8ba1\u7a7a\u95f4\u63a2\u7d22\u8fc7\u7a0b\uff0c\u5c55\u793a\u4e86\u7aef\u5230\u7aef\u5b8c\u6574\u7cfb\u7edf\u6a21\u578b\u7684\u91cd\u8981\u6027\u3002", "result": "\u7814\u7a76\u8868\u660e\uff0c\u8fd9\u7c7b\u7cfb\u7edf\u7684\u7aef\u5230\u7aef\u5b8c\u6574\u7cfb\u7edf\u6a21\u578b\u81f3\u5173\u91cd\u8981\uff0c\u56e0\u4e3a\u6ca1\u6709\u5355\u4e00\u7ec4\u4ef6\u6216\u7c7b\u522b\u4e3b\u5bfc\u7cfb\u7edf\u529f\u8017\u3002\u8fd9\u610f\u5473\u7740\u9700\u8981\u5728\u5b8c\u6574\u7cfb\u7edf\u80cc\u666f\u4e0b\u8fdb\u884c\u957f\u671f\u8bbe\u8ba1\u51b3\u7b56\u548c\u529f\u8017\u4f18\u5316\uff0c\u4ee5\u907f\u514d\u56e0\u5176\u4ed6\u7cfb\u7edf\u74f6\u9888\u6216\u74f6\u9888\u53d8\u5316\u800c\u53d7\u9650\u3002", "conclusion": "\u901a\u8fc7\u7cfb\u7edf\u5efa\u6a21\u83b7\u5f97\u7684\u7ecf\u9a8c\u548c\u89c1\u89e3\u5bf9\u4e8e\u6700\u7ec8\u5b9e\u73b0\u5168\u5929\u5019\u53ef\u7a7f\u6234\u60c5\u5883AI\u7cfb\u7edf\u81f3\u5173\u91cd\u8981\uff0c\u5f3a\u8c03\u4e86\u5168\u5c40\u7cfb\u7edf\u89c6\u89d2\u5728\u529f\u8017\u4f18\u5316\u4e2d\u7684\u5173\u952e\u4f5c\u7528\u3002"}}
{"id": "2512.15788", "categories": ["cs.PL", "cs.FL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2512.15788", "abs": "https://arxiv.org/abs/2512.15788", "authors": ["Anastasia Mavridou", "Marie Farrell", "Gricel V\u00e1zquez", "Tom Pressburger", "Timothy E. Wang", "Radu Calinescu", "Michael Fisher"], "title": "Automated Formalization of Probabilistic Requirements from Structured Natural Language", "comment": "Official website https://github.com/NASA-SW-VnV/fret/releases/tag/v3.0.0", "summary": "Integrating autonomous and adaptive behavior into software-intensive systems presents significant challenges for software development, as uncertainties in the environment or decision-making processes must be explicitly captured. These challenges are amplified in safety- and mission-critical systems, which must undergo rigorous scrutiny during design and development. Key among these challenges is the difficulty of specifying requirements that use probabilistic constructs to capture the uncertainty affecting these systems. To enable formal analysis, such requirements must be expressed in precise mathematical notations such as probabilistic logics. However, expecting developers to write requirements directly in complex formalisms is unrealistic and highly error-prone. We extend the structured natural language used by NASA's Formal Requirement Elicitation Tool (FRET) with support for the specification of unambiguous and correct probabilistic requirements, and develop an automated approach for translating these requirements into logical formulas. We propose and develop a formal, compositional, and automated approach for translating structured natural-language requirements into formulas in probabilistic temporal logic. To increase trust in our formalizations, we provide assurance that the generated formulas are well-formed and conform to the intended semantics through an automated validation framework and a formal proof. The extended FRET tool enables developers to specify probabilistic requirements in structured natural language, and to automatically translate them into probabilistic temporal logic, making the formal analysis of autonomous and adaptive systems more practical and less error-prone.", "AI": {"tldr": "\u6269\u5c55NASA\u7684FRET\u5de5\u5177\uff0c\u652f\u6301\u7528\u7ed3\u6784\u5316\u81ea\u7136\u8bed\u8a00\u7f16\u5199\u6982\u7387\u9700\u6c42\uff0c\u5e76\u81ea\u52a8\u8f6c\u6362\u4e3a\u6982\u7387\u65f6\u5e8f\u903b\u8f91\u516c\u5f0f\uff0c\u4fbf\u4e8e\u81ea\u4e3b\u81ea\u9002\u5e94\u7cfb\u7edf\u7684\u5f62\u5f0f\u5316\u5206\u6790\u3002", "motivation": "\u81ea\u4e3b\u81ea\u9002\u5e94\u7cfb\u7edf\u5f00\u53d1\u9762\u4e34\u6982\u7387\u9700\u6c42\u89c4\u8303\u56f0\u96be\uff0c\u73b0\u6709\u5f62\u5f0f\u5316\u65b9\u6cd5\u5bf9\u5f00\u53d1\u8005\u4e0d\u53cb\u597d\u4e14\u6613\u51fa\u9519\uff0c\u9700\u8981\u66f4\u5b9e\u7528\u7684\u89e3\u51b3\u65b9\u6848\u3002", "method": "\u6269\u5c55FRET\u7684\u7ed3\u6784\u5316\u81ea\u7136\u8bed\u8a00\uff0c\u652f\u6301\u6982\u7387\u9700\u6c42\u89c4\u8303\uff1b\u5f00\u53d1\u81ea\u52a8\u8f6c\u6362\u65b9\u6cd5\uff0c\u5c06\u9700\u6c42\u8f6c\u6362\u4e3a\u6982\u7387\u65f6\u5e8f\u903b\u8f91\u516c\u5f0f\uff1b\u5efa\u7acb\u9a8c\u8bc1\u6846\u67b6\u786e\u4fdd\u516c\u5f0f\u6b63\u786e\u6027\u3002", "result": "\u5f00\u53d1\u4e86\u6269\u5c55\u7684FRET\u5de5\u5177\uff0c\u80fd\u591f\u81ea\u52a8\u5c06\u7ed3\u6784\u5316\u81ea\u7136\u8bed\u8a00\u6982\u7387\u9700\u6c42\u8f6c\u6362\u4e3a\u6b63\u786e\u7684\u6982\u7387\u65f6\u5e8f\u903b\u8f91\u516c\u5f0f\uff0c\u63d0\u9ad8\u4e86\u5f62\u5f0f\u5316\u5206\u6790\u7684\u5b9e\u7528\u6027\u548c\u53ef\u9760\u6027\u3002", "conclusion": "\u8be5\u65b9\u6cd5\u4f7f\u81ea\u4e3b\u81ea\u9002\u5e94\u7cfb\u7edf\u7684\u6982\u7387\u9700\u6c42\u89c4\u8303\u66f4\u52a0\u5b9e\u7528\u548c\u53ef\u9760\uff0c\u964d\u4f4e\u4e86\u5f62\u5f0f\u5316\u5206\u6790\u7684\u95e8\u69db\u548c\u9519\u8bef\u7387\u3002"}}
{"id": "2512.16134", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2512.16134", "abs": "https://arxiv.org/abs/2512.16134", "authors": ["Jian Tian", "Shuailong Li", "Yang Cao", "Wenbo Cui", "Minghan Zhu", "Wenkang Wu", "Jianming Zhang", "Yanpeng Wang", "Zhiwen Xiao", "Zhenyu Hou", "Dou Shen"], "title": "Staggered Batch Scheduling: Co-optimizing Time-to-First-Token and Throughput for High-Efficiency LLM Inference", "comment": null, "summary": "The evolution of Large Language Model (LLM) serving towards complex, distributed architectures--specifically the P/D-separated, large-scale DP+EP paradigm--introduces distinct scheduling challenges. Unlike traditional deployments where schedulers can treat instances as black boxes, DP+EP architectures exhibit high internal synchronization costs. We identify that immediate request dispatching in such systems leads to severe in-engine queuing and parallelization bubbles, degrading Time-to-First-Token (TTFT). To address this, we propose Staggered Batch Scheduling (SBS), a mechanism that deliberately buffers requests to form optimal execution batches. This temporal decoupling eliminates internal queuing bubbles without compromising throughput. Furthermore, leveraging the scheduling window created by buffering, we introduce a Load-Aware Global Allocation strategy that balances computational load across DP units for both Prefill and Decode phases. Deployed on a production H800 cluster serving Deepseek-V3, our system reduces TTFT by 30%-40% and improves throughput by 15%-20% compared to state-of-the-art immediate scheduling baselines.", "AI": {"tldr": "\u63d0\u51faStaggered Batch Scheduling (SBS)\u673a\u5236\uff0c\u901a\u8fc7\u7f13\u51b2\u8bf7\u6c42\u5f62\u6210\u6700\u4f18\u6267\u884c\u6279\u6b21\uff0c\u89e3\u51b3DP+EP\u67b6\u6784\u4e2d\u7684\u8c03\u5ea6\u95ee\u9898\uff0c\u964d\u4f4eTTFT 30%-40%\uff0c\u63d0\u5347\u541e\u5410\u91cf15%-20%", "motivation": "\u968f\u7740LLM\u670d\u52a1\u5411\u590d\u6742\u5206\u5e03\u5f0f\u67b6\u6784\uff08\u7279\u522b\u662fP/D\u5206\u79bb\u7684\u5927\u89c4\u6a21DP+EP\u8303\u5f0f\uff09\u6f14\u8fdb\uff0c\u4f20\u7edf\u8c03\u5ea6\u65b9\u6cd5\u65e0\u6cd5\u5e94\u5bf9\u9ad8\u5185\u90e8\u540c\u6b65\u6210\u672c\u3002\u7acb\u5373\u8bf7\u6c42\u8c03\u5ea6\u4f1a\u5bfc\u81f4\u4e25\u91cd\u7684\u5f15\u64ce\u5185\u6392\u961f\u548c\u5e76\u884c\u5316\u6c14\u6ce1\uff0c\u964d\u4f4e\u9996\u6b21\u4ee4\u724c\u65f6\u95f4(TTFT)\u3002", "method": "\u63d0\u51faStaggered Batch Scheduling (SBS)\u673a\u5236\uff0c\u901a\u8fc7\u6545\u610f\u7f13\u51b2\u8bf7\u6c42\u5f62\u6210\u6700\u4f18\u6267\u884c\u6279\u6b21\uff0c\u5b9e\u73b0\u65f6\u95f4\u89e3\u8026\u6d88\u9664\u5185\u90e8\u6392\u961f\u6c14\u6ce1\u3002\u540c\u65f6\u5229\u7528\u7f13\u51b2\u521b\u5efa\u7684\u8c03\u5ea6\u7a97\u53e3\uff0c\u5f15\u5165\u8d1f\u8f7d\u611f\u77e5\u5168\u5c40\u5206\u914d\u7b56\u7565\uff0c\u5e73\u8861DP\u5355\u5143\u5728Prefill\u548cDecode\u9636\u6bb5\u7684\u8ba1\u7b97\u8d1f\u8f7d\u3002", "result": "\u5728\u751f\u4ea7H800\u96c6\u7fa4\u4e0a\u90e8\u7f72\u670d\u52a1Deepseek-V3\uff0c\u76f8\u6bd4\u6700\u5148\u8fdb\u7684\u7acb\u5373\u8c03\u5ea6\u57fa\u7ebf\uff0c\u7cfb\u7edf\u5c06TTFT\u964d\u4f4e30%-40%\uff0c\u541e\u5410\u91cf\u63d0\u534715%-20%\u3002", "conclusion": "Staggered Batch Scheduling\u673a\u5236\u6709\u6548\u89e3\u51b3\u4e86DP+EP\u67b6\u6784\u4e2d\u7684\u8c03\u5ea6\u6311\u6218\uff0c\u901a\u8fc7\u7f13\u51b2\u548c\u8d1f\u8f7d\u611f\u77e5\u8c03\u5ea6\u663e\u8457\u6539\u5584\u4e86LLM\u670d\u52a1\u7684\u54cd\u5e94\u65f6\u95f4\u548c\u541e\u5410\u6027\u80fd\u3002"}}
{"id": "2512.15816", "categories": ["cs.PL", "cs.AI", "cs.LO"], "pdf": "https://arxiv.org/pdf/2512.15816", "abs": "https://arxiv.org/abs/2512.15816", "authors": ["Daragh King", "Vasileios Koutavas", "Laura Kovacs"], "title": "A Neurosymbolic Approach to Loop Invariant Generation via Weakest Precondition Reasoning", "comment": null, "summary": "Loop invariant generation remains a critical bottleneck in automated program verification. Recent work has begun to explore the use of Large Language Models (LLMs) in this area, yet these approaches tend to lack a reliable and structured methodology, with little reference to existing program verification theory. This paper presents NeuroInv, a neurosymbolic approach to loop invariant generation. NeuroInv comprises two key modules: (1) a neural reasoning module that leverages LLMs and Hoare logic to derive and refine candidate invariants via backward-chaining weakest precondition reasoning, and (2) a verification-guided symbolic module that iteratively repairs invariants using counterexamples from OpenJML. We evaluate NeuroInv on a comprehensive benchmark of 150 Java programs, encompassing single and multiple (sequential) loops, multiple arrays, random branching, and noisy code segments. NeuroInv achieves a $99.5\\%$ success rate, substantially outperforming the other evaluated approaches. Additionally, we introduce a hard benchmark of $10$ larger multi-loop programs (with an average of $7$ loops each); NeuroInv's performance in this setting demonstrates that it can scale to more complex verification scenarios.", "AI": {"tldr": "NeuroInv\u662f\u4e00\u4e2a\u795e\u7ecf\u7b26\u53f7\u65b9\u6cd5\uff0c\u901a\u8fc7\u7ed3\u5408LLM\u7684\u795e\u7ecf\u63a8\u7406\u548c\u57fa\u4e8e\u53cd\u4f8b\u7684\u7b26\u53f7\u4fee\u590d\uff0c\u5b9e\u73b0\u4e8699.5%\u7684\u5faa\u73af\u4e0d\u53d8\u5f0f\u751f\u6210\u6210\u529f\u7387\u3002", "motivation": "\u73b0\u6709\u7684\u57fa\u4e8eLLM\u7684\u5faa\u73af\u4e0d\u53d8\u5f0f\u751f\u6210\u65b9\u6cd5\u7f3a\u4e4f\u53ef\u9760\u7684\u7ed3\u6784\u5316\u65b9\u6cd5\uff0c\u4e14\u5f88\u5c11\u53c2\u8003\u73b0\u6709\u7684\u7a0b\u5e8f\u9a8c\u8bc1\u7406\u8bba\u3002\u5faa\u73af\u4e0d\u53d8\u5f0f\u751f\u6210\u4ecd\u7136\u662f\u81ea\u52a8\u5316\u7a0b\u5e8f\u9a8c\u8bc1\u7684\u5173\u952e\u74f6\u9888\u3002", "method": "NeuroInv\u5305\u542b\u4e24\u4e2a\u5173\u952e\u6a21\u5757\uff1a(1) \u795e\u7ecf\u63a8\u7406\u6a21\u5757\uff1a\u5229\u7528LLM\u548c\u970d\u5c14\u903b\u8f91\uff0c\u901a\u8fc7\u540e\u5411\u94fe\u5f0f\u6700\u5f31\u524d\u7f6e\u6761\u4ef6\u63a8\u7406\u6765\u63a8\u5bfc\u548c\u7cbe\u5316\u5019\u9009\u4e0d\u53d8\u5f0f\uff1b(2) \u9a8c\u8bc1\u5f15\u5bfc\u7684\u7b26\u53f7\u6a21\u5757\uff1a\u4f7f\u7528OpenJML\u7684\u53cd\u4f8b\u8fed\u4ee3\u4fee\u590d\u4e0d\u53d8\u5f0f\u3002", "result": "\u5728150\u4e2aJava\u7a0b\u5e8f\u7684\u7efc\u5408\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0cNeuroInv\u8fbe\u5230\u4e8699.5%\u7684\u6210\u529f\u7387\uff0c\u663e\u8457\u4f18\u4e8e\u5176\u4ed6\u8bc4\u4f30\u65b9\u6cd5\u3002\u5728\u5305\u542b10\u4e2a\u66f4\u5927\u89c4\u6a21\u591a\u5faa\u73af\u7a0b\u5e8f\uff08\u5e73\u5747\u6bcf\u4e2a\u7a0b\u5e8f7\u4e2a\u5faa\u73af\uff09\u7684\u56f0\u96be\u57fa\u51c6\u6d4b\u8bd5\u4e2d\uff0cNeuroInv\u4e5f\u8868\u73b0\u51fa\u8272\uff0c\u8bc1\u660e\u5176\u53ef\u4ee5\u6269\u5c55\u5230\u66f4\u590d\u6742\u7684\u9a8c\u8bc1\u573a\u666f\u3002", "conclusion": "NeuroInv\u901a\u8fc7\u795e\u7ecf\u7b26\u53f7\u65b9\u6cd5\u6210\u529f\u89e3\u51b3\u4e86\u5faa\u73af\u4e0d\u53d8\u5f0f\u751f\u6210\u95ee\u9898\uff0c\u5c06LLM\u7684\u80fd\u529b\u4e0e\u4f20\u7edf\u7684\u7a0b\u5e8f\u9a8c\u8bc1\u7406\u8bba\u76f8\u7ed3\u5408\uff0c\u4e3a\u81ea\u52a8\u5316\u7a0b\u5e8f\u9a8c\u8bc1\u63d0\u4f9b\u4e86\u6709\u6548\u7684\u89e3\u51b3\u65b9\u6848\u3002"}}
{"id": "2512.16136", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16136", "abs": "https://arxiv.org/abs/2512.16136", "authors": ["Zhisheng Hu", "Pengfei Zuo", "Junliang Hu", "Yizou Chen", "Yingjia Wang", "Ming-Chang Yang"], "title": "Lotus: Optimizing Disaggregated Transactions with Disaggregated Locks", "comment": null, "summary": "Disaggregated memory (DM) separates compute and memory resources, allowing flexible scaling to achieve high resource utilization. To ensure atomic and consistent data access on DM, distributed transaction systems have been adapted, where compute nodes (CNs) rely on one-sided RDMA operations to access remote data in memory nodes (MNs). However, we observe that in existing transaction systems, the RDMA network interface cards at MNs become a primary performance bottleneck. This bottleneck arises from the high volume of one-sided atomic operations used for locks, which hinders the system's ability to scale efficiently.\n  To address this issue, this paper presents Lotus, a scalable distributed transaction system with lock disaggregation on DM. The key innovation of Lotus is to disaggregate locks from data and execute all locks on CNs, thus eliminating the bottleneck at MN RNICs. To achieve efficient lock management on CNs, Lotus employs an application-aware lock management mechanism that leverages the locality of the OLTP workloads to shard locks while maintaining load balance. To ensure consistent transaction processing with lock disaggregation, Lotus introduces a lock-first transaction protocol, which separates the locking phase as the first step in each read-write transaction execution. This protocol allows the system to determine the success of lock acquisitions early and proactively abort conflicting transactions, improving overall efficiency. To tolerate lock loss during CN failures, Lotus employs a lock-rebuild-free recovery mechanism that treats locks as ephemeral and avoids their reconstruction, ensuring lightweight recovery for CN failures. Experimental results demonstrate that Lotus improves transaction throughput by up to 2.1$\\times$ and reduces latency by up to 49.4% compared to state-of-the-art transaction systems on DM.", "AI": {"tldr": "Lotus\u63d0\u51fa\u4e86\u4e00\u79cd\u5728\u5206\u89e3\u5185\u5b58\u67b6\u6784\u4e0a\u5b9e\u73b0\u9501\u5206\u89e3\u7684\u5206\u5e03\u5f0f\u4e8b\u52a1\u7cfb\u7edf\uff0c\u901a\u8fc7\u5c06\u9501\u7ba1\u7406\u4ece\u5185\u5b58\u8282\u70b9\u8f6c\u79fb\u5230\u8ba1\u7b97\u8282\u70b9\uff0c\u89e3\u51b3\u4e86RDMA\u7f51\u7edc\u63a5\u53e3\u5361\u7684\u6027\u80fd\u74f6\u9888\u95ee\u9898\u3002", "motivation": "\u73b0\u6709\u5206\u89e3\u5185\u5b58\u4e0a\u7684\u5206\u5e03\u5f0f\u4e8b\u52a1\u7cfb\u7edf\u4e2d\uff0c\u5185\u5b58\u8282\u70b9\u7684RDMA\u7f51\u7edc\u63a5\u53e3\u5361\u6210\u4e3a\u4e3b\u8981\u6027\u80fd\u74f6\u9888\uff0c\u8fd9\u6e90\u4e8e\u5927\u91cf\u7528\u4e8e\u9501\u64cd\u4f5c\u7684\u5355\u8fb9\u539f\u5b50\u64cd\u4f5c\uff0c\u9650\u5236\u4e86\u7cfb\u7edf\u7684\u53ef\u6269\u5c55\u6027\u3002", "method": "1. \u9501\u5206\u89e3\uff1a\u5c06\u9501\u4ece\u6570\u636e\u4e2d\u5206\u79bb\uff0c\u6240\u6709\u9501\u64cd\u4f5c\u5728\u8ba1\u7b97\u8282\u70b9\u4e0a\u6267\u884c\uff1b2. \u5e94\u7528\u611f\u77e5\u7684\u9501\u7ba1\u7406\u673a\u5236\uff1a\u5229\u7528OLTP\u5de5\u4f5c\u8d1f\u8f7d\u7684\u5c40\u90e8\u6027\u8fdb\u884c\u9501\u5206\u7247\uff0c\u540c\u65f6\u4fdd\u6301\u8d1f\u8f7d\u5747\u8861\uff1b3. \u9501\u4f18\u5148\u4e8b\u52a1\u534f\u8bae\uff1a\u5c06\u9501\u5b9a\u9636\u6bb5\u4f5c\u4e3a\u8bfb\u5199\u4e8b\u52a1\u6267\u884c\u7684\u7b2c\u4e00\u6b65\uff1b4. \u65e0\u9501\u91cd\u5efa\u6062\u590d\u673a\u5236\uff1a\u5c06\u9501\u89c6\u4e3a\u4e34\u65f6\u72b6\u6001\uff0c\u907f\u514d\u5728\u8ba1\u7b97\u8282\u70b9\u6545\u969c\u65f6\u91cd\u5efa\u9501\u3002", "result": "\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u4e0e\u73b0\u6709\u6700\u5148\u8fdb\u7684\u5206\u89e3\u5185\u5b58\u4e8b\u52a1\u7cfb\u7edf\u76f8\u6bd4\uff0cLotus\u5c06\u4e8b\u52a1\u541e\u5410\u91cf\u63d0\u9ad8\u4e86\u6700\u591a2.1\u500d\uff0c\u5e76\u5c06\u5ef6\u8fdf\u964d\u4f4e\u4e86\u6700\u591a49.4%\u3002", "conclusion": "Lotus\u901a\u8fc7\u9501\u5206\u89e3\u548c\u521b\u65b0\u7684\u9501\u7ba1\u7406\u673a\u5236\uff0c\u6709\u6548\u89e3\u51b3\u4e86\u5206\u89e3\u5185\u5b58\u7cfb\u7edf\u4e2dRDMA\u7f51\u7edc\u63a5\u53e3\u5361\u7684\u74f6\u9888\u95ee\u9898\uff0c\u663e\u8457\u63d0\u5347\u4e86\u5206\u5e03\u5f0f\u4e8b\u52a1\u7cfb\u7edf\u7684\u6027\u80fd\u548c\u53ef\u6269\u5c55\u6027\u3002"}}
{"id": "2512.15834", "categories": ["cs.PL", "cs.AI", "cs.DC", "cs.PF", "cs.SE"], "pdf": "https://arxiv.org/pdf/2512.15834", "abs": "https://arxiv.org/abs/2512.15834", "authors": ["Daniel Nichols", "Prajwal Singhania", "Charles Jekel", "Abhinav Bhatele", "Harshitha Menon"], "title": "Optimizing Agentic Language Model Inference via Speculative Tool Calls", "comment": null, "summary": "Language models (LMs) are becoming increasingly dependent on external tools. LM-based agentic frameworks frequently interact with their environment via such tools to search files, run code, call APIs, etc. Further, modern reasoning-based LMs use tools such as web search and Python code execution to enhance their reasoning capabilities. While tools greatly improve the capabilities of LMs, they also introduce performance bottlenecks during the inference process. In this paper, we introduce novel systems optimizations to address such performance bottlenecks by speculating tool calls and forcing sequences to remain resident in the inference engine to minimize overheads. Our optimizations lead to throughput improvements of several hundred tokens per second when hosting inference for LM agents. We provide a theoretical analysis of our algorithms to provide insights into speculation configurations that will yield the best performance. Further, we recommend a new \"tool cache\" API endpoint to enable LM providers to easily adopt these optimizations.", "AI": {"tldr": "\u63d0\u51fa\u9488\u5bf9\u8bed\u8a00\u6a21\u578b\u5de5\u5177\u8c03\u7528\u6027\u80fd\u74f6\u9888\u7684\u7cfb\u7edf\u4f18\u5316\u65b9\u6848\uff0c\u901a\u8fc7\u63a8\u6d4b\u5de5\u5177\u8c03\u7528\u548c\u4fdd\u6301\u5e8f\u5217\u9a7b\u7559\u6765\u63d0\u5347\u63a8\u7406\u541e\u5410\u91cf", "motivation": "\u8bed\u8a00\u6a21\u578b\u8d8a\u6765\u8d8a\u4f9d\u8d56\u5916\u90e8\u5de5\u5177\uff08\u6587\u4ef6\u641c\u7d22\u3001\u4ee3\u7801\u6267\u884c\u3001API\u8c03\u7528\u7b49\uff09\uff0c\u8fd9\u4e9b\u5de5\u5177\u867d\u7136\u589e\u5f3a\u4e86\u6a21\u578b\u80fd\u529b\uff0c\u4f46\u4e5f\u5728\u63a8\u7406\u8fc7\u7a0b\u4e2d\u5f15\u5165\u4e86\u6027\u80fd\u74f6\u9888\uff0c\u5f71\u54cd\u63a8\u7406\u541e\u5410\u91cf", "method": "\u91c7\u7528\u63a8\u6d4b\u5de5\u5177\u8c03\u7528\u548c\u5f3a\u5236\u5e8f\u5217\u5728\u63a8\u7406\u5f15\u64ce\u4e2d\u4fdd\u6301\u9a7b\u7559\u7684\u7cfb\u7edf\u4f18\u5316\u65b9\u6cd5\uff0c\u51cf\u5c11\u5f00\u9500\uff1b\u63d0\u51fa\u7406\u8bba\u5206\u6790\u6307\u5bfc\u6700\u4f73\u63a8\u6d4b\u914d\u7f6e\uff0c\u5e76\u5efa\u8bae\u65b0\u7684\"\u5de5\u5177\u7f13\u5b58\"API\u7aef\u70b9", "result": "\u4f18\u5316\u65b9\u6848\u4f7fLM\u4ee3\u7406\u63a8\u7406\u7684\u541e\u5410\u91cf\u63d0\u5347\u6570\u767e\u4e2atoken/\u79d2", "conclusion": "\u901a\u8fc7\u7cfb\u7edf\u4f18\u5316\u89e3\u51b3\u5de5\u5177\u8c03\u7528\u5e26\u6765\u7684\u6027\u80fd\u74f6\u9888\u662f\u53ef\u884c\u7684\uff0c\u63d0\u51fa\u7684\u4f18\u5316\u65b9\u6cd5\u548cAPI\u5efa\u8bae\u80fd\u591f\u663e\u8457\u63d0\u5347\u8bed\u8a00\u6a21\u578b\u4ee3\u7406\u7684\u63a8\u7406\u6548\u7387"}}
{"id": "2512.16148", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16148", "abs": "https://arxiv.org/abs/2512.16148", "authors": ["Zhisheng Hu", "Jiacheng Shen", "Ming-Chang Yang"], "title": "FlexKV: Flexible Index Offloading for Memory-Disaggregated Key-Value Store", "comment": null, "summary": "Disaggregated memory (DM) is a promising data center architecture that decouples CPU and memory into independent resource pools to improve resource utilization. Building on DM, memory-disaggregated key-value (KV) stores are adopted to efficiently manage remote data. Unfortunately, existing approaches suffer from poor performance due to two critical issues: 1) the overdependence on one-sided atomic operations in index processing, and 2) the constrained efficiency in compute-side caches. To address these issues, we propose FlexKV, a memory-disaggregated KV store with index proxying. Our key idea is to dynamically offload the index to compute nodes, leveraging their powerful CPUs to accelerate index processing and maintain high-performance compute-side caches. Three challenges have to be addressed to enable efficient index proxying on DM, i.e., the load imbalance across compute nodes, the limited memory of compute nodes, and the expensive cache coherence overhead. FlexKV proposes: 1) a rank-aware hotness detection algorithm to continuously balance index load across compute nodes, 2) a two-level CN memory optimization scheme to efficiently utilize compute node memory, and 3) an RPC-aggregated cache management mechanism to reduce cache coherence overhead. The experimental results show that FlexKV improves throughput by up to 2.94$\\times$ and reduces latency by up to 85.2%, compared with the state-of-the-art memory-disaggregated KV stores.", "AI": {"tldr": "FlexKV\u662f\u4e00\u4e2a\u5185\u5b58\u89e3\u8026\u7684\u952e\u503c\u5b58\u50a8\u7cfb\u7edf\uff0c\u901a\u8fc7\u7d22\u5f15\u4ee3\u7406\u6280\u672f\u5c06\u7d22\u5f15\u52a8\u6001\u5378\u8f7d\u5230\u8ba1\u7b97\u8282\u70b9\uff0c\u89e3\u51b3\u4e86\u73b0\u6709\u7cfb\u7edf\u5bf9\u5355\u8fb9\u539f\u5b50\u64cd\u4f5c\u7684\u8fc7\u5ea6\u4f9d\u8d56\u548c\u8ba1\u7b97\u4fa7\u7f13\u5b58\u6548\u7387\u53d7\u9650\u7684\u95ee\u9898\uff0c\u5b9e\u73b0\u4e86\u9ad8\u8fbe2.94\u500d\u7684\u541e\u5410\u91cf\u63d0\u5347\u548c85.2%\u7684\u5ef6\u8fdf\u964d\u4f4e\u3002", "motivation": "\u5185\u5b58\u89e3\u8026\u67b6\u6784\u5c06CPU\u548c\u5185\u5b58\u89e3\u8026\u4e3a\u72ec\u7acb\u8d44\u6e90\u6c60\u4ee5\u63d0\u9ad8\u5229\u7528\u7387\uff0c\u4f46\u73b0\u6709\u7684\u5185\u5b58\u89e3\u8026\u952e\u503c\u5b58\u50a8\u5b58\u5728\u6027\u80fd\u95ee\u9898\uff1a1\uff09\u7d22\u5f15\u5904\u7406\u8fc7\u5ea6\u4f9d\u8d56\u5355\u8fb9\u539f\u5b50\u64cd\u4f5c\uff1b2\uff09\u8ba1\u7b97\u4fa7\u7f13\u5b58\u6548\u7387\u53d7\u9650\u3002\u8fd9\u4e9b\u95ee\u9898\u5bfc\u81f4\u6027\u80fd\u4e0d\u4f73\u3002", "method": "FlexKV\u63d0\u51fa\u7d22\u5f15\u4ee3\u7406\u6280\u672f\uff0c\u5c06\u7d22\u5f15\u52a8\u6001\u5378\u8f7d\u5230\u8ba1\u7b97\u8282\u70b9\uff0c\u5229\u7528\u5176\u5f3a\u5927CPU\u52a0\u901f\u7d22\u5f15\u5904\u7406\u3002\u5177\u4f53\u89e3\u51b3\u4e09\u4e2a\u6311\u6218\uff1a1\uff09\u57fa\u4e8e\u7b49\u7ea7\u611f\u77e5\u7684\u70ed\u5ea6\u68c0\u6d4b\u7b97\u6cd5\u5e73\u8861\u7d22\u5f15\u8d1f\u8f7d\uff1b2\uff09\u4e24\u7ea7\u8ba1\u7b97\u8282\u70b9\u5185\u5b58\u4f18\u5316\u65b9\u6848\u9ad8\u6548\u5229\u7528\u5185\u5b58\uff1b3\uff09RPC\u805a\u5408\u7684\u7f13\u5b58\u7ba1\u7406\u673a\u5236\u964d\u4f4e\u7f13\u5b58\u4e00\u81f4\u6027\u5f00\u9500\u3002", "result": "\u5b9e\u9a8c\u7ed3\u679c\u663e\u793a\uff0c\u4e0e\u6700\u5148\u8fdb\u7684\u5185\u5b58\u89e3\u8026\u952e\u503c\u5b58\u50a8\u76f8\u6bd4\uff0cFlexKV\u5c06\u541e\u5410\u91cf\u63d0\u5347\u9ad8\u8fbe2.94\u500d\uff0c\u5ef6\u8fdf\u964d\u4f4e\u9ad8\u8fbe85.2%\u3002", "conclusion": "FlexKV\u901a\u8fc7\u7d22\u5f15\u4ee3\u7406\u6280\u672f\u6709\u6548\u89e3\u51b3\u4e86\u5185\u5b58\u89e3\u8026\u952e\u503c\u5b58\u50a8\u7684\u6027\u80fd\u74f6\u9888\uff0c\u663e\u8457\u63d0\u5347\u4e86\u7cfb\u7edf\u6027\u80fd\uff0c\u4e3a\u5185\u5b58\u89e3\u8026\u67b6\u6784\u4e0b\u7684\u9ad8\u6548\u6570\u636e\u7ba1\u7406\u63d0\u4f9b\u4e86\u65b0\u601d\u8def\u3002"}}
{"id": "2512.16455", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2512.16455", "abs": "https://arxiv.org/abs/2512.16455", "authors": ["Ignacio Heredia", "\u00c1lvaro L\u00f3pez Garc\u00eda", "Germ\u00e1n Molt\u00f3", "Amanda Calatrava", "Valentin Kozlov", "Alessandro Costantini", "Viet Tran", "Mario David", "Daniel San Mart\u00edn", "Marcin P\u0142\u00f3ciennik", "Marta Obreg\u00f3n Ruiz", "Sa\u00fal Fernandez", "Judith S\u00e1inz-Pardo D\u00edaz", "Miguel Caballer", "Caterina Alarc\u00f3n Mar\u00edn", "Stefan Dlugolinsky", "Martin \u0160eleng", "Lisana Berberi", "Khadijeh Alibabaei", "Borja Esteban Sanchis", "Pedro Castro", "Giacinto Donvito", "Diego Aguirre", "Sergio Langarita", "Vicente Rodriguez", "Leonhard Duda", "Andr\u00e9s Heredia Canales", "Susana Rebolledo Ruiz", "Jo\u00e3o Machado", "Giang Nguyen", "Fernando Aguilar G\u00f3mez", "Jaime D\u00edez"], "title": "AI4EOSC: a Federated Cloud Platform for Artificial Intelligence in Scientific Research", "comment": null, "summary": "In this paper, we describe a federated compute platform dedicated to support Artificial Intelligence in scientific workloads. Putting the effort into reproducible deployments, it delivers consistent, transparent access to a federation of physically distributed e-Infrastructures. Through a comprehensive service catalogue, the platform is able to offer an integrated user experience covering the full Machine Learning lifecycle, including model development (with dedicated interactive development environments), training (with GPU resources, annotation tools, experiment tracking, and federated learning support) and deployment (covering a wide range of deployment options all along the Cloud Continuum). The platform also provides tools for traceability and reproducibility of AI models, integrates with different Artificial Intelligence model providers, datasets and storage resources, allowing users to interact with the broader Machine Learning ecosystem. Finally, it is easily customizable to lower the adoption barrier by external communities.", "AI": {"tldr": "\u672c\u6587\u4ecb\u7ecd\u4e86\u4e00\u4e2a\u4e13\u4e3a\u79d1\u5b66AI\u5de5\u4f5c\u8d1f\u8f7d\u8bbe\u8ba1\u7684\u8054\u90a6\u8ba1\u7b97\u5e73\u53f0\uff0c\u63d0\u4f9b\u8986\u76d6\u5b8c\u6574\u673a\u5668\u5b66\u4e60\u751f\u547d\u5468\u671f\u7684\u96c6\u6210\u670d\u52a1\uff0c\u652f\u6301\u6a21\u578b\u5f00\u53d1\u3001\u8bad\u7ec3\u548c\u90e8\u7f72\uff0c\u5e76\u6ce8\u91cd\u53ef\u91cd\u590d\u6027\u548c\u53ef\u5b9a\u5236\u6027\u3002", "motivation": "\u4e3a\u79d1\u5b66AI\u5de5\u4f5c\u8d1f\u8f7d\u63d0\u4f9b\u53ef\u91cd\u590d\u90e8\u7f72\u7684\u8054\u90a6\u8ba1\u7b97\u5e73\u53f0\uff0c\u5b9e\u73b0\u5bf9\u7269\u7406\u5206\u5e03\u5f0f\u7535\u5b50\u57fa\u7840\u8bbe\u65bd\u7684\u4e00\u81f4\u900f\u660e\u8bbf\u95ee\uff0c\u964d\u4f4e\u5916\u90e8\u793e\u533a\u91c7\u7528\u95e8\u69db\u3002", "method": "\u901a\u8fc7\u5168\u9762\u7684\u670d\u52a1\u76ee\u5f55\u6784\u5efa\u8054\u90a6\u8ba1\u7b97\u5e73\u53f0\uff0c\u63d0\u4f9b\u4ea4\u4e92\u5f0f\u5f00\u53d1\u73af\u5883\u3001GPU\u8d44\u6e90\u3001\u6ce8\u91ca\u5de5\u5177\u3001\u5b9e\u9a8c\u8ddf\u8e2a\u3001\u8054\u90a6\u5b66\u4e60\u652f\u6301\uff0c\u4ee5\u53ca\u8986\u76d6\u4e91\u8fde\u7eed\u4f53\u7684\u591a\u79cd\u90e8\u7f72\u9009\u9879\u3002", "result": "\u5e73\u53f0\u80fd\u591f\u63d0\u4f9b\u5b8c\u6574\u7684\u673a\u5668\u5b66\u4e60\u751f\u547d\u5468\u671f\u7ba1\u7406\uff0c\u96c6\u6210\u591a\u79cdAI\u6a21\u578b\u63d0\u4f9b\u5546\u3001\u6570\u636e\u96c6\u548c\u5b58\u50a8\u8d44\u6e90\uff0c\u652f\u6301AI\u6a21\u578b\u7684\u53ef\u8ffd\u6eaf\u6027\u548c\u53ef\u91cd\u590d\u6027\uff0c\u5e76\u4e0e\u66f4\u5e7f\u6cdb\u7684\u673a\u5668\u5b66\u4e60\u751f\u6001\u7cfb\u7edf\u4ea4\u4e92\u3002", "conclusion": "\u8be5\u8054\u90a6\u8ba1\u7b97\u5e73\u53f0\u6210\u529f\u4e3a\u79d1\u5b66AI\u5de5\u4f5c\u8d1f\u8f7d\u63d0\u4f9b\u4e86\u5168\u9762\u652f\u6301\uff0c\u901a\u8fc7\u53ef\u5b9a\u5236\u5316\u8bbe\u8ba1\u964d\u4f4e\u4e86\u5916\u90e8\u793e\u533a\u7684\u91c7\u7528\u95e8\u69db\uff0c\u5b9e\u73b0\u4e86\u5206\u5e03\u5f0f\u57fa\u7840\u8bbe\u65bd\u7684\u900f\u660e\u8bbf\u95ee\u548c\u5b8c\u6574\u673a\u5668\u5b66\u4e60\u751f\u547d\u5468\u671f\u7ba1\u7406\u3002"}}
{"id": "2512.16473", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2512.16473", "abs": "https://arxiv.org/abs/2512.16473", "authors": ["En-Ming Huang", "Li-Shang Lin", "Chun-Yi Lee"], "title": "Efficient CPU-GPU Collaborative Inference for MoE-based LLMs on Memory-Limited Systems", "comment": "7 pages, 6 figures, to be published in ASP-DAC 2026", "summary": "Large Language Models (LLMs) have achieved impressive results across various tasks, yet their high computational demands pose deployment challenges, especially on consumer-grade hardware. Mixture of Experts (MoE) models provide an efficient solution through selective activation of parameter subsets, which reduces computation requirements. Despite this efficiency, state-of-the-art MoE models still require substantial memory beyond typical consumer GPU capacities. Traditional offloading methods that transfer model weights between CPU and GPU introduce latency, limiting inference performance. This paper presents a novel CPU-GPU collaborative inference framework that incorporates an expert caching mechanism on the GPU to reduce data transfer requirements and enable faster inference through cache hits. Computations are offloaded to CPU for efficient cache miss handling, which benefits from CPU multithreading optimizations. The evaluations of our framework demonstrate performance improvements and highlight the potential of CPU-GPU collaboration to maximize hardware utilization for single-request inference scenarios on consumer-grade systems. The implementation of our framework is available at https://github.com/elsa-lab/MoE-CPU-GPU-Collaborative-Inference.", "AI": {"tldr": "\u63d0\u51fa\u4e86\u4e00\u79cdCPU-GPU\u534f\u4f5c\u63a8\u7406\u6846\u67b6\uff0c\u901a\u8fc7GPU\u4e13\u5bb6\u7f13\u5b58\u673a\u5236\u51cf\u5c11\u6570\u636e\u4f20\u8f93\uff0c\u5229\u7528CPU\u591a\u7ebf\u7a0b\u5904\u7406\u7f13\u5b58\u672a\u547d\u4e2d\uff0c\u5728\u6d88\u8d39\u7ea7\u786c\u4ef6\u4e0a\u63d0\u5347MoE\u6a21\u578b\u63a8\u7406\u6027\u80fd\u3002", "motivation": "\u5927\u578b\u8bed\u8a00\u6a21\u578b\u8ba1\u7b97\u9700\u6c42\u9ad8\uff0cMoE\u6a21\u578b\u867d\u80fd\u9009\u62e9\u6027\u6fc0\u6d3b\u53c2\u6570\u51cf\u5c11\u8ba1\u7b97\uff0c\u4f46\u4ecd\u9700\u5927\u91cf\u5185\u5b58\u8d85\u51fa\u6d88\u8d39\u7ea7GPU\u5bb9\u91cf\u3002\u4f20\u7edf\u5378\u8f7d\u65b9\u6cd5\u5728CPU\u548cGPU\u95f4\u4f20\u8f93\u6743\u91cd\u4f1a\u5f15\u5165\u5ef6\u8fdf\uff0c\u9650\u5236\u63a8\u7406\u6027\u80fd\u3002", "method": "\u63d0\u51faCPU-GPU\u534f\u4f5c\u63a8\u7406\u6846\u67b6\uff1a1) GPU\u4e0a\u5b9e\u73b0\u4e13\u5bb6\u7f13\u5b58\u673a\u5236\uff0c\u51cf\u5c11\u6570\u636e\u4f20\u8f93\u9700\u6c42\uff1b2) \u8ba1\u7b97\u5378\u8f7d\u5230CPU\uff0c\u5229\u7528CPU\u591a\u7ebf\u7a0b\u4f18\u5316\u5904\u7406\u7f13\u5b58\u672a\u547d\u4e2d\uff1b3) \u6700\u5927\u5316\u6d88\u8d39\u7ea7\u7cfb\u7edf\u786c\u4ef6\u5229\u7528\u7387\u3002", "result": "\u8bc4\u4f30\u663e\u793a\u8be5\u6846\u67b6\u80fd\u63d0\u5347\u6027\u80fd\uff0c\u8bc1\u660e\u4e86CPU-GPU\u534f\u4f5c\u5728\u5355\u8bf7\u6c42\u63a8\u7406\u573a\u666f\u4e0b\u6700\u5927\u5316\u786c\u4ef6\u5229\u7528\u7684\u6f5c\u529b\u3002\u6846\u67b6\u5b9e\u73b0\u5df2\u5f00\u6e90\u3002", "conclusion": "CPU-GPU\u534f\u4f5c\u63a8\u7406\u6846\u67b6\u901a\u8fc7\u4e13\u5bb6\u7f13\u5b58\u548c\u8ba1\u7b97\u5378\u8f7d\uff0c\u6709\u6548\u89e3\u51b3\u4e86MoE\u6a21\u578b\u5728\u6d88\u8d39\u7ea7\u786c\u4ef6\u4e0a\u7684\u90e8\u7f72\u6311\u6218\uff0c\u5b9e\u73b0\u4e86\u66f4\u5feb\u7684\u63a8\u7406\u901f\u5ea6\u548c\u66f4\u597d\u7684\u786c\u4ef6\u5229\u7528\u7387\u3002"}}
{"id": "2512.16792", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2512.16792", "abs": "https://arxiv.org/abs/2512.16792", "authors": ["Endar Suprih Wihidayat", "Sieteng Soh", "Kwan-Wu Chin", "Duc-son Pham"], "title": "Delay-Aware Multi-Stage Edge Server Upgrade with Budget Constraint", "comment": "17 pages, 9 figures", "summary": "In this paper, the Multi-stage Edge Server Upgrade (M-ESU) is proposed as a new network planning problem, involving the upgrading of an existing multi-access edge computing (MEC) system through multiple stages (e.g., over several years). More precisely, the problem considers two key decisions: (i) whether to deploy additional edge servers or upgrade those already installed, and (ii) how tasks should be offloaded so that the average number of tasks that meet their delay requirement is maximized. The framework specifically involves: (i) deployment of new servers combined with capacity upgrades for existing servers, and (ii) the optimal task offloading to maximize the average number of tasks with a delay requirement. It also considers the following constraints: (i) budget per stage, (ii) server deployment and upgrade cost (in $) and cost depreciation rate, (iii) computation resource of servers, (iv) number of tasks and their growth rate (in %), and (v) the increase in task sizes and stricter delay requirements over time. We present two solutions: a Mixed Integer Linear Programming (MILP) model and an efficient heuristic algorithm (M-ESU/H). MILP yields the optimal solution for small networks, whereas M-ESU/H is used in large-scale networks. For small networks, the simulation results show that the solution computed by M-ESU/H is within 1.25% of the optimal solution while running several orders of magnitude faster. For large networks, M-ESU/H is compared against three alternative heuristic solutions that consider only server deployment, or giving priority to server deployment or upgrade. Our experiments show that M-ESU/H yields up to 21.57% improvement in task satisfaction under identical budget and demand growth conditions, confirming its scalability and practical value for long-term MEC systems.", "AI": {"tldr": "\u63d0\u51fa\u591a\u9636\u6bb5\u8fb9\u7f18\u670d\u52a1\u5668\u5347\u7ea7\uff08M-ESU\uff09\u89c4\u5212\u95ee\u9898\uff0c\u901a\u8fc7\u6df7\u5408\u6574\u6570\u7ebf\u6027\u89c4\u5212\u548c\u542f\u53d1\u5f0f\u7b97\u6cd5\u4f18\u5316\u8fb9\u7f18\u8ba1\u7b97\u7cfb\u7edf\u7684\u957f\u671f\u5347\u7ea7\u51b3\u7b56\uff0c\u5728\u9884\u7b97\u7ea6\u675f\u4e0b\u6700\u5927\u5316\u6ee1\u8db3\u5ef6\u8fdf\u8981\u6c42\u7684\u4efb\u52a1\u6570\u91cf\u3002", "motivation": "\u73b0\u6709\u7684\u591a\u63a5\u5165\u8fb9\u7f18\u8ba1\u7b97\uff08MEC\uff09\u7cfb\u7edf\u9700\u8981\u957f\u671f\u89c4\u5212\u4ee5\u9002\u5e94\u4efb\u52a1\u589e\u957f\u3001\u5ef6\u8fdf\u8981\u6c42\u53d8\u4e25\u683c\u7b49\u53d8\u5316\u3002\u4f20\u7edf\u65b9\u6cd5\u7f3a\u4e4f\u8003\u8651\u591a\u9636\u6bb5\u5347\u7ea7\u51b3\u7b56\uff0c\u65e0\u6cd5\u5728\u9884\u7b97\u7ea6\u675f\u4e0b\u4f18\u5316\u957f\u671f\u6027\u80fd\u3002", "method": "\u63d0\u51faM-ESU\u6846\u67b6\uff0c\u5305\u542b\u4e24\u4e2a\u5173\u952e\u51b3\u7b56\uff1a1\uff09\u90e8\u7f72\u65b0\u670d\u52a1\u5668\u6216\u5347\u7ea7\u73b0\u6709\u670d\u52a1\u5668\uff1b2\uff09\u4efb\u52a1\u5378\u8f7d\u4f18\u5316\u4ee5\u6700\u5927\u5316\u6ee1\u8db3\u5ef6\u8fdf\u8981\u6c42\u7684\u4efb\u52a1\u6570\u91cf\u3002\u63d0\u4f9b\u4e24\u79cd\u89e3\u51b3\u65b9\u6848\uff1a\u6df7\u5408\u6574\u6570\u7ebf\u6027\u89c4\u5212\uff08MILP\uff09\u6a21\u578b\u7528\u4e8e\u5c0f\u578b\u7f51\u7edc\uff0c\u9ad8\u6548\u7684\u542f\u53d1\u5f0f\u7b97\u6cd5\uff08M-ESU/H\uff09\u7528\u4e8e\u5927\u89c4\u6a21\u7f51\u7edc\u3002", "result": "\u5bf9\u4e8e\u5c0f\u578b\u7f51\u7edc\uff0cM-ESU/H\u7b97\u6cd5\u89e3\u4e0e\u6700\u4f18\u89e3\u5dee\u8ddd\u57281.25%\u4ee5\u5185\uff0c\u8fd0\u884c\u901f\u5ea6\u5feb\u51e0\u4e2a\u6570\u91cf\u7ea7\u3002\u5bf9\u4e8e\u5927\u578b\u7f51\u7edc\uff0c\u76f8\u6bd4\u4ec5\u8003\u8651\u670d\u52a1\u5668\u90e8\u7f72\u6216\u4f18\u5148\u90e8\u7f72/\u5347\u7ea7\u7684\u4e09\u79cd\u66ff\u4ee3\u542f\u53d1\u5f0f\u65b9\u6848\uff0cM-ESU/H\u5728\u76f8\u540c\u9884\u7b97\u548c\u9700\u6c42\u589e\u957f\u6761\u4ef6\u4e0b\u4efb\u52a1\u6ee1\u610f\u5ea6\u63d0\u5347\u9ad8\u8fbe21.57%\u3002", "conclusion": "M-ESU\u6846\u67b6\u4e3aMEC\u7cfb\u7edf\u7684\u957f\u671f\u89c4\u5212\u63d0\u4f9b\u4e86\u6709\u6548\u89e3\u51b3\u65b9\u6848\uff0cM-ESU/H\u7b97\u6cd5\u5728\u4fdd\u6301\u63a5\u8fd1\u6700\u4f18\u6027\u80fd\u7684\u540c\u65f6\u5177\u6709\u826f\u597d\u53ef\u6269\u5c55\u6027\uff0c\u9002\u7528\u4e8e\u5b9e\u9645\u5927\u89c4\u6a21\u8fb9\u7f18\u8ba1\u7b97\u7cfb\u7edf\u3002"}}
