{"id": "2507.17233", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.17233", "abs": "https://arxiv.org/abs/2507.17233", "authors": ["Marco Ciccalè", "Daniel Jurjo-Rivas", "Jose F. Morales", "Pedro López-García", "Manuel V. Hermenegildo"], "title": "Hiord: An Approach to the Specification and Verification of Higher-Order (C)LP Programs", "comment": "Accepted for publication in Theory and Practice of Logic Programming\n  (TPLP)", "summary": "Higher-order constructs enable more expressive and concise code by allowing\nprocedures to be parameterized by other procedures. Assertions allow expressing\npartial program specifications, which can be verified either at compile time\n(statically) or run time (dynamically). In higher-order programs, assertions\ncan also describe higher-order arguments. While in the context of (C)LP,\nrun-time verification of higher-order assertions has received some attention,\ncompile-time verification remains relatively unexplored. We propose a novel\napproach for statically verifying higher-order (C)LP programs with higher-order\nassertions. Although we use the Ciao assertion language for illustration, our\napproach is quite general and we believe is applicable to similar contexts.\nHigher-order arguments are described using predicate properties -- a special\nkind of property which exploits the (Ciao) assertion language. We refine the\nsyntax and semantics of these properties and introduce an abstract criterion to\ndetermine conformance to a predicate property at compile time, based on a\nsemantic order relation comparing the predicate property with the predicate\nassertions. We then show how to handle these properties using an abstract\ninterpretation-based static analyzer for programs with first-order assertions\nby reducing predicate properties to first-order properties. Finally, we report\non a prototype implementation and evaluate it through various examples within\nthe Ciao system."}
{"id": "2507.17087", "categories": ["cs.DC", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.17087", "abs": "https://arxiv.org/abs/2507.17087", "authors": ["Anjiang Wei", "Rohan Yadav", "Hang Song", "Wonchan Lee", "Ke Wang", "Alex Aiken"], "title": "Mapple: A Domain-Specific Language for Mapping Distributed Heterogeneous Parallel Programs", "comment": null, "summary": "Optimizing parallel programs for distributed heterogeneous systems remains a\ncomplex task, often requiring significant code modifications. Task-based\nprogramming systems improve modularity by separating performance decisions from\ncore application logic, but their mapping interfaces are often too low-level.\nIn this work, we introduce Mapple, a high-level, declarative programming\ninterface for mapping distributed applications. Mapple provides transformation\nprimitives to resolve dimensionality mismatches between iteration and processor\nspaces, including a key primitive, decompose, that helps minimize communication\nvolume. We implement Mapple on top of the Legion runtime by translating Mapple\nmappers into its low-level C++ interface. Across nine applications, including\nsix matrix multiplication algorithms and three scientific computing workloads,\nMapple reduces mapper code size by 14X and enables performance improvements of\nup to 1.34X over expert-written C++ mappers. In addition, the decompose\nprimitive achieves up to 1.83X improvement over existing\ndimensionality-resolution heuristics. These results demonstrate that Mapple\nsimplifies the development of high-performance mappers for distributed\napplications."}
{"id": "2507.17087", "categories": ["cs.DC", "cs.PL"], "pdf": "https://arxiv.org/pdf/2507.17087", "abs": "https://arxiv.org/abs/2507.17087", "authors": ["Anjiang Wei", "Rohan Yadav", "Hang Song", "Wonchan Lee", "Ke Wang", "Alex Aiken"], "title": "Mapple: A Domain-Specific Language for Mapping Distributed Heterogeneous Parallel Programs", "comment": null, "summary": "Optimizing parallel programs for distributed heterogeneous systems remains a\ncomplex task, often requiring significant code modifications. Task-based\nprogramming systems improve modularity by separating performance decisions from\ncore application logic, but their mapping interfaces are often too low-level.\nIn this work, we introduce Mapple, a high-level, declarative programming\ninterface for mapping distributed applications. Mapple provides transformation\nprimitives to resolve dimensionality mismatches between iteration and processor\nspaces, including a key primitive, decompose, that helps minimize communication\nvolume. We implement Mapple on top of the Legion runtime by translating Mapple\nmappers into its low-level C++ interface. Across nine applications, including\nsix matrix multiplication algorithms and three scientific computing workloads,\nMapple reduces mapper code size by 14X and enables performance improvements of\nup to 1.34X over expert-written C++ mappers. In addition, the decompose\nprimitive achieves up to 1.83X improvement over existing\ndimensionality-resolution heuristics. These results demonstrate that Mapple\nsimplifies the development of high-performance mappers for distributed\napplications."}
{"id": "2507.17094", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.17094", "abs": "https://arxiv.org/abs/2507.17094", "authors": ["Sukjin Kim", "Seongyeon Park", "Si Ung Noh", "Junguk Hong", "Taehee Kwon", "Hunseong Lim", "Jinho Lee"], "title": "PathWeaver: A High-Throughput Multi-GPU System for Graph-Based Approximate Nearest Neighbor Search", "comment": "ATC 2025", "summary": "Graph-based Approximate Nearest Neighbor Search (ANNS) is widely adopted in\nnumerous applications, such as recommendation systems, natural language\nprocessing, and computer vision. While recent works on GPU-based acceleration\nhave significantly advanced ANNS performance, the ever-growing scale of\ndatasets now demands efficient multi-GPU solutions. However, the design of\nexisting works overlooks multi-GPU scalability, resulting in naive approaches\nthat treat additional GPUs as a means to extend memory capacity for large\ndatasets. This inefficiency arises from partitioning the dataset and\nindependently searching for data points similar to the queries in each GPU. We\ntherefore propose PathWeaver, a novel multi-GPU framework designed to scale and\naccelerate ANNS for large datasets. First, we propose pipelining-based path\nextension, a GPU-aware pipelining mechanism that reduces prior work's redundant\nsearch iterations by leveraging GPU-to-GPU communication. Second, we design\nghost staging that leverages a representative dataset to identify optimal query\nstarting points, reducing the search space for challenging queries. Finally, we\nintroduce direction-guided selection, a data selection technique that filters\nirrelevant points early in the search process, minimizing unnecessary memory\naccesses and distance computations. Comprehensive evaluations across diverse\ndatasets demonstrate that PathWeaver achieves 3.24$\\times$ geomean speedup and\nup to 5.30$\\times$ speedup on 95% recall rate over state-of-the-art\nmulti-GPU-based ANNS frameworks."}
{"id": "2507.17120", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.17120", "abs": "https://arxiv.org/abs/2507.17120", "authors": ["Wanyi Zheng", "Minxian Xu", "Shengye Song", "Kejiang Ye"], "title": "BucketServe: Bucket-Based Dynamic Batching for Smart and Efficient LLM Inference Serving", "comment": "9 pages", "summary": "Large language models (LLMs) have become increasingly popular in various\nareas, traditional business gradually shifting from rule-based systems to\nLLM-based solutions. However, the inference of LLMs is resource-intensive or\nlatency-sensitive, posing significant challenges for serving systems. Existing\nLLM serving systems often use static or continuous batching strategies, which\ncan lead to inefficient GPU memory utilization and increased latency,\nespecially under heterogeneous workloads. These methods may also struggle to\nadapt to dynamic workload fluctuations, resulting in suboptimal throughput and\npotential service level objective (SLO) violations. In this paper, we introduce\nBucketServe, a bucket-based dynamic batching framework designed to optimize LLM\ninference performance. By grouping requests into size-homogeneous buckets based\non sequence length, BucketServe minimizes padding overhead and optimizes GPU\nmemory usage through real-time batch size adjustments preventing out-of-memory\n(OOM) errors. It introduces adaptive bucket splitting/merging and\npriority-aware scheduling to mitigate resource fragmentation and ensure SLO\ncompliance. Experiment shows that BucketServe significantly outperforms UELLM\nin throughput, achieving up to 3.58x improvement. It can also handle 1.93x more\nrequest load under the SLO attainment of 80% compared with DistServe and\ndemonstrates 1.975x higher system load capacity compared to the UELLM."}
{"id": "2507.17128", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.17128", "abs": "https://arxiv.org/abs/2507.17128", "authors": ["Minxian Xu", "Linfeng Wen", "Junhan Liao", "Huaming Wu", "Kejiang Ye", "Chengzhong Xu"], "title": "Auto-scaling Approaches for Cloud-native Applications: A Survey and Taxonomy", "comment": "14 pages", "summary": "The interactions within cloud-native applications are complex, with a\nconstantly changing number of services and loads, posing higher demands on\nauto-scaling approach. This mainly involves several challenges such as\nmicroservices dependency analysis, performance profiling, anomaly detection,\nworkload characterization and task co-location. Therefore, some advanced\nalgorithms have been investigated into auto-scaling cloud-native applications\nto optimize system and application performance. These algorithms can learn from\nhistorical data and appropriately adjust resource allocation based on the\ncurrent environment and load conditions to optimize resource utilization and\nsystem performance. In this paper, we systematically review the literature on\nstate-of-the-art auto-scaling approaches for cloud-native applications from\n2020, and further explore the technological evolution. Additionally, we propose\na detailed taxonomy to categorize current research from five perspectives,\nincluding infrastructure, architecture, scaling methods, optimization\nobjectives, and behavior modeling. Then, we provide a comprehensive comparison\nand in-depth discussion of the key features, advantages, limitations, and\napplication scenarios of each approach, considering their performance in\ndiverse environments and under various conditions. Finally, we summarize the\ncurrent state of research in this field, identify the gaps and unresolved\nchallenges, and emphasize promising directions for future exploration,\nparticularly in areas such as the application of large models, microservice\ndependency management, and the use of meta-learning techniques to enhance model\napplicability and adaptability across different environments."}
{"id": "2507.17133", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.17133", "abs": "https://arxiv.org/abs/2507.17133", "authors": ["Jianmin Hu", "Minxian Xu", "Kejiang Ye", "Chengzhong Xu"], "title": "BrownoutServe: SLO-Aware Inference Serving under Bursty Workloads for MoE-based LLMs", "comment": "12 pages", "summary": "In recent years, the Mixture-of-Experts (MoE) architecture has been widely\napplied to large language models (LLMs), providing a promising solution that\nactivates only a subset of the model's parameters during computation, thereby\nreducing overall memory requirements and allowing for faster inference compared\nto dense models. Despite these advantages, existing systems still face issues\nof low efficiency due to static model placement and lack of dynamic workloads\nadaptation. This leads to suboptimal resource utilization and increased\nlatency, especially during bursty requests periods.\n  To address these challenges, this paper introduces BrownoutServe, a novel\nserving framework designed to optimize inference efficiency and maintain\nservice reliability for MoE-based LLMs under dynamic computational demands and\ntraffic conditions. BrownoutServe introduces \"united experts\" that integrate\nknowledge from multiple experts, reducing the times of expert access and\ninference latency. Additionally, it proposes a dynamic brownout mechanism to\nadaptively adjust the processing of certain tokens, optimizing inference\nperformance while guaranteeing service level objectives (SLOs) are met. Our\nevaluations show the effectiveness of BrownoutServe under various workloads: it\nachieves up to 2.07x throughput improvement compared to vLLM and reduces SLO\nviolations by 90.28%, showcasing its robustness under bursty traffic while\nmaintaining acceptable inference accuracy."}
{"id": "2507.17301", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.17301", "abs": "https://arxiv.org/abs/2507.17301", "authors": ["Chi-Wei Chu", "Ding-Yong Hong", "Jan-Jan Wu"], "title": "Efficient Column-Wise N:M Pruning on RISC-V CPU", "comment": null, "summary": "In deep learning frameworks, weight pruning is a widely used technique for\nimproving computational efficiency by reducing the size of large models. This\nis especially critical for convolutional operators, which often act as\nperformance bottlenecks in convolutional neural networks (CNNs). However, the\neffectiveness of pruning heavily depends on how it is implemented, as different\nmethods can significantly impact both computational performance and memory\nfootprint. In this work, we propose a column-wise N:M pruning strategy applied\nat the tile level and modify XNNPACK to enable efficient execution of pruned\nmodels on the RISC-V vector architecture. Additionally, we propose fusing the\noperations of im2col and data packing to minimize redundant memory accesses and\nmemory overhead. To further optimize performance, we incorporate AITemplate's\nprofiling technique to identify the optimal implementation for each\nconvolutional operator. Our proposed approach effectively increases ResNet\ninference throughput by as much as 4.0x, and preserves ImageNet top-1 accuracy\nwithin 2.1\\% of the dense baseline."}
{"id": "2507.17411", "categories": ["cs.DC", "90B35, 90C10, 68Q10, 68W10", "C.1.4"], "pdf": "https://arxiv.org/pdf/2507.17411", "abs": "https://arxiv.org/abs/2507.17411", "authors": ["Pál András Papp", "Toni Böhnlein", "A. N. Yzelman"], "title": "Multiprocessor Scheduling with Memory Constraints: Fundamental Properties and Finding Optimal Solutions", "comment": "Published in the 54th International Conference on Parallel Processing\n  (ICPP 2025)", "summary": "We study the problem of scheduling a general computational DAG on multiple\nprocessors in a 2-level memory hierarchy. This setting is a natural\ngeneralization of several prominent models in the literature, and it\nsimultaneously captures workload balancing, communication, and data movement\ndue to cache size limitations. We first analyze the fundamental properties of\nthis problem from a theoretical perspective, such as its computational\ncomplexity. We also prove that optimizing parallelization and memory management\nseparately, as done in many applications, can result in a solution that is a\nlinear factor away from the optimum.\n  On the algorithmic side, we discuss a natural technique to represent and\nsolve the problem as an Integer Linear Program (ILP). We develop a holistic\nscheduling algorithm based on this approach, and we experimentally study its\nperformance and properties on a small benchmark of computational tasks. Our\nresults confirm that the ILP-based method can indeed find considerably better\nsolutions than a baseline which combines classical scheduling algorithms and\nmemory management policies."}
{"id": "2507.17458", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.17458", "abs": "https://arxiv.org/abs/2507.17458", "authors": ["Marco Pulimeno", "Italo Epicoco", "Massimo Cafaro"], "title": "Distributed P2P quantile tracking with relative value error", "comment": null, "summary": "In this paper we present \\textsc{DUDDSketch}, a distributed version of the\n\\textsc{UDDSketch} algorithm for accurate tracking of quantiles. The algorithm\nis a fully decentralized, gossip-based distributed protocol working in the\ncontext of unstructured P2P networks. We discuss the algorithm's design and\nformally prove its correctness. We also show, through extensive experimental\nresults, that the algorithm converges to the results provided by the sequential\nalgorithm, which is a fundamental and highly desirable property."}
