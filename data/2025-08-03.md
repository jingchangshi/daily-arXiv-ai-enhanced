<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.DC](#cs.DC) [Total: 4]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Abstractions of Sequences, Functions and Operators](https://arxiv.org/abs/2507.23151)
*Louis Rustenholz,Pedro Lopez-Garcia,Manuel V. Hermenegildo*

Main category: cs.PL

TL;DR: 论文提出了一种基于约束的抽象域（B-bound domains），用于抽象数值函数，并引入域抽象技术，支持从符号函数到数值函数的转换。


<details>
  <summary>Details</summary>
Motivation: 解决递归定义的函数闭式边界推断问题，应用于程序分析和混合系统。

Method: 提出B-bound domains抽象域，利用边界函数集合抽象函数，并引入域抽象技术。

Result: 能够推断高度非线性数值不变量，简化传递函数设计。

Conclusion: 新方法在程序分析和混合系统中具有广泛的应用潜力。

Abstract: We present theoretical and practical results on the order theory of lattices
of functions, focusing on Galois connections that abstract (sets of) functions
- a topic known as higher-order abstract interpretation.
  We are motivated by the challenge of inferring closed-form bounds on
functions which are defined recursively, i.e. as the fixed point of an operator
or, equivalently, as the solution to a functional equation. This has multiple
applications in program analysis (e.g. cost analysis, loop acceleration,
declarative language analysis) and in hybrid systems governed by differential
equations.
  Our main contribution is a new family of constraint-based abstract domains
for abstracting numerical functions, B-bound domains, which abstract a function
f by a conjunction of bounds from a preselected set of boundary functions. They
allow inferring highly non-linear numerical invariants, which classical
numerical abstract domains struggle with. We uncover a convexity property in
the constraint space that simplifies, and, in some cases, fully automates,
transfer function design.
  We also introduce domain abstraction, a functor that lifts arbitrary mappings
in value space to Galois connections in function space. This supports
abstraction from symbolic to numerical functions (i.e. size abstraction), and
enables dimensionality reduction of equations.
  We base our constructions of transfer functions on a simple operator
language, starting with sequences, and extending to more general functions,
including multivariate, piecewise, and non-discrete domains.

</details>


### [2] [Kernel-FFI: Transparent Foreign Function Interfaces for Interactive Notebooks](https://arxiv.org/abs/2507.23205)
*Hebi Li,Forrest Sheng Bao,Qi Xiao,Jin Tian*

Main category: cs.PL

TL;DR: Kernel-FFI是一个语言无关的框架，用于在交互式笔记本中实现无缝跨语言函数调用和对象操作，解决了现有FFI解决方案在动态工作流中的不足。


<details>
  <summary>Details</summary>
Motivation: 现有FFI解决方案在动态、交互式笔记本环境中存在配置繁琐、缺乏递归调用和面向对象编程支持等问题。

Method: Kernel-FFI通过源代码级转换自动重写跨语言调用，支持面向对象编程和跨语言资源管理，并引入侧信道通信机制解决阻塞问题。

Result: Kernel-FFI实现了无缝跨语言调用和对象操作，支持递归和异步调用。

Conclusion: Kernel-FFI为多语言开发提供了高效、透明的解决方案，适用于现代笔记本环境。

Abstract: Foreign Function Interfaces (FFIs) are essential for enabling
interoperability between programming languages, yet existing FFI solutions are
ill-suited for the dynamic, interactive workflows prevalent in modern notebook
environments such as Jupyter. Current approaches require extensive manual
configuration, introduce significant boilerplate, and often lack support for
recursive calls and object-oriented programming (OOP) constructs-features
critical for productive, multi-language development.
  We present Kernel-FFI, a transparent, language-agnostic framework that
enables seamless cross-language function calls and object manipulation within
interactive notebooks. Kernel-FFI employs source-level transformation to
automatically rewrite cross-language invocations, eliminating the need for
manual bindings or boilerplate. Kernel-FFI provides robust support for OOP by
enabling foreign object referencing and automatic resource management across
language boundaries. Furthermore, to address the blocking nature of Jupyter
kernels and support recursive and asynchronous foreign calls, we introduce a
novel side-channel communication mechanism. Our tool will be open-sourced and
available at https://codepod.io/docs/kernel-ffi

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [3] [H2SGEMM: Emulating FP32 GEMM on Ascend NPUs using FP16 Units with Precision Recovery and Cache-Aware Optimization](https://arxiv.org/abs/2507.23387)
*Weicheng Xue,Baisong Xu,Kai Yang,Yongxiang Liu,Dengdeng Fan,Pengxiang Xu,Yonghong Tian*

Main category: cs.DC

TL;DR: H2SGEMM是一种高性能算法，利用FP16计算单元模拟FP32矩阵乘法，通过分解和误差补偿策略实现高精度，性能接近理论峰值。


<details>
  <summary>Details</summary>
Motivation: 低精度矩阵引擎（如FP16）缺乏对全精度计算的支持，限制了其应用范围。

Method: 将FP32操作数分解为两个FP16值，并通过可调缩放策略补偿数值误差，采用缓存感知分块和双缓冲流水线优化性能。

Result: H2SGEMM在Ascend 910A NPU上达到理论FP32峰值性能的77%，并恢复FP32精度，数值稳定性优于传统方法。

Conclusion: H2SGEMM成功利用FP16单元实现高精度FP32矩阵乘法，性能优越且数值稳定。

Abstract: Low-precision matrix engines, such as FP16 cube, offer high throughput but
lack support for full-precision computation. In this work, we propose H2SGEMM,
a high-performance algorithm for emulating FP32 general matrix-matrix
multiplication (GEMM) using only FP16 computation units on a representative AI
accelerator. The method decomposes each FP32 operand into two FP16 values and
compensates for numerical errors through a tunable scaling strategy. A detailed
analysis of numerical errors, including underflow conditions and precision
loss, guides the selection of scaling parameters to preserve up to 22 bits of
mantissa accuracy. We further investigate the effect of computation order on
accuracy and demonstrate that a term-wise accumulation scheme improves
numerical stability over conventional FP32 GEMM in low-exponent regimes.
Finally, a cache-aware blocking strategy and double-buffered pipeline are
introduced to overlap memory transfers with computation, enabling H2SGEMM to
achieve up to 77% of the theoretical FP32-equivalent peak performance on Ascend
910A NPU lacking native FP32 support. Extensive numerical experiments confirm
that our method not only recovers the accuracy of native FP32 GEMM but also
exhibits superior numerical stability under certain conditions, due to its
structured and error-aware computation order.

</details>


### [4] [Towards a Testbed for Scalable FaaS Platforms](https://arxiv.org/abs/2507.23431)
*Trever Schirmer,David Bermbach*

Main category: cs.DC

TL;DR: 介绍了一个研究型测试平台，用于评估不同架构和技术对FaaS平台性能的影响。


<details>
  <summary>Details</summary>
Motivation: 为了更好地理解云平台架构如何影响其性能，尤其是针对FaaS平台的扩展性。

Method: 开发了一个可快速适应的研究型测试平台，用于评估不同架构和技术对FaaS平台性能的影响。

Result: 该测试平台能够有效评估不同架构和技术对FaaS平台扩展性的影响。

Conclusion: 研究型测试平台为理解和优化FaaS平台的性能提供了实用工具。

Abstract: Most cloud platforms have a Function-as-a-Service (FaaS) offering that
enables users to easily write highly scalable applications. To better
understand how the platform's architecture impacts its performance, we present
a research-focused testbed that can be adapted to quickly evaluate the impact
of different architectures and technologies on the characteristics of
scalability-focused FaaS platforms.

</details>


### [5] [Threshold-Driven Streaming Graph: Expansion and Rumor Spreading](https://arxiv.org/abs/2507.23533)
*Flora Angileri,Andrea Clementi,Emanuele Natale,Michele Salvi,Isabella Ziccardi*

Main category: cs.DC

TL;DR: 研究了RAES算法在动态图模型（滑动窗口模型）下的行为，证明了动态图中每个快照具有良好扩展性，并利用此特性为PUSH和PULL谣言传播协议建立了对数时间上限。


<details>
  <summary>Details</summary>
Motivation: 探索RAES算法在动态图模型中的表现，解决静态图假设的限制，并分析其在节点更替频繁的P2P网络中的应用。

Method: 在滑动窗口模型下，模拟节点动态更替，分析RAES算法在动态图中的扩展性，并评估PUSH和PULL协议的完成时间。

Result: 动态图中每个快照具有高概率的良好扩展性，且PUSH和PULL协议的完成时间上限为对数级别。

Conclusion: RAES算法在动态图模型中仍能保持扩展性，适用于P2P网络，为谣言传播协议提供了高效的时间保证。

Abstract: A randomized distributed algorithm called RAES was introduced in [Becchetti
et al., SODA 2020] to extract a bounded-degree expander from a dense $n$-vertex
expander graph $G = (V, E)$. The algorithm relies on a simple threshold-based
procedure. A key assumption in [Becchetti et al., SODA 2020] is that the input
graph $G$ is static - i.e., both its vertex set $V$ and edge set $E$ remain
unchanged throughout the process - while the analysis of RAES in dynamic models
is left as a major open question.
  In this work, we investigate the behavior of RAES under a dynamic graph model
induced by a streaming node-churn process (also known as the sliding window
model), where, at each discrete round, a new node joins the graph and the
oldest node departs. This process yields a bounded-degree dynamic graph
$\mathcal{G} =\{ G_t = (V_t, E_t) : t \in \mathbb{N}\}$ that captures essential
characteristics of peer-to-peer networks -- specifically, node churn and
threshold on the number of connections each node can manage. We prove that
every snapshot $G_t$ in the dynamic graph sequence has good expansion
properties with high probability. Furthermore, we leverage this property to
establish a logarithmic upper bound on the completion time of the well-known
PUSH and PULL rumor spreading protocols over the dynamic graph $\mathcal{G}$.

</details>


### [6] [The ArborX library: version 2.0](https://arxiv.org/abs/2507.23700)
*Andrey Prokopenko,Daniel Arndt,Damien Lebrun-Grandié,Bruno Turcksin*

Main category: cs.DC

TL;DR: ArborX 2.0是一个基于Kokkos的性能可移植几何搜索库，本次更新包括新接口、新搜索数据结构（如暴力搜索和分布式搜索）、回调功能支持以及扩展算法（如光线追踪和聚类）。


<details>
  <summary>Details</summary>
Motivation: 为了支持更广泛的用户问题和提升库的灵活性，ArborX 2.0进行了多项改进。

Method: 引入了新接口、新的搜索数据结构（如暴力搜索和分布式搜索）、支持用户回调功能，并扩展了算法集（如光线追踪和聚类）。

Result: ArborX 2.0提供了更强大的功能和更高的灵活性，适用于更多类型的几何搜索问题。

Conclusion: ArborX 2.0通过多项改进提升了性能和适用性，为几何搜索问题提供了更全面的解决方案。

Abstract: This paper provides an overview of the 2.0 release of the ArborX library, a
performance portable geometric search library based on Kokkos. We describe the
major changes in ArborX 2.0 including a new interface for the library to
support a wider range of user problems, new search data structures (brute
force, distributed), support for user functions to be executed on the results
(callbacks), and an expanded set of the supported algorithms (ray tracing,
clustering).

</details>
