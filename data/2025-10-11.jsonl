{"id": "2510.07449", "categories": ["cs.AR", "C.1.0"], "pdf": "https://arxiv.org/pdf/2510.07449", "abs": "https://arxiv.org/abs/2510.07449", "authors": ["Georgia Antoniou", "Haris Volos", "Jawad Haj Yahya", "Yiannakis Sazeides"], "title": "How long can you sleep? Idle Time System Inefficiencies and Opportunities", "comment": "3 pages, 3 figures, accepted at the 1st International Workshop on\n  Data Center Energy Efficiency (DCEE2025) 2025", "summary": "This work introduces a model-based framework that reveals the idle\nopportunity of modern servers running latency-critical applications.\nSpecifically, three queuing models, M/M/1, cxM/M/1, and M/M/c, are used to\nestimate the theoretical idle time distribution at the CPU core and system\n(package) level. A comparison of the actual idleness of a real server and that\nfrom the theoretical models reveals significant missed opportunities to enter\ndeep idle states. This inefficiency is attributed to the idle-governor\ninaccuracy and the high latency to transition to/from legacy deep-idle states.\nThe proposed methodology offers the means for an early-stage design exploration\nand insights into idle time behavior and opportunities for varying server\nsystem configurations and load."}
{"id": "2510.07719", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.07719", "abs": "https://arxiv.org/abs/2510.07719", "authors": ["Parker Hao Tian", "Zahra Yousefijamarani", "Alaa Alameldeen"], "title": "DL-PIM: Improving Data Locality in Processing-in-Memory Systems", "comment": null, "summary": "PIM architectures aim to reduce data transfer costs between processors and\nmemory by integrating processing units within memory layers. Prior PIM\narchitectures have shown potential to improve energy efficiency and\nperformance. However, such advantages rely on data proximity to the processing\nunits performing computations. Data movement overheads can degrade PIM's\nperformance and energy efficiency due to the need to move data between a\nprocessing unit and a distant memory location. %they face challenges due to the\noverhead of transferring data from remote memory locations to processing units\ninside memory for computation. In this paper, we demonstrate that a large\nfraction of PIM's latency per memory request is attributed to data transfers\nand queuing delays from remote memory accesses. To improve PIM's data locality,\nwe propose DL-PIM, a novel architecture that dynamically detects the overhead\nof data movement, and proactively moves data to a reserved area in the local\nmemory of the requesting processing unit. DL-PIM uses a distributed\naddress-indirection hardware lookup table to redirect traffic to the current\ndata location. We propose DL-PIM implementations on two 3D stacked memories:\nHMC and HBM. While some workloads benefit from DL-PIM, others are negatively\nimpacted by the additional latency due to indirection accesses. Therefore, we\npropose an adaptive mechanism that assesses the cost and benefit of indirection\nand dynamically enables or disables it to prevent degrading workloads that\nsuffer from indirection. Overall, DL-PIM reduces the average memory latency per\nrequest by 54% in HMC and 50% in HBM which resulted in performance improvement\nof 15% for workloads with substantial data reuse in HMC and 5% in HBM. For all\nrepresentative workloads, DL-PIM achieved a 6% speedup in HMC and a 3% speedup\nin HBM, showing that DL-PIM enhances data locality and overall system\nperformance."}
{"id": "2510.08137", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.08137", "abs": "https://arxiv.org/abs/2510.08137", "authors": ["Anastasios Petropoulos", "Theodore Antonakopoulos"], "title": "A Scalable FPGA Architecture With Adaptive Memory Utilization for GEMM-Based Operations", "comment": null, "summary": "Deep neural network (DNN) inference relies increasingly on specialized\nhardware for high computational efficiency. This work introduces a\nfield-programmable gate array (FPGA)-based dynamically configurable accelerator\nfeaturing systolic arrays, high-bandwidth memory, and UltraRAMs. We present two\nprocessing unit (PU) configurations with different computing capabilities using\nthe same interfaces and peripheral blocks. By instantiating multiple PUs and\nemploying a heuristic weight transfer schedule, the architecture achieves\nnotable throughput efficiency over prior works. Moreover, we outline how the\narchitecture can be extended to emulate analog in-memory computing (AIMC)\ndevices to aid next-generation heterogeneous AIMC chip designs and investigate\ndevice-level noise behavior. Overall, this brief presents a versatile DNN\ninference acceleration architecture adaptable to various models and future FPGA\ndesigns."}
{"id": "2510.08351", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.08351", "abs": "https://arxiv.org/abs/2510.08351", "authors": ["Qingxiu Liu", "Jiazhen Cai", "Siyuan Sheng", "Yuhui Chen", "Lu Tang", "Zhirong Shen", "Patrick P. C. Lee"], "title": "FMCache: File-System Metadata Caching in Programmable Switches", "comment": "14 pages", "summary": "Fast and scalable metadata management across multiple metadata servers is\ncrucial for distributed file systems to handle numerous files and directories.\nClient-side caching of frequently accessed metadata can mitigate server loads,\nbut incurs significant overhead and complexity in maintaining cache consistency\nwhen the number of clients increases. We propose FMCache, an in-switch\nfile-system metadata caching framework that leverages programmable switches to\nserve file-system metadata requests from multiple clients directly in the\nswitch data plane. Unlike prior in-switch key-value caching approaches, FMCache\naddresses file-system-specific path dependencies under stringent switch\nresource constraints. We implement FMCache atop Hadoop HDFS and evaluate it on\na Tofino-switch testbed using real-world file-system metadata workloads.\nFMCache achieves up to 181.6% higher throughput than vanilla HDFS and\ncomplements client-side caching with additional throughput gains of up to\n139.6%. It also incurs low latencies and limited switch resource usage."}
{"id": "2510.07582", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.07582", "abs": "https://arxiv.org/abs/2510.07582", "authors": ["Yuyan Bao", "Tiark Rompf"], "title": "Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness", "comment": null, "summary": "Programming benefits from a clear separation between pure, mathematical\ncomputation and impure, effectful interaction with the world. Existing\napproaches to enforce this separation include monads, type-and-effect systems,\nand capability systems. All share a tension between precision and usability,\nand each one has non-obvious strengths and weaknesses.\n  This paper aims to raise the bar in assessing such systems. First, we propose\na semantic definition of purity, inspired by contextual equivalence, as a\nbaseline independent of any specific typing discipline. Second, we propose that\nexpressiveness should be measured by the degree of completeness, i.e., how many\nsemantically pure terms can be typed as pure. Using this measure, we focus on\nminimal meaningful effect and capability systems and show that they are\nincomparable, i.e., neither subsumes the other in terms of expressiveness.\n  Based on this result, we propose a synthesis and show that type, ability, and\neffect systems combine their respective strengths while avoiding their\nweaknesses. As part of our formal model, we provide a logical relation to\nfacilitate proofs of purity and other properties for a variety of effect typing\ndisciplines."}
{"id": "2510.07811", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.07811", "abs": "https://arxiv.org/abs/2510.07811", "authors": ["Aryan Poduri"], "title": "Adaptive Execution Scheduler for DataDios SmartDiff", "comment": "4 pages, 1 figure", "summary": "We present an adaptive scheduler for a single differencing engine (SmartDiff)\nwith two execution modes: (i) in-memory threads and (ii) Dask based\nparallelism. The scheduler continuously tunes batch size and worker/thread\ncount within fixed CPU and memory budgets to minimize p95 latency. A\nlightweight preflight profiler estimates bytes/row and I/O rate; an online\ncost/memory model prunes unsafe actions; and a guarded hill-climb policy favors\nlower latency with backpressure and straggler mitigation. Backend selection is\ngated by a conservative working-set estimate so that in-memory execution is\nchosen when safe, otherwise Dask is used. Across synthetic and public tabular\nbenchmarks, the scheduler reduces p95 latency by 23 to 28 percent versus a\ntuned warm-up heuristic (and by 35 to 40 percent versus fixed grid baselines),\nwhile lowering peak memory by 16 to 22 percent (25 to 32 percent vs. fixed)\nwith zero OOMs and comparable throughput."}
{"id": "2510.08544", "categories": ["cs.AR", "cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.08544", "abs": "https://arxiv.org/abs/2510.08544", "authors": ["Hengrui Zhang", "Pratyush Patel", "August Ning", "David Wentzlaff"], "title": "SPAD: Specialized Prefill and Decode Hardware for Disaggregated LLM Inference", "comment": null, "summary": "Large Language Models (LLMs) have gained popularity in recent years, driving\nup the demand for inference. LLM inference is composed of two phases with\ndistinct characteristics: a compute-bound prefill phase followed by a\nmemory-bound decode phase. To efficiently serve LLMs, prior work proposes\nprefill-decode disaggregation to run each phase on separate hardware. However,\nexisting hardware poorly matches the different requirements of each phase.\nCurrent datacenter GPUs and TPUs follow a more-is-better design philosophy that\nmaximizes compute and memory resources, causing memory bandwidth\nunderutilization in the prefill phase and compute underutilization in the\ndecode phase. Such underutilization directly translates into increased serving\ncosts.\n  This paper proposes SPAD (Specialized Prefill and Decode hardware), adopting\na less-is-more methodology to design specialized chips tailored to the distinct\ncharacteristics of prefill and decode phases. The proposed Prefill Chips have\nlarger systolic arrays and use cost-effective GDDR memory, whereas the proposed\nDecode Chips retain high memory bandwidth but reduce compute capacity. Compared\nto modeled H100s, simulations show that the proposed Prefill Chips deliver 8%\nhigher prefill performance on average at 52% lower hardware cost, while the\nproposed Decode Chips achieve 97% of the decode performance with 28% lower TDP.\n  End-to-end simulations on production traces show that SPAD reduces hardware\ncost by 19%-41% and TDP by 2%-17% compared to modeled baseline clusters while\noffering the same performance. Even when models and workloads change, SPAD can\nreallocate either type of chip to run either phase and still achieve 11%-43%\nlower hardware costs, demonstrating the longevity of the SPAD design."}
{"id": "2510.07851", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2510.07851", "abs": "https://arxiv.org/abs/2510.07851", "authors": ["Willem Heijltjes"], "title": "The Functional Machine Calculus III: Control", "comment": null, "summary": "The Functional Machine Calculus (Heijltjes 2022) is a new approach to\nunifying the imperative and functional programming paradigms. It extends the\nlambda-calculus, preserving the key features of confluent reduction and typed\ntermination, to embed computational effects, evaluation strategies, and control\nflow operations. The first instalment modelled sequential higher-order\ncomputation with global store, input/output, probabilities, and\nnon-determinism, and embedded both the call-by-name and call-by-value\nlambda-calculus, as well as Moggi's computational metalanguage and Levy's\ncall-by-push-value. The present paper extends the calculus from sequential to\nbranching and looping control flow. This allows the faithful embedding of a\nminimal but complete imperative language, including conditionals, exception\nhandling, and iteration, as well as constants and algebraic data types.\n  The calculus is defined through a simple operational semantics, extending the\n(simplified) Krivine machine for the lambda-calculus with multiple operand\nstacks to model effects and a continuation stack to model sequential,\nbranching, and looping computation. It features a confluent reduction relation\nand a system of simple types that guarantees termination of the machine and\nstrong normalization of reduction (in the absence of iteration). These\nproperties carry over to the embedded imperative language, providing a unified\nfunctional-imperative model of computation that supports simple types, a direct\nand intuitive operational semantics, and a confluent reduction semantics."}
{"id": "2510.08164", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.08164", "abs": "https://arxiv.org/abs/2510.08164", "authors": ["Marco Picone", "Samuele Burattini", "Marco Melloni", "Prasad Talasila", "Davide Ziglioli", "Matteo Martinelli", "Nicola Bicocchi", "Alessandro Ricci", "Peter Gorm Larsen"], "title": "A Multi-Simulation Bridge for IoT Digital Twins", "comment": null, "summary": "The increasing capabilities of Digital Twins (DTs) in the context of the\nInternet of Things (IoT) and Industrial IoT (IIoT) call for seamless\nintegration with simulation platforms to support system design, validation, and\nreal-time operation. This paper introduces the concept, design, and\nexperimental evaluation of the DT Simulation Bridge - a software framework that\nenables diverse interaction patterns between active DTs and simulation\nenvironments. The framework supports both the DT development lifecycle and the\nincorporation of simulations during active operation. Through bidirectional\ndata exchange, simulations can update DT models dynamically, while DTs provide\nreal-time feedback to adapt simulation parameters. We describe the\narchitectural design and core software components that ensure flexible\ninteroperability and scalable deployment. Experimental results show that the DT\nSimulation Bridge enhances design agility, facilitates virtual commissioning,\nand supports live behavioral analysis under realistic conditions, demonstrating\nits effectiveness across a range of industrial scenarios."}
{"id": "2510.08180", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.08180", "abs": "https://arxiv.org/abs/2510.08180", "authors": ["Natalie Carl", "Tobias Pfandzelter", "David Bermbach"], "title": "Towards Energy-Efficient Serverless Computing with Hardware Isolation", "comment": null, "summary": "Serverless computing provides just-in-time infrastructure provisioning with\nrapid elasticity and a finely-grained pricing model. As full control of\nresource allocation is in the hands of the cloud provider and applications only\nconsume resources when they actually perform work, we believe that serverless\ncomputing is uniquely positioned to maximize energy efficiency.\n  However, the focus of current serverless platforms is to run hundreds or\nthousands of serverless functions from different tenants on traditional server\nhardware, requiring expensive software isolation mechanisms and a high degree\nof overprovisioning, i.e., idle servers, to anticipate load spikes. With shared\ncaches, high clock frequencies, and many-core architectures, servers today are\noptimized for large, singular workloads but not to run thousands of isolated\nfunctions.\n  We propose rethinking the serverless hardware architecture to align it with\nthe requirements of serverless software. Specifically, we propose using\nhardware isolation with individual processors per function instead of software\nisolation resulting in a serverless hardware stack that consumes energy only\nwhen an application actually performs work. In preliminary evaluation with real\nhardware and a typical serverless workload we find that this could reduce\nenergy consumption overheads by 90.63% or an average 70.8MW."}
{"id": "2510.08228", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.08228", "abs": "https://arxiv.org/abs/2510.08228", "authors": ["Quentin Renau", "Amjad Ullah", "Emma Hart"], "title": "Distributed Resource Selection for Self-Organising Cloud-Edge Systems", "comment": "This paper is accepted for publication in the 23rd IEEE International\n  Symposium on Network Computing and Applications", "summary": "This paper presents a distributed resource selection mechanism for diverse\ncloud-edge environments, enabling dynamic and context-aware allocation of\nresources to meet the demands of complex distributed applications. By\ndistributing the decision-making process, our approach ensures efficiency,\nscalability, and resilience in highly dynamic cloud-edge environments where\ncentralised coordination becomes a bottleneck. The proposed mechanism aims to\nfunction as a core component of a broader, distributed, and self-organising\norchestration system that facilitates the intelligent placement and adaptation\nof applications in real-time. This work leverages a consensus-based mechanism\nutilising local knowledge and inter-agent collaboration to achieve efficient\nresults without relying on a central controller, thus paving the way for\ndistributed orchestration. Our results indicate that computation time is the\nkey factor influencing allocation decisions. Our approach consistently delivers\nrapid allocations without compromising optimality or incurring additional cost,\nachieving timely results at scale where exhaustive search is infeasible and\ncentralised heuristics run up to 30 times slower."}
{"id": "2510.08244", "categories": ["cs.DC", "cs.DS"], "pdf": "https://arxiv.org/pdf/2510.08244", "abs": "https://arxiv.org/abs/2510.08244", "authors": ["Dominick Banasik", "Varsha Dani", "Fabien Dufoulon", "Aayush Gupta", "Thomas P. Hayes", "Gopal Pandurangan"], "title": "Energy-Efficient Maximal Independent Sets in Radio Networks", "comment": null, "summary": "The maximal independent set (MIS) is one of the most fundamental problems in\ndistributed computing, and it has been studied intensively for over four\ndecades. This paper focuses on the MIS problem in the Radio Network model, a\nstandard model widely used to model wireless networks, particularly ad hoc\nwireless and sensor networks. Energy is a premium resource in these networks,\nwhich are typically battery-powered. Hence, designing distributed algorithms\nthat use as little energy as possible is crucial. We use the well-established\nenergy model where a node can be sleeping or awake in a round, and only the\nawake rounds (when it can send or listen) determine the energy complexity of\nthe algorithm, which we want to minimize.\n  We present new, more energy-efficient MIS algorithms in radio networks with\narbitrary and unknown graph topology. We present algorithms for two popular\nvariants of the radio model -- with collision detection (CD) and without\ncollision detection (no-CD). Specifically, we obtain the following results:\n  1. CD model: We present a randomized distributed MIS algorithm with energy\ncomplexity $O(\\log n)$, round complexity $O(\\log^2 n)$, and failure probability\n$1 / poly(n)$, where $n$ is the network size. We show that our energy\ncomplexity is optimal by showing a matching $\\Omega(\\log n)$ lower bound.\n  2. no-CD model: In the more challenging no-CD model, we present a randomized\ndistributed MIS algorithm with energy complexity $O(\\log^2n \\log \\log n)$,\nround complexity $O(\\log^3 n \\log \\Delta)$, and failure probability $1 /\npoly(n)$. The energy complexity of our algorithm is significantly lower than\nthe round (and energy) complexity of $O(\\log^3 n)$ of the best known\ndistributed MIS algorithm of Davies [PODC 2023] for arbitrary graph topology."}
{"id": "2510.08536", "categories": ["cs.DC", "cs.SE"], "pdf": "https://arxiv.org/pdf/2510.08536", "abs": "https://arxiv.org/abs/2510.08536", "authors": ["Gregor Olenik", "Marcel Koch", "Hartwig Anzt"], "title": "Investigating Matrix Repartitioning to Address the Over- and Undersubscription Challenge for a GPU-based CFD Solver", "comment": "2025 Workshop: HPC on Heterogeneous Hardware (H3)", "summary": "Modern high-performance computing (HPC) increasingly relies on GPUs, but\nintegrating GPU acceleration into complex scientific frameworks like OpenFOAM\nremains a challenge. Existing approaches either fully refactor the codebase or\nuse plugin-based GPU solvers, each facing trade-offs between performance and\ndevelopment effort. In this work, we address the limitations of plugin-based\nGPU acceleration in OpenFOAM by proposing a repartitioning strategy that better\nbalances CPU matrix assembly and GPU-based linear solves. We present a detailed\ncomputational model, describe a novel matrix repartitioning and update\nprocedure, and evaluate its performance on large-scale CFD simulations. Our\nresults show that the proposed method significantly mitigates oversubscription\nissues, improving solver performance and resource utilization in heterogeneous\nCPU-GPU environments."}
{"id": "2510.08544", "categories": ["cs.AR", "cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2510.08544", "abs": "https://arxiv.org/abs/2510.08544", "authors": ["Hengrui Zhang", "Pratyush Patel", "August Ning", "David Wentzlaff"], "title": "SPAD: Specialized Prefill and Decode Hardware for Disaggregated LLM Inference", "comment": null, "summary": "Large Language Models (LLMs) have gained popularity in recent years, driving\nup the demand for inference. LLM inference is composed of two phases with\ndistinct characteristics: a compute-bound prefill phase followed by a\nmemory-bound decode phase. To efficiently serve LLMs, prior work proposes\nprefill-decode disaggregation to run each phase on separate hardware. However,\nexisting hardware poorly matches the different requirements of each phase.\nCurrent datacenter GPUs and TPUs follow a more-is-better design philosophy that\nmaximizes compute and memory resources, causing memory bandwidth\nunderutilization in the prefill phase and compute underutilization in the\ndecode phase. Such underutilization directly translates into increased serving\ncosts.\n  This paper proposes SPAD (Specialized Prefill and Decode hardware), adopting\na less-is-more methodology to design specialized chips tailored to the distinct\ncharacteristics of prefill and decode phases. The proposed Prefill Chips have\nlarger systolic arrays and use cost-effective GDDR memory, whereas the proposed\nDecode Chips retain high memory bandwidth but reduce compute capacity. Compared\nto modeled H100s, simulations show that the proposed Prefill Chips deliver 8%\nhigher prefill performance on average at 52% lower hardware cost, while the\nproposed Decode Chips achieve 97% of the decode performance with 28% lower TDP.\n  End-to-end simulations on production traces show that SPAD reduces hardware\ncost by 19%-41% and TDP by 2%-17% compared to modeled baseline clusters while\noffering the same performance. Even when models and workloads change, SPAD can\nreallocate either type of chip to run either phase and still achieve 11%-43%\nlower hardware costs, demonstrating the longevity of the SPAD design."}
