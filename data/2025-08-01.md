<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 2]
- [cs.DC](#cs.DC) [Total: 4]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Abstractions of Sequences, Functions and Operators](https://arxiv.org/abs/2507.23151)
*Louis Rustenholz,Pedro Lopez-Garcia,Manuel V. Hermenegildo*

Main category: cs.PL

TL;DR: 论文提出了一种基于约束的抽象域（B-bound domains），用于抽象数值函数，并引入域抽象方法，支持从符号函数到数值函数的转换。


<details>
  <summary>Details</summary>
Motivation: 研究动机是解决递归定义的函数的闭式边界推断问题，应用于程序分析和混合系统。

Method: 方法包括构建B-bound domains和域抽象，利用凸性简化传递函数设计。

Result: 结果表明，该方法能推断高度非线性数值不变量，优于传统数值抽象域。

Conclusion: 结论是该方法在抽象解释和函数空间分析中具有广泛适用性。

Abstract: We present theoretical and practical results on the order theory of lattices
of functions, focusing on Galois connections that abstract (sets of) functions
- a topic known as higher-order abstract interpretation.
  We are motivated by the challenge of inferring closed-form bounds on
functions which are defined recursively, i.e. as the fixed point of an operator
or, equivalently, as the solution to a functional equation. This has multiple
applications in program analysis (e.g. cost analysis, loop acceleration,
declarative language analysis) and in hybrid systems governed by differential
equations.
  Our main contribution is a new family of constraint-based abstract domains
for abstracting numerical functions, B-bound domains, which abstract a function
f by a conjunction of bounds from a preselected set of boundary functions. They
allow inferring highly non-linear numerical invariants, which classical
numerical abstract domains struggle with. We uncover a convexity property in
the constraint space that simplifies, and, in some cases, fully automates,
transfer function design.
  We also introduce domain abstraction, a functor that lifts arbitrary mappings
in value space to Galois connections in function space. This supports
abstraction from symbolic to numerical functions (i.e. size abstraction), and
enables dimensionality reduction of equations.
  We base our constructions of transfer functions on a simple operator
language, starting with sequences, and extending to more general functions,
including multivariate, piecewise, and non-discrete domains.

</details>


### [2] [Kernel-FFI: Transparent Foreign Function Interfaces for Interactive Notebooks](https://arxiv.org/abs/2507.23205)
*Hebi Li,Forrest Sheng Bao,Qi Xiao,Jin Tian*

Main category: cs.PL

TL;DR: Kernel-FFI是一个透明的、语言无关的框架，用于在交互式笔记本中实现无缝的跨语言函数调用和对象操作，解决了现有FFI解决方案在动态交互环境中的不足。


<details>
  <summary>Details</summary>
Motivation: 现有FFI解决方案在动态交互式笔记本环境中表现不佳，需要大量手动配置和样板代码，且缺乏对递归调用和面向对象编程的支持。

Method: Kernel-FFI通过源代码级转换自动重写跨语言调用，无需手动绑定或样板代码，并支持面向对象编程和跨语言资源管理。此外，通过引入侧信道通信机制解决Jupyter内核的阻塞问题。

Result: Kernel-FFI实现了无缝的跨语言函数调用和对象操作，支持递归和异步调用，解决了现有FFI的局限性。

Conclusion: Kernel-FFI为动态交互环境提供了一种高效的跨语言互操作解决方案，显著提升了多语言开发的效率。

Abstract: Foreign Function Interfaces (FFIs) are essential for enabling
interoperability between programming languages, yet existing FFI solutions are
ill-suited for the dynamic, interactive workflows prevalent in modern notebook
environments such as Jupyter. Current approaches require extensive manual
configuration, introduce significant boilerplate, and often lack support for
recursive calls and object-oriented programming (OOP) constructs-features
critical for productive, multi-language development.
  We present Kernel-FFI, a transparent, language-agnostic framework that
enables seamless cross-language function calls and object manipulation within
interactive notebooks. Kernel-FFI employs source-level transformation to
automatically rewrite cross-language invocations, eliminating the need for
manual bindings or boilerplate. Kernel-FFI provides robust support for OOP by
enabling foreign object referencing and automatic resource management across
language boundaries. Furthermore, to address the blocking nature of Jupyter
kernels and support recursive and asynchronous foreign calls, we introduce a
novel side-channel communication mechanism. Our tool will be open-sourced and
available at https://codepod.io/docs/kernel-ffi

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [3] [H2SGEMM: Emulating FP32 GEMM on Ascend NPUs using FP16 Units with Precision Recovery and Cache-Aware Optimization](https://arxiv.org/abs/2507.23387)
*Weicheng Xue,Baisong Xu,Kai Yang,Yongxiang Liu,Dengdeng Fan,Pengxiang Xu,Yonghong Tian*

Main category: cs.DC

TL;DR: H2SGEMM是一种高性能算法，利用FP16计算单元模拟FP32矩阵乘法，通过数值误差补偿和优化计算顺序实现高精度和高性能。


<details>
  <summary>Details</summary>
Motivation: 低精度矩阵引擎（如FP16）缺乏对全精度计算的支持，限制了其在高精度应用中的使用。

Method: 将FP32操作数分解为两个FP16值，通过可调缩放策略补偿数值误差，并优化计算顺序和缓存策略。

Result: 在Ascend 910A NPU上达到理论FP32峰值性能的77%，数值实验显示其精度和稳定性优于传统FP32 GEMM。

Conclusion: H2SGEMM不仅恢复了FP32 GEMM的精度，还在某些条件下表现出更高的数值稳定性。

Abstract: Low-precision matrix engines, such as FP16 cube, offer high throughput but
lack support for full-precision computation. In this work, we propose H2SGEMM,
a high-performance algorithm for emulating FP32 general matrix-matrix
multiplication (GEMM) using only FP16 computation units on a representative AI
accelerator. The method decomposes each FP32 operand into two FP16 values and
compensates for numerical errors through a tunable scaling strategy. A detailed
analysis of numerical errors, including underflow conditions and precision
loss, guides the selection of scaling parameters to preserve up to 22 bits of
mantissa accuracy. We further investigate the effect of computation order on
accuracy and demonstrate that a term-wise accumulation scheme improves
numerical stability over conventional FP32 GEMM in low-exponent regimes.
Finally, a cache-aware blocking strategy and double-buffered pipeline are
introduced to overlap memory transfers with computation, enabling H2SGEMM to
achieve up to 77% of the theoretical FP32-equivalent peak performance on Ascend
910A NPU lacking native FP32 support. Extensive numerical experiments confirm
that our method not only recovers the accuracy of native FP32 GEMM but also
exhibits superior numerical stability under certain conditions, due to its
structured and error-aware computation order.

</details>


### [4] [Towards a Testbed for Scalable FaaS Platforms](https://arxiv.org/abs/2507.23431)
*Trever Schirmer,David Bermbach*

Main category: cs.DC

TL;DR: 研究提出了一个测试平台，用于评估不同架构和技术对FaaS平台性能的影响。


<details>
  <summary>Details</summary>
Motivation: 理解云平台架构如何影响其性能，尤其是针对可扩展性强的FaaS平台。

Method: 开发一个研究型测试平台，可快速评估不同架构和技术对FaaS平台特性的影响。

Result: 测试平台能够灵活适应不同架构和技术的评估需求。

Conclusion: 该测试平台为研究FaaS平台的性能提供了有效工具。

Abstract: Most cloud platforms have a Function-as-a-Service (FaaS) offering that
enables users to easily write highly scalable applications. To better
understand how the platform's architecture impacts its performance, we present
a research-focused testbed that can be adapted to quickly evaluate the impact
of different architectures and technologies on the characteristics of
scalability-focused FaaS platforms.

</details>


### [5] [Threshold-Driven Streaming Graph: Expansion and Rumor Spreading](https://arxiv.org/abs/2507.23533)
*Flora Angileri,Andrea Clementi,Emanuele Natale,Michele Salvi,Isabella Ziccardi*

Main category: cs.DC

TL;DR: 研究了RAES算法在动态图模型中的表现，证明了其在节点轮换的动态图中仍能保持扩展性，并给出了PUSH/PULL谣言传播协议的时间上限。


<details>
  <summary>Details</summary>
Motivation: RAES算法在静态图中表现良好，但其在动态图模型中的行为尚不明确，尤其是在节点轮换的动态环境中。

Method: 通过流式节点轮换模型（滑动窗口模型）模拟动态图，分析RAES算法在每轮节点变化时的扩展性。

Result: 证明动态图中的每个快照都具有高概率的良好扩展性，并得出PUSH/PULL协议的完成时间为对数级别。

Conclusion: RAES算法在动态图中仍能保持扩展性，适用于节点轮换的网络环境，如P2P网络。

Abstract: A randomized distributed algorithm called RAES was introduced in [Becchetti
et al., SODA 2020] to extract a bounded-degree expander from a dense $n$-vertex
expander graph $G = (V, E)$. The algorithm relies on a simple threshold-based
procedure. A key assumption in [Becchetti et al., SODA 2020] is that the input
graph $G$ is static - i.e., both its vertex set $V$ and edge set $E$ remain
unchanged throughout the process - while the analysis of RAES in dynamic models
is left as a major open question.
  In this work, we investigate the behavior of RAES under a dynamic graph model
induced by a streaming node-churn process (also known as the sliding window
model), where, at each discrete round, a new node joins the graph and the
oldest node departs. This process yields a bounded-degree dynamic graph
$\mathcal{G} =\{ G_t = (V_t, E_t) : t \in \mathbb{N}\}$ that captures essential
characteristics of peer-to-peer networks -- specifically, node churn and
threshold on the number of connections each node can manage. We prove that
every snapshot $G_t$ in the dynamic graph sequence has good expansion
properties with high probability. Furthermore, we leverage this property to
establish a logarithmic upper bound on the completion time of the well-known
PUSH and PULL rumor spreading protocols over the dynamic graph $\mathcal{G}$.

</details>


### [6] [The ArborX library: version 2.0](https://arxiv.org/abs/2507.23700)
*Andrey Prokopenko,Daniel Arndt,Damien Lebrun-Grandié,Bruno Turcksin*

Main category: cs.DC

TL;DR: ArborX 2.0是一个基于Kokkos的性能可移植几何搜索库，新增了接口、数据结构、回调功能和算法支持。


<details>
  <summary>Details</summary>
Motivation: 扩展ArborX库的功能，以支持更广泛的用户问题和应用场景。

Method: 引入新接口、数据结构（如暴力搜索和分布式搜索）、回调功能，并扩展算法（如光线追踪和聚类）。

Result: ArborX 2.0提供了更灵活的功能和更高的性能可移植性。

Conclusion: ArborX 2.0通过新增功能和改进，显著提升了库的实用性和适用范围。

Abstract: This paper provides an overview of the 2.0 release of the ArborX library, a
performance portable geometric search library based on Kokkos. We describe the
major changes in ArborX 2.0 including a new interface for the library to
support a wider range of user problems, new search data structures (brute
force, distributed), support for user functions to be executed on the results
(callbacks), and an expanded set of the supported algorithms (ray tracing,
clustering).

</details>
