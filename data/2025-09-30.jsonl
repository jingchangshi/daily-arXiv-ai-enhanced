{"id": "2509.22679", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.22679", "abs": "https://arxiv.org/abs/2509.22679", "authors": ["Abdessalam Benhari", "Yves Denneulin", "Frédéric Desprez", "Fanny Dufossé", "Denis Trystram"], "title": "Analysis of the carbon footprint of HPC", "comment": null, "summary": "The demand in computing power has never stopped growing over the years.\nToday, the performance of the most powerful systems exceeds the exascale.\nUnfortunately, this growth also comes with ever-increasing energy costs,\nleading to a high carbon footprint. This paper investigates the evolution of\nhigh performance systems in terms of carbon emissions. A lot of studies focus\non Top500 (and Green500) as the tip of an iceberg to identify trends in the\ndomain in terms of computing performance. We propose here to go further in\nconsidering the whole span life of several large scale systems and to link the\nevolution with trajectory toward 2030. More precisely, we introduce the energy\nmix in the analysis of Top500 systems and we derive a predictive model for\nestimating the weight of HPC for the next 5 years."}
{"id": "2509.22681", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.22681", "abs": "https://arxiv.org/abs/2509.22681", "authors": ["Xianwen Guo", "Bin Huang", "Xiaomeng Wu", "Guanlin Wu", "Fangjian Li", "Shijia Wang", "Qiang Xiao", "Chuanjiang Luo", "Yong Li"], "title": "FLAME: A Serving System Optimized for Large-Scale Generative Recommendation with Efficiency", "comment": null, "summary": "Generative recommendation (GR) models possess greater scaling power compared\nto traditional deep learning recommendation models (DLRMs), yet they also\nimpose a tremendous increase in computational burden. Measured in FLOPs, a\ntypical GR model's workload sits in $10^9 \\sim 10^{11}$ range, roughly four\norders of magnitude higher than traditional DLRMs. Delivering accurate results\nin a few tens of milliseconds while processing billions of such requests per\nday puts extreme demands on the performance of the online serving system.\nTherefore, for industry practitioners, the alluring gains of GR models are\ntempered by the formidable challenge of online deployment at scale in\nproduction services. In this work, we introduce a comprehensive solution of\nonline serving system tailored For Large-scale GenerAtive RecoMmendation with\nEfficiency (FLAME). Specifically, we leveraging CPU-GPU heterogeneous hardware\nto decouple feature pre-processing and model computation. We encapsulated\nseveral memory optimization features as the Proximal Data Accelerator (PDA)\nmodule to make full use of limited bandwidth and storage resources, which\nachieves a 1.9x throughput gain and a 1.7x latency reduction. We implement the\nFused Kernel Engine (FKE) module based on the functionality and interface of\nNVIDIA TensorRT to boost model computation, delivering a speedup ratio of\n4.6x-6.1x, throughput gain ratio of 4.7x-6.3x one step further. In addition, we\ndesign the Dynamic Stream Orchestrator (DSO) module to coordinate concurrent\nrequests, enhancing the system throughput performance with 1.3x improvement in\nthroughput and 2.3x speed-up under non-uniform distribution of upstream\ncandidates. Comprehensive evaluations demonstrate that our FLAME effectively\nsupports large-scale online deployment of GR models and achieves remarkable\nimprovements in system performance."}
{"id": "2509.22684", "categories": ["cs.DC", "cs.AR", "cs.CR", "cs.PF"], "pdf": "https://arxiv.org/pdf/2509.22684", "abs": "https://arxiv.org/abs/2509.22684", "authors": ["Tarunesh Verma", "Yichao Yuan", "Nishil Talati", "Todd Austin"], "title": "ZKProphet: Understanding Performance of Zero-Knowledge Proofs on GPUs", "comment": "To appear at 2025 IEEE International Symposium on Workload\n  Characterization", "summary": "Zero-Knowledge Proofs (ZKP) are protocols which construct cryptographic\nproofs to demonstrate knowledge of a secret input in a computation without\nrevealing any information about the secret. ZKPs enable novel applications in\nprivate and verifiable computing such as anonymized cryptocurrencies and\nblockchain scaling and have seen adoption in several real-world systems. Prior\nwork has accelerated ZKPs on GPUs by leveraging the inherent parallelism in\ncore computation kernels like Multi-Scalar Multiplication (MSM). However, we\nfind that a systematic characterization of execution bottlenecks in ZKPs, as\nwell as their scalability on modern GPU architectures, is missing in the\nliterature. This paper presents ZKProphet, a comprehensive performance study of\nZero-Knowledge Proofs on GPUs. Following massive speedups of MSM, we find that\nZKPs are bottlenecked by kernels like Number-Theoretic Transform (NTT), as they\naccount for up to 90% of the proof generation latency on GPUs when paired with\noptimized MSM implementations. Available NTT implementations under-utilize GPU\ncompute resources and often do not employ architectural features like\nasynchronous compute and memory operations. We observe that the arithmetic\noperations underlying ZKPs execute exclusively on the GPU's 32-bit integer\npipeline and exhibit limited instruction-level parallelism due to data\ndependencies. Their performance is thus limited by the available integer\ncompute units. While one way to scale the performance of ZKPs is adding more\ncompute units, we discuss how runtime parameter tuning for optimizations like\nprecomputed inputs and alternative data representations can extract additional\nspeedup. With this work, we provide the ZKP community a roadmap to scale\nperformance on GPUs and construct definitive GPU-accelerated ZKPs for their\napplication requirements and available hardware resources."}
{"id": "2509.22701", "categories": ["cs.DC", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.22701", "abs": "https://arxiv.org/abs/2509.22701", "authors": ["Leszek Sliwko", "Jolanta Mizera-Pietraszko"], "title": "Enhancing Cluster Scheduling in HPC: A Continuous Transfer Learning for Real-Time Optimization", "comment": "This is the accepted version of the paper published in 2025 IEEE\n  International Parallel and Distributed Processing Symposium Workshops\n  (IPDPSW). The final version is available at:\n  https://doi.org/10.1109/IPDPSW66978.2025.00056", "summary": "This study presents a machine learning-assisted approach to optimize task\nscheduling in cluster systems, focusing on node-affinity constraints.\nTraditional schedulers like Kubernetes struggle with real-time adaptability,\nwhereas the proposed continuous transfer learning model evolves dynamically\nduring operations, minimizing retraining needs. Evaluated on Google Cluster\nData, the model achieves over 99% accuracy, reducing computational overhead and\nimproving scheduling latency for constrained tasks. This scalable solution\nenables real-time optimization, advancing machine learning integration in\ncluster management and paving the way for future adaptive scheduling\nstrategies."}
{"id": "2509.22980", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.22980", "abs": "https://arxiv.org/abs/2509.22980", "authors": ["Jingyao Zhang", "Elaheh Sadredini"], "title": "\\textit{No One-Size-Fits-All}: A Workload-Driven Characterization of Bit-Parallel vs. Bit-Serial Data Layouts for Processing-using-Memory", "comment": null, "summary": "Processing-in-Memory (PIM) is a promising approach to overcoming the\nmemory-wall bottleneck. However, the PIM community has largely treated its two\nfundamental data layouts, Bit-Parallel (BP) and Bit-Serial (BS), as if they\nwere interchangeable. This implicit \"one-layout-fits-all\" assumption, often\nhard-coded into existing evaluation frameworks, creates a critical gap:\narchitects lack systematic, workload-driven guidelines for choosing the optimal\ndata layout for their target applications.\n  To address this gap, this paper presents the first systematic,\nworkload-driven characterization of BP and BS PIM architectures. We develop\niso-area, cycle-accurate BP and BS PIM architectural models and conduct a\ncomprehensive evaluation using a diverse set of benchmarks. Our suite includes\nboth fine-grained microworkloads from MIMDRAM to isolate specific operational\ncharacteristics, and large-scale applications from the PIMBench suite, such as\nthe VGG network, to represent realistic end-to-end workloads.\n  Our results quantitatively demonstrate that no single layout is universally\nsuperior; the optimal choice is strongly dependent on workload characteristics.\nBP excels on control-flow-intensive tasks with irregular memory access\npatterns, whereas BS shows substantial advantages in massively parallel,\nlow-precision (e.g., INT4/INT8) computations common in AI. Based on this\ncharacterization, we distill a set of actionable design guidelines for\narchitects. This work challenges the prevailing one-size-fits-all view on PIM\ndata layouts and provides a principled foundation for designing\nnext-generation, workload-aware, and potentially hybrid PIM systems."}
{"id": "2509.22982", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.22982", "abs": "https://arxiv.org/abs/2509.22982", "authors": ["David M Kahn", "Jan Hoffmann", "Thomas Reps", "Jessie Grosen"], "title": "Efficient Cost Bounds with Linear Maps", "comment": null, "summary": "The Automatic Amortized Resource Analysis (AARA) derives program-execution\ncost bounds using types. To do so, AARA often makes use of cost-free types,\nwhich are critical for the composition of types and cost bounds. However,\ninferring cost-free types using the current state-of-the-art algorithm is\nexpensive due to recursive dependence on additional cost-free types.\nFurthermore, that algorithm uses a heuristic only applicable to polynomial cost\nbounds, and not, e.g., exponential bounds. This paper presents a new approach\nto these problems by representing the cost-free types of a function in a new\nway: with a linear map, which can stand for infinitely many cost-free types.\nSuch maps enable an algebraic flavor of reasoning about cost bounds (including\nnon-polynomial bounds) via matrix inequalities. These inequalities can be\nsolved with off-the-shelf linear-programming tools for many programs, so that\ntypes can always be efficiently checked and often be efficiently inferred. An\nexperimental evaluation with a prototype implementation shows that-when it is\napplicable-the inference of linear maps is exponentially more efficient than\nthe state-of-the-art algorithm."}
{"id": "2509.22704", "categories": ["cs.DC", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.22704", "abs": "https://arxiv.org/abs/2509.22704", "authors": ["Leszek Sliwko"], "title": "Intelligent Load Balancing in Cloud Computer Systems", "comment": "A thesis submitted in partial fulfilment of the requirements of the\n  University of Westminster for the degree of Doctor of Philosophy", "summary": "Cloud computing is an established technology allowing users to share\nresources on a large scale, never before seen in IT history. A cloud system\nconnects multiple individual servers in order to process related tasks in\nseveral environments at the same time. Clouds are typically more cost-effective\nthan single computers of comparable computing performance. The sheer physical\nsize of the system itself means that thousands of machines may be involved. The\nfocus of this research was to design a strategy to dynamically allocate tasks\nwithout overloading Cloud nodes which would result in system stability being\nmaintained at minimum cost. This research has added the following new\ncontributions to the state of knowledge: (i) a novel taxonomy and\ncategorisation of three classes of schedulers, namely OS-level, Cluster and Big\nData, which highlight their unique evolution and underline their different\nobjectives; (ii) an abstract model of cloud resources utilisation is specified,\nincluding multiple types of resources and consideration of task migration\ncosts; (iii) a virtual machine live migration was experimented with in order to\ncreate a formula which estimates the network traffic generated by this process;\n(iv) a high-fidelity Cloud workload simulator, based on a month-long workload\ntraces from Google's computing cells, was created; (v) two possible approaches\nto resource management were proposed and examined in the practical part of the\nmanuscript: the centralised metaheuristic load balancer and the decentralised\nagent-based system. The project involved extensive experiments run on the\nUniversity of Westminster HPC cluster, and the promising results are presented\ntogether with detailed discussions and a conclusion."}
{"id": "2509.22999", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.22999", "abs": "https://arxiv.org/abs/2509.22999", "authors": ["Sachin Sachdeva", "Jincong Lu", "Wantong Li", "Sheldon X. -D. Tan"], "title": "Enhanced Hybrid Temporal Computing Using Deterministic Summations for Ultra-Low-Power Accelerators", "comment": "8 pages", "summary": "This paper presents an accuracy-enhanced Hybrid Temporal Computing (E-HTC)\nframework for ultra-low-power hardware accelerators with deterministic\nadditions. Inspired by the recently proposed HTC architecture, which leverages\npulse-rate and temporal data encoding to reduce switching activity and energy\nconsumption but loses accuracy due to its multiplexer (MUX)-based scaled\naddition, we propose two bitstream addition schemes: (1) an Exact\nMultiple-input Binary Accumulator (EMBA), which performs precise binary\naccumulation, and (2) a Deterministic Threshold-based Scaled Adder (DTSA),\nwhich employs threshold logic for scaled addition. These adders are integrated\ninto a multiplier accumulator (MAC) unit supporting both unipolar and bipolar\nencodings. To validate the framework, we implement two accelerators: a Finite\nImpulse Response (FIR) filter and an 8-point Discrete Cosine Transform\n(DCT)/iDCT engine. Results on a 4x4 MAC show that, in unipolar mode, E-HTC\nmatches the RMSE of state-of-the-art Counter-Based Stochastic Computing (CBSC)\nMAC, improves accuracy by 94% over MUX-based HTC, and reduces power and area by\n23% and 7% compared to MUX-based HTC and 64% and 74% compared to CBSC. In\nbipolar mode, E-HTC MAC achieves 2.09% RMSE -- an 83% improvement over\nMUX-based HTC -- and approaches CBSC's 1.40% RMSE with area and power savings\nof 28% and 43% vs. MUX-based HTC and about 76% vs. CBSC. In FIR experiments,\nboth E-HTC variants yield PSNR gains of 3--5 dB (30--45% RMSE reduction) while\nsaving 13% power and 3% area. For DCT/iDCT, E-HTC boosts PSNR by 10--13 dB\n(70--75% RMSE reduction) while saving area and power over both MUX- and\nCBSC-based designs."}
{"id": "2509.23061", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.23061", "abs": "https://arxiv.org/abs/2509.23061", "authors": ["Xu Xu", "Xin Li", "Xingwei Qu", "Jie Fu", "Binhang Yuan"], "title": "Local Success Does Not Compose: Benchmarking Large Language Models for Compositional Formal Verification", "comment": null, "summary": "We introduce DafnyCOMP, a benchmark for evaluating large language models\n(LLMs) on compositional specification generation in Dafny. Unlike prior\nbenchmarks that focus on single-function tasks, DafnyCOMP targets programs\ncomposed of multiple interacting functions with data dependencies, requiring\nreasoning across component boundaries. The benchmark consists of 300\nautomatically synthesized multi-function programs. We evaluate several\nstate-of-the-art LLM families and find that, while they perform well on\nsingle-function verification, their performance drops sharply on compositional\ntasks. Analysis reveals systematic failures in cross-functional reasoning,\nincluding fragile specifications, misalignment between implementations and\nproofs, and unstable reasoning. DafnyCOMP thus provides a diagnostic tool for\nmeasuring progress toward reliable, verifiable, and compositional code\ngeneration with LLMs."}
{"id": "2509.22707", "categories": ["cs.DC", "cs.LG", "stat.ML"], "pdf": "https://arxiv.org/pdf/2509.22707", "abs": "https://arxiv.org/abs/2509.22707", "authors": ["Jinqi Yan", "Fang He", "Qianlong Sang", "Bifeng Tong", "Peng Sun", "Yili Gong", "Chuang Hu", "Dazhao Cheng"], "title": "Metadata-Guided Adaptable Frequency Scaling across Heterogeneous Applications and Devices", "comment": null, "summary": "Dynamic Voltage and Frequency Scaling is essential for enhancing energy\nefficiency in mobile platforms. However, traditional heuristic-based governors\nare increasingly inadequate for managing the complexity of heterogeneous\nSystem-on-Chip designs and diverse application workloads. Although\nreinforcement learning approaches offer improved performance, their poor\ngeneralization capability and reliance on extensive retraining for each\nhardware and application combination leads to significant deployment costs. In\nthis work, we observe that device and application metadata inherently\nencapsulate valuable knowledge for DVFS, presenting an opportunity to overcome\nthese limitations. We formulate DVFS for heterogeneous devices and applications\nas a multi-task reinforcement learning problem. We introduce MetaDVFS, which is\na metadata-guided framework that systematically leverages metadata to discover\nand transfer shared knowledge across DVFS tasks. MetaDVFS can output a set of\nDVFS models with significant generalization capability for various applications\nof heterogeneous devices. Evaluations on five Google Pixel devices running six\napplications show that MetaDVFS achieves up to 17% improvement in\nPerformance-Power Ratio and up to 26% improvement in Quality of Experience.\nCompared to state-of-the-art methods, MetaDVFS delivers 70.8% faster adaptation\nand 5.8-27.6% higher performance over standalone device-application specific\ntraining, while avoiding negative transfer effects. These results establish\nMetaDVFS as an effective and scalable solution for DVFS deployment in\nheterogeneous mobile environments."}
{"id": "2509.23179", "categories": ["cs.AR", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.23179", "abs": "https://arxiv.org/abs/2509.23179", "authors": ["Jingyao Zhang", "Elaheh Sadredini"], "title": "A Near-Cache Architectural Framework for Cryptographic Computing", "comment": null, "summary": "Recent advancements in post-quantum cryptographic algorithms have led to\ntheir standardization by the National Institute of Standards and Technology\n(NIST) to safeguard information security in the post-quantum era. These\nalgorithms, however, employ public keys and signatures that are 3 to 9$\\times$\nlonger than those used in pre-quantum cryptography, resulting in significant\nperformance and energy efficiency overheads. A critical bottleneck identified\nin our analysis is the cache bandwidth. This limitation motivates the adoption\nof on-chip in-/near-cache computing, a computing paradigm that offers\nhigh-performance, exceptional energy efficiency, and flexibility to accelerate\npost-quantum cryptographic algorithms. Our analysis of existing works reveals\nchallenges in integrating in-/near-cache computing into modern computer systems\nand performance limitations due to external bandwidth limitation, highlighting\nthe need for innovative solutions that can seamlessly integrate into existing\nsystems without performance and energy efficiency issues. In this paper, we\nintroduce a near-cache-slice computing paradigm with support of customization\nand virtual address, named Crypto-Near-Cache (CNC), designed to accelerate\npost-quantum cryptographic algorithms and other applications. By placing SRAM\narrays with bitline computing capability near cache slices, high internal\nbandwidth and short data movement are achieved with native support of virtual\naddressing. An ISA extension to facilitate CNC is also proposed, with detailed\ndiscussion on the implementation aspects of the core/cache datapath."}
{"id": "2509.23229", "categories": ["cs.PL", "D.2.4; F.3.1"], "pdf": "https://arxiv.org/pdf/2509.23229", "abs": "https://arxiv.org/abs/2509.23229", "authors": ["Yawen Guan", "Clément Pit-Claudel"], "title": "Fine-Grained Reasoning About Container-Internal Pointers with Logical Pinning", "comment": null, "summary": "Most separation logics hide container-internal pointers for modularity. This\nmakes it difficult to specify container APIs that temporarily expose those\npointers to the outside, and to verify programs that use these APIs. We present\nlogical pinning, a lightweight borrowing model for sequential programs that\nallows users to selectively track container-internal pointers at the logical\nlevel. Our model generalizes the magic-wand operator, making it easy to write\nand prove precise specifications, including pointer-stability properties.\nBecause it only changes how representation predicates and specifications are\nwritten, our approach is compatible with most separation logic variants. We\ndemonstrate the practicality of logical pinning by verifying small but\nrepresentative pointer-manipulating programs, and deriving more precise\nversions of common container specifications. In doing so, we show that our\napproach subsumes some well-known proof patterns, simplifies some complex\nproofs, and enables reasoning about program patterns not supported by\ntraditional specifications. All of our results are mechanized in the Rocq proof\nassistant, using the CFML library."}
{"id": "2509.22832", "categories": ["cs.DC", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.22832", "abs": "https://arxiv.org/abs/2509.22832", "authors": ["Biyao Zhang", "Mingkai Zheng", "Debargha Ganguly", "Xuecen Zhang", "Vikash Singh", "Vipin Chaudhary", "Zhao Zhang"], "title": "Efficient Fine-Grained GPU Performance Modeling for Distributed Deep Learning of LLM", "comment": null, "summary": "Training Large Language Models(LLMs) is one of the most compute-intensive\ntasks in high-performance computing. Predicting end-to-end training time for\nmulti-billion parameter models distributed across hundreds of GPUs remains\nchallenging due to complex interactions between transformer components,\nparallelism strategies(data, model, pipeline, tensor), and multi-tier\ncommunication. Learned models require costly sampling, while analytical models\noften struggle with real-world network and hardware complexities. We address\nthis by decomposing LLMs into core computational primitives and modeling them\nwith: (1) operator-level decomposition for fine-grained analysis; (2)\nlightweight sampling based hardware-aware prediction models for key operations;\n(3) an end-to-end prediction system integrating these components across complex\nparallelization strategies. Crucially, our methodology has been validated on\ntwo large-scale HPC systems. Our framework achieves low average prediction\nerrors-4.98\\% on Perlmutter(A100) and 9.38\\% on Vista(GH200)-for models up to\n20B parameters across 128 GPUs. Importantly, it runs entirely on CPUs, enabling\nrapid iteration over hardware configurations and training strategies without\ncostly on-cluster experimentation."}
{"id": "2509.23674", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.23674", "abs": "https://arxiv.org/abs/2509.23674", "authors": ["Hongqin Lyu", "Yonghao Wang", "Yunlin Du", "Mingyu Shi", "Zhiteng Chao", "Wenxing Li", "Tiancheng Wang", "Huawei Li"], "title": "AssertGen: Enhancement of LLM-aided Assertion Generation through Cross-Layer Signal Bridging", "comment": "6 pages, 7 figures", "summary": "Assertion-based verification (ABV) serves as a crucial technique for ensuring\nthat register-transfer level (RTL) designs adhere to their specifications.\nWhile Large Language Model (LLM) aided assertion generation approaches have\nrecently achieved remarkable progress, existing methods are still unable to\neffectively identify the relationship between design specifications and RTL\ndesigns, which leads to the insufficiency of the generated assertions. To\naddress this issue, we propose AssertGen, an assertion generation framework\nthat automatically generates SystemVerilog assertions (SVA). AssertGen first\nextracts verification objectives from specifications using a chain-of-thought\n(CoT) reasoning strategy, then bridges corresponding signals between these\nobjectives and the RTL code to construct a cross-layer signal chain, and\nfinally generates SVAs based on the LLM. Experimental results demonstrate that\nAssertGen outperforms the existing state-of-the-art methods across several key\nmetrics, such as pass rate of formal property verification (FPV), cone of\ninfluence (COI), proof core and mutation testing coverage."}
{"id": "2509.25114", "categories": ["cs.PL", "cs.SC", "math.AG"], "pdf": "https://arxiv.org/pdf/2509.25114", "abs": "https://arxiv.org/abs/2509.25114", "authors": ["Erdenebayar Bayarmagnai", "Fatemeh Mohammadi", "Rémi Prébet"], "title": "From Affine to Polynomial: Synthesizing Loops with Branches via Algebraic Geometry", "comment": null, "summary": "Ensuring software correctness remains a fundamental challenge in formal\nprogram verification. One promising approach relies on finding polynomial\ninvariants for loops. Polynomial invariants are properties of a program loop\nthat hold before and after each iteration. Generating such invariants is a\ncrucial task in loop analysis, but it is undecidable in the general case.\nRecently, an alternative approach to this problem has emerged, focusing on\nsynthesizing loops from invariants. However, existing methods only synthesize\naffine loops without guard conditions from polynomial invariants. In this\npaper, we address a more general problem, allowing loops to have polynomial\nupdate maps with a given structure, inequations in the guard condition, and\npolynomial invariants of arbitrary form.\n  We use algebraic geometry tools to design and implement an algorithm that\ncomputes a finite set of polynomial equations whose solutions correspond to all\nnondeterministic branching loops satisfying the given invariants. Furthermore,\nwe introduce a new class of invariants for which we present a significantly\nmore efficient algorithm. In other words, we reduce the problem of synthesizing\nloops to find solutions of multivariate polynomial systems with rational\nentries. This final step is handled in our software using an SMT solver."}
{"id": "2509.22922", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.22922", "abs": "https://arxiv.org/abs/2509.22922", "authors": ["Pranjal Naman", "Yogesh Simmhan"], "title": "OptimES: Optimizing Federated Learning Using Remote Embeddings for Graph Neural Networks", "comment": "Extended full-length version of paper that appeared at Euro-Par 2024:\n  \"Optimizing Federated Learning Using Remote Embeddings for Graph Neural\n  Networks\", Pranjal Naman and Yogesh Simmhan, in International European\n  Conference on Parallel and Distributed Computing (Euro-Par), 2024. DOI:\n  https://doi.org/10.1007/978-3-031-69766-1_32", "summary": "Graph Neural Networks (GNNs) have experienced rapid advancements in recent\nyears due to their ability to learn meaningful representations from graph data\nstructures. However, in most real-world settings, such as financial transaction\nnetworks and healthcare networks, this data is localized to different data\nowners and cannot be aggregated due to privacy concerns. Federated Learning\n(FL) has emerged as a viable machine learning approach for training a shared\nmodel that iteratively aggregates local models trained on decentralized data.\nThis addresses privacy concerns while leveraging parallelism. State-of-the-art\nmethods enhance the privacy-respecting convergence accuracy of federated GNN\ntraining by sharing remote embeddings of boundary vertices through a server\n(EmbC). However, they are limited by diminished performance due to large\ncommunication costs. In this article, we propose OptimES, an optimized\nfederated GNN training framework that employs remote neighbourhood pruning,\noverlapping the push of embeddings to the server with local training, and\ndynamic pulling of embeddings to reduce network costs and training time. We\nperform a rigorous evaluation of these strategies for four common graph\ndatasets with up to $111M$ vertices and $1.8B$ edges. We see that a modest drop\nin per-round accuracy due to the preemptive push of embeddings is out-stripped\nby the reduction in per-round training time for large and dense graphs like\nReddit and Products, converging up to $\\approx 3.5\\times$ faster than EmbC and\ngiving up to $\\approx16\\%$ better accuracy than the default federated GNN\nlearning. While accuracy improvements over default federated GNNs are modest\nfor sparser graphs like Arxiv and Papers, they achieve the target accuracy\nabout $\\approx11\\times$ faster than EmbC."}
{"id": "2509.23693", "categories": ["cs.AR", "cs.OS"], "pdf": "https://arxiv.org/pdf/2509.23693", "abs": "https://arxiv.org/abs/2509.23693", "authors": ["Tao Lu", "Jiapin Wang", "Yelin Shan", "Xiangping Zhang", "Xiang Chen"], "title": "ASIC-based Compression Accelerators for Storage Systems: Design, Placement, and Profiling Insights", "comment": "16 pages", "summary": "Lossless compression imposes significant computational over head on\ndatacenters when performed on CPUs. Hardware compression and decompression\nprocessing units (CDPUs) can alleviate this overhead, but optimal algorithm\nselection, microarchitectural design, and system-level placement of CDPUs are\nstill not well understood. We present the design of an ASIC-based in-storage\nCDPU and provide a comprehensive end-to-end evaluation against two leading ASIC\naccelerators, Intel QAT 8970 and QAT 4xxx. The evaluation spans three dominant\nCDPU placement regimes: peripheral, on-chip, and in-storage. Our results\nreveal: (i) acute sensitivity of throughput and latency to CDPU placement and\ninterconnection, (ii) strong correlation between compression efficiency and\ndata patterns/layouts, (iii) placement-driven divergences between\nmicrobenchmark gains and real-application speedups, (iv) discrepancies between\nmodule and system-level power efficiency, and (v) scalability and multi-tenant\ninterference is sues of various CDPUs. These findings motivate a\nplacement-aware, cross-layer rethinking of hardware (de)compression for\nhyperscale storage infrastructures."}
{"id": "2509.23013", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.23013", "abs": "https://arxiv.org/abs/2509.23013", "authors": ["Varad Kulkarni", "Nikhil Reddy", "Tuhin Khare", "Abhinandan S. Prasad", "Chitra Babu", "Yogesh Simmhan"], "title": "Characterizing FaaS Workflows on Public Clouds: The Good, the Bad and the Ugly", "comment": null, "summary": "Function-as-a-service (FaaS) is a popular serverless computing paradigm for\ndeveloping event-driven functions that elastically scale on public clouds. FaaS\nworkflows, such as AWS Step Functions and Azure Durable Functions, are composed\nfrom FaaS functions, like AWS Lambda and Azure Functions, to build practical\napplications. But, the complex interactions between functions in the workflow\nand the limited visibility into the internals of proprietary FaaS platforms are\nmajor impediments to gaining a deeper understanding of FaaS workflow platforms.\nWhile several works characterize FaaS platforms to derive such insights, there\nis a lack of a principled and rigorous study for FaaS workflow platforms, which\nhave unique scaling, performance and costing behavior influenced by the\nplatform design, dataflow and workloads. In this article, we perform extensive\nevaluations of three popular FaaS workflow platforms from AWS and Azure,\nrunning 25 micro-benchmark and application workflows over 132k invocations. Our\ndetailed analysis confirms some conventional wisdom but also uncovers unique\ninsights on the function execution, workflow orchestration, inter-function\ninteractions, cold-start scaling and monetary costs. Our observations help\ndevelopers better configure and program these platforms, set performance and\nscalability expectations, and identify research gaps on enhancing the\nplatforms."}
{"id": "2509.23972", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.23972", "abs": "https://arxiv.org/abs/2509.23972", "authors": ["Hongqin Lyu", "Yunlin Du", "Yonghao Wang", "Zhiteng Chao", "Tiancheng Wang", "Huawei Li"], "title": "AssertFix: Empowering Automated Assertion Fix via Large Language Models", "comment": "6 pages, 6 figures", "summary": "Assertion-based verification (ABV) is critical in ensuring that\nregister-transfer level (RTL) designs conform to their functional\nspecifications. SystemVerilog Assertions (SVA) effectively specify design\nproperties, but writing and maintaining them manually is challenging and\nerror-prone. Although recent progress of assertion generation methods\nleveraging large language models (LLMs) have shown great potential in improving\nassertion quality, they typically treat assertion generation as a final step,\nleaving the burden of fixing of the incorrect assertions to human effects,\nwhich may significantly limits the application of these methods. To address the\nabove limitation, we propose an automatic assertion fix framework based on\nLLMs, named AssertFix. AsserFix accurately locates the RTL code related to the\nincorrect assertion, systematically identifies the root causes of the assertion\nerrors, classifies the error type and finally applies dedicated fix strategies\nto automatically correct these errors, improving the overall quality of the\ngenerated assertions. Experimental results show that AssertFix achieves\nnoticeable improvements in both fix rate and verification coverage across the\nOpencore benchmarks."}
{"id": "2509.23241", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.23241", "abs": "https://arxiv.org/abs/2509.23241", "authors": ["Ankita Dutta", "Nabendu Chaki", "Rajat K. De"], "title": "Memory Efficient and Staleness Free Pipeline Parallel DNN Training Framework with Improved Convergence Speed", "comment": null, "summary": "High resource requirement for Deep Neural Network (DNN) training across\nmultiple GPUs necessitates development of various parallelism techniques. In\nthis paper, we introduce two interconnected DNN training frameworks, namely,\nV-TiMePReSt and I-TiMePReSt, based on pipeline parallelism, a variant of model\nparallelism. V-TiMePReSt is a completely staleness-free system which enables\nthe DNNs to be trained on the latest updated weights in each stage of all\nforward and backward passes. Developing staleness-aware systems at the expense\nof weight stashing reduces GPU-memory consumption, however, increases the\nnumber of epochs to converge. Thus, we introduce I-TiMePReSt, which is also a\nstaleness-aware system, but not at the expense of weight stashing. It does not\nrely solely on the stale weights or the latest updated weights. I-TiMePReSt\ncomputes an intermediate weight towards the latter and performs backward pass\non it. Additionally, we formulate the significance of the stale weights\nmathematically depending on the degree of staleness. In contrast to\nV-TiMePReSt, I-TiMePReSt works based on the assumption that stale weights have\na significant contribution in training, which can be quantified mathematically\nbased on the degree of staleness, although there are other contributory factors\nwhich should not be ignored. Experimental results show that V-TiMePReSt is\nadvantageous over existing models in terms of $1)$ the extent of staleness of\nthe weight parameter values and $2)$ GPU memory efficiency, while I-TiMePReSt\nis superior in terms of $1)$ removing staleness of the weight parameters\nwithout removing weight stashing and $2)$ maintaining the trade-off between GPU\nmemory consumption and convergence speed (number of epochs)."}
{"id": "2509.24929", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.24929", "abs": "https://arxiv.org/abs/2509.24929", "authors": ["Hongwei Zhao", "Vianney Lapotre", "Guy Gogniat"], "title": "Fault Injection in On-Chip Interconnects: A Comparative Study of Wishbone, AXI-Lite, and AXI", "comment": "12 pages, 7 tables", "summary": "Fault injection attacks exploit physical disturbances to compromise the\nfunctionality and security of integrated circuits. As System on Chip (SoC)\narchitectures grow in complexity, the vulnerability of on chip communication\nfabrics has become increasingly prominent. Buses, serving as interconnects\namong various IP cores, represent potential vectors for fault-based\nexploitation. In this study, we perform simulation-driven fault injection\nacross three mainstream bus protocols Wishbone, AXI Lite, and AXI. We\nsystematically examine fault success rates, spatial vulnerability\ndistributions, and timing dependencies to characterize how faults interact with\nbus-level transactions. The results uncover consistent behavioral patterns\nacross protocols, offering practical insights for both attack modeling and the\ndevelopment of resilient SoC designs."}
{"id": "2509.23324", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.23324", "abs": "https://arxiv.org/abs/2509.23324", "authors": ["Zixu Hao", "Jianyu Wei", "Tuowei Wang", "Minxing Huang", "Huiqiang Jiang", "Shiqi Jiang", "Ting Cao", "Ju Ren"], "title": "Scaling LLM Test-Time Compute with Mobile NPU on Smartphones", "comment": null, "summary": "Deploying Large Language Models (LLMs) on mobile devices faces the challenge\nof insufficient performance in smaller models and excessive resource\nconsumption in larger ones. This paper highlights that mobile Neural Processing\nUnits (NPUs) have underutilized computational resources, particularly their\nmatrix multiplication units, during typical LLM inference. To leverage this\nwasted compute capacity, we propose applying parallel test-time scaling\ntechniques on mobile NPUs to enhance the performance of smaller LLMs. However,\nthis approach confronts inherent NPU challenges, including inadequate hardware\nsupport for fine-grained quantization and low efficiency in general-purpose\ncomputations. To overcome these, we introduce two key techniques: a\nhardware-aware tile quantization scheme that aligns group quantization with NPU\nmemory access patterns, and efficient LUT-based replacements for complex\noperations such as Softmax and dequantization. We design and implement an\nend-to-end inference system that leverages the NPU's compute capability to\nsupport test-time scaling on Qualcomm Snapdragon platforms. Experiments show\nour approach brings significant speedups: up to 19.0 for mixed-precision GEMM\nand 2.2 for Softmax. More importantly, we demonstrate that smaller models using\ntest-time scaling can match or exceed the accuracy of larger models, achieving\na new performance-cost Pareto frontier."}
{"id": "2509.22684", "categories": ["cs.DC", "cs.AR", "cs.CR", "cs.PF"], "pdf": "https://arxiv.org/pdf/2509.22684", "abs": "https://arxiv.org/abs/2509.22684", "authors": ["Tarunesh Verma", "Yichao Yuan", "Nishil Talati", "Todd Austin"], "title": "ZKProphet: Understanding Performance of Zero-Knowledge Proofs on GPUs", "comment": "To appear at 2025 IEEE International Symposium on Workload\n  Characterization", "summary": "Zero-Knowledge Proofs (ZKP) are protocols which construct cryptographic\nproofs to demonstrate knowledge of a secret input in a computation without\nrevealing any information about the secret. ZKPs enable novel applications in\nprivate and verifiable computing such as anonymized cryptocurrencies and\nblockchain scaling and have seen adoption in several real-world systems. Prior\nwork has accelerated ZKPs on GPUs by leveraging the inherent parallelism in\ncore computation kernels like Multi-Scalar Multiplication (MSM). However, we\nfind that a systematic characterization of execution bottlenecks in ZKPs, as\nwell as their scalability on modern GPU architectures, is missing in the\nliterature. This paper presents ZKProphet, a comprehensive performance study of\nZero-Knowledge Proofs on GPUs. Following massive speedups of MSM, we find that\nZKPs are bottlenecked by kernels like Number-Theoretic Transform (NTT), as they\naccount for up to 90% of the proof generation latency on GPUs when paired with\noptimized MSM implementations. Available NTT implementations under-utilize GPU\ncompute resources and often do not employ architectural features like\nasynchronous compute and memory operations. We observe that the arithmetic\noperations underlying ZKPs execute exclusively on the GPU's 32-bit integer\npipeline and exhibit limited instruction-level parallelism due to data\ndependencies. Their performance is thus limited by the available integer\ncompute units. While one way to scale the performance of ZKPs is adding more\ncompute units, we discuss how runtime parameter tuning for optimizations like\nprecomputed inputs and alternative data representations can extract additional\nspeedup. With this work, we provide the ZKP community a roadmap to scale\nperformance on GPUs and construct definitive GPU-accelerated ZKPs for their\napplication requirements and available hardware resources."}
{"id": "2509.23384", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.23384", "abs": "https://arxiv.org/abs/2509.23384", "authors": ["Yue Zhang", "Yuansheng Chen", "Xuan Mo", "Alex Xi", "Jialun Li", "WeiGang Wu"], "title": "A Predictive and Synergistic Two-Layer Scheduling Framework for LLM Serving", "comment": null, "summary": "LLM inference serving typically scales out with a two-tier architecture: a\ncluster router distributes requests to multiple inference engines, each of\nwhich then in turn performs its own internal scheduling. However, this commonly\nused paradigm suffers from critical, systemic inefficiency caused by the\ninformation gaps across two layers. At the cluster-layer, the router mainly\nrelies on lagging, coarse-grained metrics, such as average latency and queue\nlength to make decisions, resulting in \"decision lag\" that leads to suboptimal\nrequest routing. At the engine-layer, static heuristic scheduling policies\ncannot effectively handle the dynamic workloads, leading a poor balance between\nlatency and throughput. Besides, these gaps may cause SLO violations and\nresource waste, especially in heterogeneous cloud environments.\n  To bridge such gaps, we propose SynergySched, a cross-layer framework that\nshifts LLM serving system from reactive load balancing to predictive\norchestration. The core of SynergySched lies in a structurally-informed online\nperformance model that provides accurate, forward-looking per-step latency and\ncapacity estimations. This model empowers two key components. At the\nengine-layer, LENS performs SLO-aware, adaptive scheduling, dynamically\noptimizing batching to meet SLOs under real-time loads. At the cluster-layer,\nPRISM uses predictive signals to perform state-driven routing, maximizing\ncluster-wide performance and SLO attainment. Performance evaluations show that\nSynergySched improves SLO attainment by 43% on average and achieves up to 3x\nthroughput speedup in long-context and heterogeneous scenarios. Besides, we\nalso deploy SynergySched on FlowGPT's clusters to demonstrate its advantages in\nproduction environment."}
{"id": "2509.23419", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.23419", "abs": "https://arxiv.org/abs/2509.23419", "authors": ["Asadullah Tariq", "Tariq Qayyum", "Mohamed Adel Serhani", "Farag Sallabi", "Ikbal Taleb", "Ezedin S. Barka"], "title": "Enhancing Communication Efficiency in FL with Adaptive Gradient Quantization and Communication Frequency Optimization", "comment": null, "summary": "Federated Learning (FL) enables participant devices to collaboratively train\ndeep learning models without sharing their data with the server or other\ndevices, effectively addressing data privacy and computational concerns.\nHowever, FL faces a major bottleneck due to high communication overhead from\nfrequent model updates between devices and the server, limiting deployment in\nresource-constrained wireless networks. In this paper, we propose a three-fold\nstrategy. Firstly, an Adaptive Feature-Elimination Strategy to drop less\nimportant features while retaining high-value ones; secondly, Adaptive Gradient\nInnovation and Error Sensitivity-Based Quantization, which dynamically adjusts\nthe quantization level for innovative gradient compression; and thirdly,\nCommunication Frequency Optimization to enhance communication efficiency. We\nevaluated our proposed model's performance through extensive experiments,\nassessing accuracy, loss, and convergence compared to baseline techniques. The\nresults show that our model achieves high communication efficiency in the\nframework while maintaining accuracy."}
{"id": "2509.23448", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.23448", "abs": "https://arxiv.org/abs/2509.23448", "authors": ["Hao Hao", "Dahlia Malkhi", "Maofan Yin", "Lizan Zhou"], "title": "Lyte Quorum: Off-Chain Ready Smart Contract Hosted with Choice", "comment": null, "summary": "This paper introduces Lyquor, a decentralized platform that reimagines\nblockchain infrastructure through a service-centric model where nodes\nselectively host smart contracts (called Lyquids) while preserving global\ncomposability. We present three key innovations: (1) Fate-Constrained Ordering\n(FCO), which decouples consensus from execution to enable selective hosting\nwithout sacrificing Layer-1 grade composability; (2) Direct Memory Architecture\n(DMA), which eliminates state access bottlenecks by providing each contract\nwith persistent, byte-addressable virtual memory; and (3) Universal Procedure\nCall (UPC), which enables fault-tolerant, programmable coordination across\ndistributed off-chain computation. Together, these components are powered by a\nRust-macroed unified programming model where on-chain and off-chain logic\ncoexist seamlessly, supporting both traditional smart contract patterns and\nnovel distributed applications. Lyquor addresses critical limitations in\nexisting systems while maintaining compatibility with Ethereum APIs, offering a\npath toward truly scalable decentralized computation."}
{"id": "2509.23706", "categories": ["cs.DC", "cs.DS"], "pdf": "https://arxiv.org/pdf/2509.23706", "abs": "https://arxiv.org/abs/2509.23706", "authors": ["Bogdan-Ioan Popa", "Adrian-Marius Dumitran", "Livia Magureanu"], "title": "Parallel Algorithms for the One Sided Crossing Minimization Problem", "comment": null, "summary": "The One Sided Crossing Minimization (OSCM) problem is an optimization problem\nin graph drawing that aims to minimize the number of edge crossings in\nbipartite graph layouts. It has practical applications in areas such as network\nvisualization and VLSI (Very Large Scale Integration) design, where reducing\nedge crossings improves the arrangement of circuit components and their\ninterconnections. Despite the rise of multi-core systems, the parallelization\nof exact and fixed-parameter tractable (FPT) algorithms for OSCM remains\nlargely unexplored. Parallel variants offer significant potential for scaling\nto larger graphs but require careful handling of synchronization and memory\nmanagement. In this paper, we explore various previously studied exact and FPT\nalgorithms for OSCM, implementing and analyzing them in both sequential and\nparallel forms. Our main contribution lies in empirically proving that these\nalgorithms can achieve close to linear speedup under parallelization. In\nparticular, our best result achieves a speedup of nearly 19 on a 16-core,\n32-thread machine. We further investigate and discuss the reasons why linear\nspeedup is not always attained."}
{"id": "2509.23722", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.23722", "abs": "https://arxiv.org/abs/2509.23722", "authors": ["Jihu Guo", "Tenghui Ma", "Wei Gao", "Peng Sun", "Jiaxing Li", "Xun Chen", "Yuyang Jin", "Dahua Lin"], "title": "AdaPtis: Reducing Pipeline Bubbles with Adaptive Pipeline Parallelism on Heterogeneous Models", "comment": "13 pages, 15 Figures; Under Review;", "summary": "Pipeline parallelism is widely used to train large language models (LLMs).\nHowever, increasing heterogeneity in model architectures exacerbates pipeline\nbubbles, thereby reducing training efficiency. Existing approaches overlook the\nco-optimization of model partition, model placement, and workload scheduling,\nresulting in limited efficiency improvement or even performance degradation. To\nrespond, we propose AdaPtis, an LLM training system that supports adaptive\npipeline parallelism. First, we develop a pipeline performance model to\naccurately estimate training throughput. Second, AdaPtis jointly optimizes\nmodel partition, model placement, and workload scheduling policies guided by\nthis performance model. Third, we design a unified pipeline executor that\nefficiently supports the execution of diverse pipeline strategies. Extensive\nexperiments show that AdaPtis achieves an average speedup of 1.42x (up to\n2.14x) over Megatron-LM I-1F1B across various LLM architectures and scales."}
{"id": "2509.24030", "categories": ["cs.DC", "cs.AI", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.24030", "abs": "https://arxiv.org/abs/2509.24030", "authors": ["Anjus George", "Michael Brim", "Christopher Zimmer", "David Rogers", "Sarp Oral", "Zach Mayes"], "title": "From Edge to HPC: Investigating Cross-Facility Data Streaming Architectures", "comment": null, "summary": "In this paper, we investigate three cross-facility data streaming\narchitectures, Direct Streaming (DTS), Proxied Streaming (PRS), and Managed\nService Streaming (MSS). We examine their architectural variations in data flow\npaths and deployment feasibility, and detail their implementation using the\nData Streaming to HPC (DS2HPC) architectural framework and the SciStream\nmemory-to-memory streaming toolkit on the production-grade Advanced Computing\nEcosystem (ACE) infrastructure at Oak Ridge Leadership Computing Facility\n(OLCF). We present a workflow-specific evaluation of these architectures using\nthree synthetic workloads derived from the streaming characteristics of\nscientific workflows. Through simulated experiments, we measure streaming\nthroughput, round-trip time, and overhead under work sharing, work sharing with\nfeedback, and broadcast and gather messaging patterns commonly found in AI-HPC\ncommunication motifs. Our study shows that DTS offers a minimal-hop path,\nresulting in higher throughput and lower latency, whereas MSS provides greater\ndeployment feasibility and scalability across multiple users but incurs\nsignificant overhead. PRS lies in between, offering a scalable architecture\nwhose performance matches DTS in most cases."}
{"id": "2509.24063", "categories": ["cs.DC", "cs.CE", "cs.MA", "cs.PF", "q-bio.QM"], "pdf": "https://arxiv.org/pdf/2509.24063", "abs": "https://arxiv.org/abs/2509.24063", "authors": ["Lukas Breitwieser", "Ahmad Hesam", "Abdullah Giray Yağlıkçı", "Mohammad Sadrosadati", "Fons Rademakers", "Onur Mutlu"], "title": "TeraAgent: A Distributed Agent-Based Simulation Engine for Simulating Half a Trillion Agents", "comment": null, "summary": "Agent-based simulation is an indispensable paradigm for studying complex\nsystems. These systems can comprise billions of agents, requiring the computing\nresources of multiple servers to simulate. Unfortunately, the state-of-the-art\nplatform, BioDynaMo, does not scale out across servers due to its\nshared-memory-based implementation.\n  To overcome this key limitation, we introduce TeraAgent, a distributed\nagent-based simulation engine. A critical challenge in distributed execution is\nthe exchange of agent information across servers, which we identify as a major\nperformance bottleneck. We propose two solutions: 1) a tailored serialization\nmechanism that allows agents to be accessed and mutated directly from the\nreceive buffer, and 2) leveraging the iterative nature of agent-based\nsimulations to reduce data transfer with delta encoding.\n  Built on our solutions, TeraAgent enables extreme-scale simulations with half\na trillion agents (an 84x improvement), reduces time-to-result with additional\ncompute nodes, improves interoperability with third-party tools, and provides\nusers with more hardware flexibility."}
{"id": "2509.24381", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.24381", "abs": "https://arxiv.org/abs/2509.24381", "authors": ["Tianyu Guo", "Tianming Xu", "Xianjie Chen", "Junru Chen", "Nong Xiao", "Xianwei Zhang"], "title": "RServe: Overlapping Encoding and Prefill for Efficient LMM Inference", "comment": null, "summary": "Large multimodal models (LMMs) typically employ an encoding module to\ntransform multimodal data inputs into embeddings, which are then fed to\nlanguage models for further processing. However, efficiently serving LMMs\nremains highly challenging due to the inherent complexity of their inference\npipelines. Traditional serving engines co-locate the encoding module and the\nlanguage model, leading to significant resource interference and tight data\ndependency. Recent studies have alleviated this issue by disaggregating the\nencoding module from the model, following a design style of prefill-decode\ndisaggregation. Nevertheless, these approaches fail to fully exploit\nparallelism both within individual requests (intra-request) and across multiple\nrequests (inter-request).\n  To overcome the limitation, we propose REDServe, an LMM inference system that\nefficiently orchestrates intra- and inter-request pipelines. REDServe is\ndesigned to reduce low latency and maximize parallelism at both intra- and\ninter-request granularities. Built on the disaggregated architecture of the\nencoding module and language model, REDServe adopts a fine-grained scheduling\nmethod that overlaps multimodal encoding with the forward computation of the\nlanguage model within a single request. For inter-request pipeline, REDServe\nleverages schedulable tokens and token budgets to balance computational loads\nacross micro-batches. Combined with chunked prefill, this enables a novel\nscheduling strategy that coordinates the execution of intra- and inter-request\npipelines. Experimental evaluations on representative LMMs show that REDServe\nachieves substantial latency reduction of up to 66% while improving throughput\nby up to 109%, significantly outperforming existing serving approaches."}
{"id": "2509.24626", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.24626", "abs": "https://arxiv.org/abs/2509.24626", "authors": ["Qihui Zhou", "Peiqi Yin", "Pengfei Zuo", "James Cheng"], "title": "SparseServe: Unlocking Parallelism for Dynamic Sparse Attention in Long-Context LLM Serving", "comment": "14 pages, 16 figures", "summary": "Serving long-context LLMs is costly because attention computation grows\nlinearly with context length. Dynamic sparse attention algorithms (DSAs)\nmitigate this by attending only to the key-value (KV) cache of critical tokens.\nHowever, with DSAs, the main performance bottleneck shifts from HBM bandwidth\nto HBM capacity: KV caches for unselected tokens must remain in HBM for\nlow-latency decoding, constraining parallel batch size and stalling further\nthroughput gains. Offloading these underutilized KV caches to DRAM could free\nHBM capacity, allowing larger parallel batch sizes. Yet, achieving such\nhierarchical HBM-DRAM storage raises new challenges, including fragmented KV\ncache access, HBM cache contention, and high HBM demands of hybrid batching,\nthat remain unresolved in prior work.\n  This paper proposes SparseServe, an LLM serving system that unlocks the\nparallel potential of DSAs through efficient hierarchical HBM-DRAM management.\nSparseServe introduces three key innovations to address the challenges\nmentioned above: (1) fragmentation-aware KV cache transfer, which accelerates\nHBM-DRAM data movement through GPU-direct loading (FlashH2D) and CPU-assisted\nsaving (FlashD2H); (2) working-set-aware batch size control that adjusts batch\nsizes based on real-time working set estimation to minimize HBM cache\nthrashing; (3) layer-segmented prefill that bounds HBM use during prefill to a\nsingle layer, enabling efficient execution even for long prompts. Extensive\nexperimental results demonstrate that SparseServe achieves up to 9.26x lower\nmean time-to-first-token (TTFT) latency and up to 3.14x higher token generation\nthroughput compared to state-of-the-art LLM serving systems."}
{"id": "2509.24859", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.24859", "abs": "https://arxiv.org/abs/2509.24859", "authors": ["Antian Liang", "Zhigang Zhao", "Kai Zhang", "Xuri Shi", "Chuantao Li", "Chunxiao Wang", "Zhenying He", "Yinan Jing", "X. Sean Wang"], "title": "HAPT: Heterogeneity-Aware Automated Parallel Training on Heterogeneous Clusters", "comment": null, "summary": "With the rapid evolution of GPU architectures, the heterogeneity of model\ntraining infrastructures is steadily increasing. In such environments,\neffectively utilizing all available heterogeneous accelerators becomes critical\nfor distributed model training. However, existing frameworks, which are\nprimarily designed for homogeneous clusters, often exhibit significant resource\nunderutilization when deployed on heterogeneous accelerators and networks. In\nthis paper, we present Hapt, an automated parallel training framework designed\nspecifically for heterogeneous clusters. Hapt introduces a fine-grained planner\nthat efficiently searches a wide space for the inter-operator parallel\nstrategy, enabling Hapt to alleviate communication overheads while maintaining\nbalanced loads across heterogeneous accelerators. In addition, Hapt implements\na heterogeneity-aware 1F1B scheduler that adaptively adjusts the execution\ntiming and ordering of microbatches based on network characteristics,\nmaximizing computation-communication overlap under cross-cluster interconnects\nwhile incurring only minimal memory overhead. Our evaluation results show that\nHapt can deliver 1.3x-1.6x higher performance on heterogeneous clusters than\nstate-of-the-art training frameworks."}
{"id": "2509.24932", "categories": ["cs.DC", "cs.LG", "cs.NI"], "pdf": "https://arxiv.org/pdf/2509.24932", "abs": "https://arxiv.org/abs/2509.24932", "authors": ["Fardis Nadimi", "Payam Abdisarabshali", "Jacob Chakareski", "Nicholas Mastronarde", "Seyyedali Hosseinalipour"], "title": "Graph Theory Meets Federated Learning over Satellite Constellations: Spanning Aggregations, Network Formation, and Performance Optimization", "comment": "8 Figures, 6 Appendix", "summary": "We introduce Fed-Span, a novel federated/distributed learning framework\ndesigned for low Earth orbit satellite constellations. By leveraging\ngraph-theoretic principles, Fed-Span addresses critical challenges inherent to\ndistributed learning in dynamic satellite networks, including intermittent\nsatellite connectivity, heterogeneous computational capabilities of satellites,\nand time-varying satellites' datasets. At its core, Fed-Span builds upon\nminimum spanning tree (MST) and minimum spanning forest (MSF) topologies,\nenabling spanning model aggregation and dispatching processes for distributed\nlearning. To formalize Fed-Span, we offer a fresh perspective on MST/MSF\ntopologies by formulating them through a set of continuous constraint\nrepresentations (CCRs), thereby devising graph-theoretical abstractions into an\noptimizable framework for satellite networks. Using these CCRs, we obtain the\nenergy consumption and latency of operations in Fed-Span. Moreover, we derive\nnovel convergence bounds for non-convex machine learning loss functions,\naccommodating the key system characteristics and degrees of freedom of\nFed-Span. Finally, we propose a comprehensive optimization problem that jointly\nminimizes model prediction loss, energy consumption, and latency of Fed-Span.\nWe unveil that this problem is NP-hard and develop a systematic approach to\ntransform it into a geometric programming formulation, solved via successive\nconvex optimization with performance guarantees. Through evaluations on\nreal-world datasets, we demonstrate that Fed-Span outperforms existing methods,\nwith faster model convergence, greater energy efficiency, and reduced latency.\nThese results highlight Fed-Span as a novel solution for efficient distributed\nlearning in satellite networks."}
{"id": "2509.25041", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.25041", "abs": "https://arxiv.org/abs/2509.25041", "authors": ["Yu Han", "Lehan Pan", "Jie Peng", "Ziyang Tao", "Wuyang Zhang", "Yanyong Zhang"], "title": "GRACE-MoE: Grouping and Replication with Locality-Aware Routing for Efficient Distributed MoE Inference", "comment": null, "summary": "Sparse Mixture of Experts (SMoE) performs conditional computation by\nselectively activating a subset of experts, thereby enabling scalable parameter\ngrowth in large language models (LLMs). However, the expanded parameter scale\nexceeds the memory capacity of a single device, necessitating distributed\ndeployment for inference. This setup introduces two critical challenges: (1)\nCommunication Issue: Transferring features to devices with activated experts\nleads to significant communication overhead. (2) Computational Load Issue:\nSkewed expert activation overloads certain GPUs, resulting in load imbalance\nacross devices. Among these, communication overhead is identified as the main\nbottleneck in SMoE inference. Nevertheless, reducing communication between\ndevices may exacerbate computational load imbalance, leading to device idleness\nand resource waste. Therefore, we present GRACE-MoE, short for Grouping and\nReplication with Locality-Aware Routing for SMoE inference. GRACE-MoE is a\nco-optimization framework that jointly reduces communication overhead and\nalleviates computational load imbalance. Specifically, the framework comprises\ntwo key phases: (1) Grouping & Replication: This phase groups experts based on\ntheir affinity to reduce cross-device communication. Additionally, dynamic\nreplication is applied to address load skew, improving computational load\nbalance across GPUs. (2) Routing: This phase employs a locality-aware routing\nstrategy with load prediction. It prioritizes local replicas to minimize\ncommunication overhead and balances requests across remote replicas when\nnecessary. Experiments on diverse models and multi-node, multi-GPU environments\ndemonstrate that GRACE-MoE efficiently reduces end-to-end inference latency,\nachieving up to 3.79x speedup over state-of-the-art systems. Code for GRACE-MoE\nwill be released upon acceptance."}
{"id": "2509.25121", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.25121", "abs": "https://arxiv.org/abs/2509.25121", "authors": ["Anvitha Ramachandran", "Dhruv Parikh", "Viktor Prasanna"], "title": "Accelerating Dynamic Image Graph Construction on FPGA for Vision GNNs", "comment": "IEEE HPEC 2025", "summary": "Vision Graph Neural Networks (Vision GNNs, or ViGs) represent images as\nunstructured graphs, achieving state of the art performance in computer vision\ntasks such as image classification, object detection, and instance\nsegmentation. Dynamic Image Graph Construction (DIGC) builds image graphs by\nconnecting patches (nodes) based on feature similarity, and is dynamically\nrepeated in each ViG layer following GNN based patch (node) feature updates.\nHowever, DIGC constitutes over 50% of end to end ViG inference latency, rising\nto 95% at high image resolutions, making it the dominant computational\nbottleneck. While hardware acceleration holds promise, prior works primarily\noptimize graph construction algorithmically, often compromising DIGC\nflexibility, accuracy, or generality. To address these limitations, we propose\na streaming, deeply pipelined FPGA accelerator for DIGC, featuring on chip\nbuffers that process input features in small, uniform blocks. Our design\nminimizes external memory traffic via localized computation and performs\nefficient parallel sorting with local merge sort and global k way merging\ndirectly on streaming input blocks via heap insertion. This modular\narchitecture scales seamlessly across image resolutions, ViG layer types, and\nmodel sizes and variants, and supports DIGC across diverse ViG based vision\nbackbones. The design achieves high clock frequencies post place and route due\nto the statically configured parallelism minimizing critical path delay and\ndelivers up to 16.6x and 6.8x speedups over optimized CPU and GPU DIGC\nbaselines."}
{"id": "2509.25155", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25155", "abs": "https://arxiv.org/abs/2509.25155", "authors": ["Neelesh Gupta", "Rakshith Jayanth", "Dhruv Parikh", "Viktor Prasanna"], "title": "Context-Driven Performance Modeling for Causal Inference Operators on Neural Processing Units", "comment": "IEEE HiPC 2025", "summary": "The proliferation of large language models (LLMs) has driven demand for long\ncontext inference on resource constrained edge devices. However, deploying\nthese models on Neural Processing Units (NPUs) presents significant challenges\ndue to the architectural mismatch: quadratic complexity of standard attention\nmechanisms conflicts with memory and compute patterns of edge accelerators.\nThis paper presents a comprehensive performance analysis of various causal\ninference operators on a modern NPU. We benchmark standard quadratic attention\nagainst several sub-quadratic alternatives, including structured state-space\nand linear attention models. Our analysis reveals that while sub-quadratic\nmethods offer superior scalability, they introduce distinct computational\nbottlenecks on the NPU's specialized execution units. We identify that\nquadratic attention becomes severely memory-bound, suffering from cache\ninefficiency and pipeline stalls exceeding 95% at long contexts. In contrast,\nsub-quadratic models can become compute-bound on programmable vector cores.\nThese findings provide critical insights for the co-design of hardware-aware\nmodels and optimization strategies to enable on-device AI inference with\nlong-contexts."}
