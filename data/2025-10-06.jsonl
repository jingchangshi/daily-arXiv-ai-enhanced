{"id": "2510.02613", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.02613", "abs": "https://arxiv.org/abs/2510.02613", "authors": ["Gursimran Singh", "Timothy Yu", "Haley Li", "Cheng Chen", "Hanieh Sadri", "Qintao Zhang", "Yu Zhang", "Ying Xiong", "Yong Zhang", "Zhenan Fan"], "title": "ElasticMoE: An Efficient Auto Scaling Method for Mixture-of-Experts Models", "comment": "19 pages, 15 figures, Under Submission", "summary": "Mixture-of-Experts (MoE) models promise efficient scaling of large language\nmodels (LLMs) by activating only a small subset of experts per token, but their\nparallelized inference pipelines make elastic serving challenging. Existing\nstrategies fall short: horizontal scaling provisions entire replicas of the\ncurrent configuration, often tens to hundreds of accelerators, leading to\ncoarse granularity, long provisioning delays, and costly overprovisioning.\nVertical scaling offers finer adjustments but typically requires instance\nrestarts, incurring downtime. These limitations make current approaches\nill-suited for the bursty, short-lived traffic patterns common in cloud\ndeployments.\n  We present ElasticMoE, an elastic scaling framework for MoE LLMs that\nachieves fine-grained, low-latency, and zero-downtime scaling. ElasticMoE\ndecouples inference execution from memory operations, enabling scaling steps to\nproceed concurrently with serving. An HBM Management Module (HMM) reuses\nweights and KV caches via zero-copy remapping, while high-bandwidth\npeer-to-peer transfers bring newly added accelerators online without\ninterrupting service. A virtual memory based expert redistribution mechanism\nmigrates MoE experts without costly buffer reallocations, reducing peak memory\nusage during expert parallelism reconfiguration.\n  Our evaluation on Ascend NPUs with three popular MoE LLMs shows that\nElasticMoE achieves up to 9x lower scale-up latency, up to 2x better throughput\nduring scaling, and significantly improves SLO attainment compared to\nbaselines. By enabling fine-grained, concurrent scaling with minimal\ndisruption, ElasticMoE advances the practicality of deploying massive MoE LLMs\nin dynamic cloud environments."}
{"id": "2510.02774", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.02774", "abs": "https://arxiv.org/abs/2510.02774", "authors": ["Xiang Li", "Qiong Chang", "Yun Li", "Jun Miyazaki"], "title": "GRNND: A GPU-Parallel Relative NN-Descent Algorithm for Efficient Approximate Nearest Neighbor Graph Construction", "comment": null, "summary": "Relative Nearest Neighbor Descent (RNN-Descent) is a state-of-the-art\nalgorithm for constructing sparse approximate nearest neighbor (ANN) graphs by\ncombining the iterative refinement of NN-Descent with the edge-pruning rules of\nthe Relative Neighborhood Graph (RNG). It has demonstrated strong effectiveness\nin large-scale search tasks such as information retrieval and related tasks.\nHowever, as the amount and dimensionality of data increase, the complexity of\ngraph construction in RNN-Descent rises sharply, making this stage increasingly\ntime-consuming and even prohibitive for subsequent query processing. In this\npaper, we propose GRNND, the first GPU-parallel algorithm of RNN-Descent\ndesigned to fully exploit GPU architecture. GRNND introduces a disordered\nneighbor propagation strategy to mitigate synchronized update traps, enhancing\nstructural diversity, and avoiding premature convergence during parallel\nexecution. It also leverages warp-level cooperative operations and a\ndouble-buffered neighbor pool with fixed capacity for efficient memory access,\neliminate contention, and enable highly parallelized neighbor updates.\nExtensive experiments demonstrate that GRNND consistently outperforms existing\nCPU- and GPU-based methods. GRNND achieves 2.4 to 51.7x speedup over existing\nGPU methods, and 17.8 to 49.8x speedup over CPU methods."}
{"id": "2510.02838", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.02838", "abs": "https://arxiv.org/abs/2510.02838", "authors": ["Yifei Xia", "Fangcheng Fu", "Hao Yuan", "Hanke Zhang", "Xupeng Miao", "Yijun Liu", "Suhan Ling", "Jie Jiang", "Bin Cui"], "title": "TridentServe: A Stage-level Serving System for Diffusion Pipelines", "comment": null, "summary": "Diffusion pipelines, renowned for their powerful visual generation\ncapabilities, have seen widespread adoption in generative vision tasks (e.g.,\ntext-to-image/video). These pipelines typically follow an\nencode--diffuse--decode three-stage architecture. Current serving systems\ndeploy diffusion pipelines within a static, manual, and pipeline-level\nparadigm, allocating the same resources to every request and stage. However,\nthrough an in-depth analysis, we find that such a paradigm is inefficient due\nto the discrepancy in resource needs across the three stages of each request,\nas well as across different requests. Following the analysis, we propose the\ndynamic stage-level serving paradigm and develop TridentServe, a brand new\ndiffusion serving system. TridentServe automatically, dynamically derives the\nplacement plan (i.e., how each stage resides) for pipeline deployment and the\ndispatch plan (i.e., how the requests are routed) for request processing,\nco-optimizing the resource allocation for both model and requests. Extensive\nexperiments show that TridentServe consistently improves SLO attainment and\nreduces average/P95 latencies by up to 2.5x and 3.6x/4.1x over existing works\nacross a variety of workloads."}
{"id": "2510.02878", "categories": ["cs.DC", "cs.MS", "cs.PF"], "pdf": "https://arxiv.org/pdf/2510.02878", "abs": "https://arxiv.org/abs/2510.02878", "authors": ["Massimo Bernaschi", "Alessandro Celestini", "Pasqua D'Ambra", "Giorgio Richelli"], "title": "On the energy efficiency of sparse matrix computations on multi-GPU clusters", "comment": null, "summary": "We investigate the energy efficiency of a library designed for parallel\ncomputations with sparse matrices. The library leverages high-performance,\nenergy-efficient Graphics Processing Unit (GPU) accelerators to enable\nlarge-scale scientific applications. Our primary development objective was to\nmaximize parallel performance and scalability in solving sparse linear systems\nwhose dimensions far exceed the memory capacity of a single node. To this end,\nwe devised methods that expose a high degree of parallelism while optimizing\nalgorithmic implementations for efficient multi-GPU usage. Previous work has\nalready demonstrated the library's performance efficiency on large-scale\nsystems comprising thousands of NVIDIA GPUs, achieving improvements over\nstate-of-the-art solutions. In this paper, we extend those results by providing\nenergy profiles that address the growing sustainability requirements of modern\nHPC platforms. We present our methodology and tools for accurate runtime energy\nmeasurements of the library's core components and discuss the findings. Our\nresults confirm that optimizing GPU computations and minimizing data movement\nacross memory and computing nodes reduces both time-to-solution and energy\nconsumption. Moreover, we show that the library delivers substantial advantages\nover comparable software frameworks on standard benchmarks."}
{"id": "2510.02579", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.02579", "abs": "https://arxiv.org/abs/2510.02579", "authors": ["Santiago Cuéllar", "Naomi Spargo", "Jonathan Daugherty", "David Darais"], "title": "Designing Walrus: Relational Programming with Rich Types, On-Demand Laziness, and Structured Traces", "comment": "20 pages, miniKanren 2025", "summary": "We present Walrus, a functional relational programming language embedded in\nHaskell that extends the miniKanren model with type-polymorphic unification,\non-demand laziness, and a range of usability features aimed at practical\ndevelopment. These include use of Haskell Generics for boilerplate reduction,\nstructured debugging traces, and ergonomic support for product types. We\ndescribe the design and implementation of Walrus through the lens of our\nexperience developing bidirectional compilers, and reflect on key design\ndecisions and recurring usability challenges encountered in practice."}
{"id": "2510.02675", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.02675", "abs": "https://arxiv.org/abs/2510.02675", "authors": ["Shubham Negi", "Kaushik Roy"], "title": "HALO: Memory-Centric Heterogeneous Accelerator with 2.5D Integration for Low-Batch LLM Inference", "comment": null, "summary": "The rapid adoption of Large Language Models (LLMs) has driven a growing\ndemand for efficient inference, particularly in latency-sensitive applications\nsuch as chatbots and personalized assistants. Unlike traditional deep neural\nnetworks, LLM inference proceeds in two distinct phases: the prefill phase,\nwhich processes the full input sequence in parallel, and the decode phase,\nwhich generates tokens sequentially. These phases exhibit highly diverse\ncompute and memory requirements, which makes accelerator design particularly\nchallenging. Prior works have primarily been optimized for high-batch inference\nor evaluated only short input context lengths, leaving the low-batch and long\ncontext regime, which is critical for interactive applications, largely\nunderexplored.\n  We propose HALO, a heterogeneous memory centric accelerator designed for\nthese unique challenges of prefill and decode phases in low-batch LLM\ninference. HALO integrates HBM based Compute-in-DRAM (CiD) with an on-chip\nanalog Compute-in-Memory (CiM), co-packaged using 2.5D integration. To further\nimprove the hardware utilization, we introduce a phase-aware mapping strategy\nthat adapts to the distinct demands of the prefill and decode phases. Compute\nbound operations in the prefill phase are mapped to CiM to exploit its high\nthroughput matrix multiplication capability, while memory-bound operations in\nthe decode phase are executed on CiD to benefit from reduced data movement\nwithin DRAM. Additionally, we present an analysis of the performance tradeoffs\nof LLMs under two architectural extremes: a fully CiD and a fully on-chip\nanalog CiM design to highlight the need for a heterogeneous design. We evaluate\nHALO on LLaMA-2 7B and Qwen3 8B models. Our experimental results show that LLMs\nmapped to HALO achieve up to 18x geometric mean speedup over AttAcc, an\nattention-optimized mapping and 2.5x over CENT, a fully CiD based mapping."}
{"id": "2510.02882", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.02882", "abs": "https://arxiv.org/abs/2510.02882", "authors": ["Adhitya Bhawiyuga", "Serkan Girgin", "Rolf A. de By", "Raul Zurita-Milla"], "title": "Energy Efficiency in Cloud-Based Big Data Processing for Earth Observation: Gap Analysis and Future Directions", "comment": null, "summary": "Earth observation (EO) data volumes are rapidly increasing. While cloud\ncomputing are now used for processing large EO datasets, the energy efficiency\naspects of such a processing have received much less attention. This issue is\nnotable given the increasing awareness of energy costs and carbon footprint in\nbig data processing, particularly with increased attention on compute-intensive\nfoundation models. In this paper we identify gaps in energy efficiency\npractices within cloud-based EO big data (EOBD) processing and propose several\nresearch directions for improvement. We first examine the current EOBD\nlandscape, focus on the requirements that necessitate cloud-based processing\nand analyze existing cloud-based EOBD solutions. We then investigate energy\nefficiency strategies that have been successfully employed in well-studied big\ndata domains. Through this analysis, we identify several critical gaps in\nexisting EOBD processing platforms, which primarily focus on data accessibility\nand computational feasibility, instead of energy efficiency. These gaps include\ninsufficient energy monitoring mechanisms, lack of energy awareness in data\nmanagement, inadequate implementation of energy-aware resource allocation and\nlack of energy efficiency criteria on task scheduling. Based on these findings,\nwe propose the development of energy-aware performance monitoring and\nbenchmarking frameworks, the use of optimization techniques for infrastructure\norchestration, and of energy-efficient task scheduling approaches for\ndistributed cloud-based EOBD processing frameworks. These proposed approaches\naim to foster more energy awareness in EOBD processing , potentially reducing\npower consumption and environmental impact while maintaining or minimally\nimpacting processing performance."}
{"id": "2510.03170", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.03170", "abs": "https://arxiv.org/abs/2510.03170", "authors": ["Rafaello Sanna", "William E. Byrd", "Nada Amin"], "title": "Beyond Cons: Purely Relational Data Structures", "comment": "17 pages, 6 figures, Source code available at\n  https://www.github.com/rvs314/faster-clpset-minikanren . To be published in\n  the 7th Workshop on miniKanren and Relational Programming (miniKanren'25)", "summary": "We present {Kanren} (read: set-Kanren), an extension to miniKanren with\nconstraints for reasoning about sets and association lists. {Kanren} includes\nfirst-class set objects, a functionally complete family of set-theoretic\nconstraints (including membership, union, and disjointedness), and new\nconstraints for reasoning about association lists with shadowing and scoped\nlookup. These additions allow programmers to describe collections declaratively\nand lazily, without relying on structural encodings and eager search over\nrepresentation spaces. The result is improved expressiveness and operational\nbehavior in programs that manipulate abstract data -- particularly interpreters\n-- by supporting set equality based on contents, enabling finite failure. We\ndescribe the design and implementation of {Kanren} in a constraint-enabled\nminiKanren system and illustrate its use in representative examples."}
{"id": "2510.02863", "categories": ["cs.AR", "cs.DS", "cs.NA", "math.NA", "quant-ph", "G.1.3; J.2; B.6.1"], "pdf": "https://arxiv.org/pdf/2510.02863", "abs": "https://arxiv.org/abs/2510.02863", "authors": ["D. A. Herrera-Martí", "E. Guthmuller", "J. Fereyre"], "title": "A Hardware Accelerator for the Goemans-Williamson Algorithm", "comment": "Impact of Extended Precision Arithmetic in Interior Point Methods\n  using Conjugate Gradient. 10 pages. Hardware estimates", "summary": "The combinatorial problem Max-Cut has become a benchmark in the evaluation of\nlocal search heuristics for both quantum and classical optimisers. In contrast\nto local search, which only provides average-case performance guarantees, the\nconvex semidefinite relaxation of Max-Cut by Goemans and Williamson, provides\nworst-case guarantees and is therefore suited to both the construction of\nbenchmarks and in applications to performance-critic scenarios.\n  We show how extended floating point precision can be incorporated in\nalgebraic subroutines in convex optimisation, namely in indirect matrix\ninversion methods like Conjugate Gradient, which are used in Interior Point\nMethods in the case of very large problem sizes. Also, an estimate is provided\nof the expected acceleration of the time to solution for a hardware\narchitecture that runs natively on extended precision. Specifically, when using\nindirect matrix inversion methods like Conjugate Gradient, which have lower\ncomplexity than direct methods and are therefore used in very large problems,\nwe see that increasing the internal working precision reduces the time to\nsolution by a factor that increases with the system size."}
{"id": "2510.02894", "categories": ["cs.DC", "cs.CV"], "pdf": "https://arxiv.org/pdf/2510.02894", "abs": "https://arxiv.org/abs/2510.02894", "authors": ["Jakub Lisowski", "Piotr Tyrakowski", "Szymon Zyguła", "Krzysztof Kaczmarski"], "title": "PyRadiomics-cuda: a GPU-accelerated 3D features extraction from medical images within PyRadiomics", "comment": null, "summary": "PyRadiomics-cuda is a GPU-accelerated extension of the PyRadiomics library,\ndesigned to address the computational challenges of extracting\nthree-dimensional shape features from medical images. By offloading key\ngeometric computations to GPU hardware it dramatically reduces processing times\nfor large volumetric datasets. The system maintains full compatibility with the\noriginal PyRadiomics API, enabling seamless integration into existing AI\nworkflows without code modifications. This transparent acceleration facilitates\nefficient, scalable radiomics analysis, supporting rapid feature extraction\nessential for high-throughput AI pipeline. Tests performed on a typical\ncomputational cluster, budget and home devices prove usefulness in all\nscenarios. PyRadiomics-cuda is implemented in Python and C/CUDA and is freely\navailable under the BSD license at https://github.com/mis-wut/pyradiomics-CUDA\nAdditionally PyRadiomics-cuda test suite is available at\nhttps://github.com/mis-wut/pyradiomics-cuda-data-gen. It provides detailed\nhandbook and sample scripts suited for different kinds of workflows plus\ndetailed installation instructions. The dataset used for testing is available\nat Kaggle\nhttps://www.kaggle.com/datasets/sabahesaraki/kidney-tumor-segmentation-challengekits-19"}
{"id": "2510.02990", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2510.02990", "abs": "https://arxiv.org/abs/2510.02990", "authors": ["Philippe Magalhães", "Virginie Fresse", "Benoît Suffran", "Olivier Alata"], "title": "A Resource-Driven Approach for Implementing CNNs on FPGAs Using Adaptive IPs", "comment": "HiPEAC Workshop on Reconfigurable Computing (WRC), Jan 2025,\n  Barcelona, Spain", "summary": "The increasing demand for real-time, low-latency artificial intelligence\napplications has propelled the use of Field-Programmable Gate Arrays (FPGAs)\nfor Convolutional Neural Network (CNN) implementations. FPGAs offer\nreconfigurability, energy efficiency, and performance advantages over GPUs,\nmaking them suitable for edge devices and embedded systems. This work presents\na novel library of resource-efficient convolution IPs designed to automatically\nadapt to the available FPGA resources. Developed in VHDL, these IPs are\nparameterizable and utilize fixed-point arithmetic for optimal performance.\nFour IPs are introduced, each tailored to specific resource constraints,\noffering flexibility in DSP usage, logic consumption, and precision.\nExperimental results on a Zynq UltraScale+ FPGA highlight the trade-offs\nbetween performance and resource usage. The comparison with recent FPGA-based\nCNN acceleration techniques emphasizes the versatility and independence of this\napproach from specific FPGA architectures or technological advancements. Future\nwork will expand the library to include pooling and activation functions,\nenabling broader applicability and integration into CNN frameworks."}
{"id": "2510.02930", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2510.02930", "abs": "https://arxiv.org/abs/2510.02930", "authors": ["Wen Guan", "Tadashi Maeno", "Aleksandr Alekseev", "Fernando Harald Barreiro Megino", "Kaushik De", "Edward Karavakis", "Alexei Klimentov", "Tatiana Korchuganova", "FaHui Lin", "Paul Nilsson", "Torre Wenaus", "Zhaoyu Yang", "Xin Zhao"], "title": "iDDS: Intelligent Distributed Dispatch and Scheduling for Workflow Orchestration", "comment": null, "summary": "The intelligent Distributed Dispatch and Scheduling (iDDS) service is a\nversatile workflow orchestration system designed for large-scale, distributed\nscientific computing. iDDS extends traditional workload and data management by\nintegrating data-aware execution, conditional logic, and programmable\nworkflows, enabling automation of complex and dynamic processing pipelines.\nOriginally developed for the ATLAS experiment at the Large Hadron Collider,\niDDS has evolved into an experiment-agnostic platform that supports both\ntemplate-driven workflows and a Function-as-a-Task model for Python-based\norchestration.\n  This paper presents the architecture and core components of iDDS,\nhighlighting its scalability, modular message-driven design, and integration\nwith systems such as PanDA and Rucio. We demonstrate its versatility through\nreal-world use cases: fine-grained tape resource optimization for ATLAS,\norchestration of large Directed Acyclic Graph (DAG) workflows for the Rubin\nObservatory, distributed hyperparameter optimization for machine learning\napplications, active learning for physics analyses, and AI-assisted detector\ndesign at the Electron-Ion Collider.\n  By unifying workload scheduling, data movement, and adaptive decision-making,\niDDS reduces operational overhead and enables reproducible, high-throughput\nworkflows across heterogeneous infrastructures. We conclude with current\nchallenges and future directions, including interactive, cloud-native, and\nserverless workflow support."}
