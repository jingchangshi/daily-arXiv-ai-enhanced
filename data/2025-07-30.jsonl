{"id": "2507.21317", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.21317", "abs": "https://arxiv.org/abs/2507.21317", "authors": ["Paulette Koronkevich", "William J. Bowman"], "title": "One Weird Trick to Untie Landin's Knot", "comment": null, "summary": "In this work, we explore Landin's Knot, which is understood as a pattern for\nencoding general recursion, including non-termination, that is possible after\nadding higher-order references to an otherwise terminating language. We observe\nthat this isn't always true -- higher-order references, by themselves, don't\nlead to non-termination. The key insight is that Landin's Knot relies not\nprimarily on references storing functions, but on unrestricted quantification\nover a function's environment. We show this through a closure converted\nlanguage, in which the function's environment is made explicit and hides the\ntype of the environment through impredicative quantification. Once references\nare added, this impredicative quantification can be exploited to encode\nrecursion. We conjecture that by restricting the quantification over the\nenvironment, higher-order references can be safely added to terminating\nlanguages, without resorting to more complex type systems such as linearity,\nand without restricting references from storing functions."}
{"id": "2507.21439", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.21439", "abs": "https://arxiv.org/abs/2507.21439", "authors": ["Yong Qi Foo", "Brian Sze-Kai Cheong", "Michael D. Adams"], "title": "Fixed-Point-Oriented Programming: A Concise and Elegant Paradigm", "comment": null, "summary": "Fixed-Point-Oriented Programming (FPOP) is an emerging paradigm designed to\nstreamline the implementation of problems involving self-referential\ncomputations. These include graph algorithms, static analysis, parsing, and\ndistributed computing-domains that traditionally require complex and\ntricky-to-implement work-queue algorithms. Existing programming paradigms lack\ndirect support for these inherently fixed-point computations, leading to\ninefficient and error-prone implementations.\n  This white paper explores the potential of the FPOP paradigm, which offers a\nhigh-level abstraction that enables concise and expressive problem\nformulations. By leveraging structured inference rules and user-directed\noptimizations, FPOP allows developers to write declarative specifications while\nthe compiler ensures efficient execution. It not only reduces implementation\ncomplexity for programmers but also enhances adaptability, making it easier for\nprogrammers to explore alternative solutions and optimizations without\nmodifying the core logic of their program.\n  We demonstrate how FPOP simplifies algorithm implementation, improves\nmaintainability, and enables rapid prototyping by allowing problems to be\nclearly and concisely expressed. For example, the graph distance problem can be\nexpressed in only two executable lines of code with FPOP, while it takes an\norder of magnitude more code in other paradigms. By bridging the gap between\ntheoretical fixed-point formulations and practical implementations, we aim to\nfoster further research and adoption of this paradigm."}
{"id": "2507.22048", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22048", "abs": "https://arxiv.org/abs/2507.22048", "authors": ["Di Wang"], "title": "Composable Effect Handling for Programming LLM-integrated Scripts", "comment": null, "summary": "Implementing LLM-integrated scripts introduces challenges in modularity and\nperformance, as scripts are often coupled to specific LLM implementations and\nfail to exploit parallelization opportunities. This paper proposes using\ncomposable effect handling to separate workflow logic from effectful\noperations, such as LLM calls, I/O, and concurrency, enabling modularity\nwithout sacrificing the opportunity for performance optimization. By treating\nthese operations as abstract interfaces and discharging them via effect\nhandlers, this paper shows that scripts can achieve significant speedups (e.g.,\n10$\\times$ in a Tree-of-Thoughts case study) without compromising modularity.\nThis paper aims to promote composable effect handling as a programming style\nfor LLM scripting."}
{"id": "2507.21253", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.21253", "abs": "https://arxiv.org/abs/2507.21253", "authors": ["Abdullah Al Raqibul Islam", "Helen Xu", "Dong Dai", "Aydın Buluç"], "title": "Improving SpGEMM Performance Through Matrix Reordering and Cluster-wise Computation", "comment": "Accepted to appear in the International Conference for High\n  Performance Computing, Networking, Storage, and Analysis (SC) 2025", "summary": "Sparse matrix-sparse matrix multiplication (SpGEMM) is a key kernel in many\nscientific applications and graph workloads. Unfortunately, SpGEMM is\nbottlenecked by data movement due to its irregular memory access patterns.\nSignificant work has been devoted to developing row reordering schemes towards\nimproving locality in sparse operations, but prior studies mostly focus on the\ncase of sparse-matrix vector multiplication (SpMV).\n  In this paper, we address these issues with hierarchical clustering for\nSpGEMM that leverages both row reordering and cluster-wise computation to\nimprove reuse in the second input (B) matrix with a novel row-clustered matrix\nformat and access pattern in the first input (A) matrix. We find that\nhierarchical clustering can speed up SpGEMM by 1.39x on average with low\npreprocessing cost (less than 20x the cost of a single SpGEMM on about 90% of\ninputs). Furthermore, we decouple the reordering algorithm from the clustered\nmatrix format so they can be applied as independent optimizations.\n  Additionally, this paper sheds light on the role of both row reordering and\nclustering independently and together for SpGEMM with a comprehensive empirical\nstudy of the effect of 10 different reordering algorithms and 3 clustering\nschemes on SpGEMM performance on a suite of 110 matrices. We find that\nreordering based on graph partitioning provides better SpGEMM performance than\nexisting alternatives at the cost of high preprocessing time. The evaluation\ndemonstrates that the proposed hierarchical clustering method achieves greater\naverage speedup compared to other reordering schemes with similar preprocessing\ntimes."}
{"id": "2507.21464", "categories": ["cs.DC", "H.3.4; D.2.6"], "pdf": "https://arxiv.org/pdf/2507.21464", "abs": "https://arxiv.org/abs/2507.21464", "authors": ["Marco Mambelli", "Bruno Moreira Coimbra", "Namratha Urs", "Ilya Baburashvili"], "title": "Using Containers to Speed Up Development, to Run Integration Tests and to Teach About Distributed Systems", "comment": "8 pages, 3 figures, for associated code, see [this https\n  URL](https://github.com/glideinWMS/containers), to be published in\n  proceedings of 27th International Conference on Computing in High Energy and\n  Nuclear Physics (CHEP 2024). 21-25 October 2024. Krakow,; Poland.\n  (C24-10-21.8)", "summary": "GlideinWMS is a workload manager provisioning resources for many experiments,\nincluding CMS and DUNE. The software is distributed both as native packages and\nspecialized production containers. Following an approach used in other\ncommunities like web development, we built our workspaces, system-like\ncontainers to ease development and testing. Developers can change the source\ntree or check out a different branch and quickly reconfigure the services to\nsee the effect of their changes. In this paper, we will talk about what\ndifferentiates workspaces from other containers. We will describe our base\nsystem, composed of three containers: a one-node cluster including a compute\nelement and a batch system, a GlideinWMS Factory controlling pilot jobs, and a\nscheduler and Frontend to submit jobs and provision resources. Additional\ncontainers can be used for optional components. This system can easily run on a\nlaptop, and we will share our evaluation of different container runtimes, with\nan eye for ease of use and performance. Finally, we will talk about our\nexperience as developers and with students. The GlideinWMS workspaces are\neasily integrated with IDEs like VS Code, simplifying debugging and allowing\ndevelopment and testing of the system even when offline. They simplified the\ntraining and onboarding of new team members and summer interns. And they were\nuseful in workshops where students could have first-hand experience with the\nmechanisms and components that, in production, run millions of jobs."}
{"id": "2507.21472", "categories": ["cs.DC", "H.3.4; K.6.2"], "pdf": "https://arxiv.org/pdf/2507.21472", "abs": "https://arxiv.org/abs/2507.21472", "authors": ["Marco Mambelli", "Shrijan Swaminathan"], "title": "GlideinBenchmark: collecting resource information to optimize provisioning", "comment": "6 pages, 3 figures, for associated code, see [this https\n  URL](https://github.com/glideinWMS/glideinbenchmark), to be published in\n  proceedings of 27th International Conference on Computing in High Energy and\n  Nuclear Physics (CHEP 2024). 21-25 October 2024. Krakow,; Poland.\n  (C24-10-21.8)", "summary": "Choosing the right resource can speed up job completion, better utilize the\navailable hardware, and visibly reduce costs, especially when renting computers\nin the cloud. This was demonstrated in earlier studies on HEPCloud. However,\nthe benchmarking of the resources proved to be a laborious and time-consuming\nprocess. This paper presents GlideinBenchmark, a new Web application leveraging\nthe pilot infrastructure of GlideinWMS to benchmark resources, and it shows how\nto use the data collected and published by GlideinBenchmark to automate the\noptimal selection of resources. An experiment can select the benchmark or the\nset of benchmarks that most closely evaluate the performance of its workflows.\nGlideinBenchmark, with the help of the GlideinWMS Factory, controls the\nbenchmark execution. Finally, a scheduler like HEPCloud's Decision Engine can\nuse the results to optimize resource provisioning."}
{"id": "2507.21492", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.21492", "abs": "https://arxiv.org/abs/2507.21492", "authors": ["Yicong Luo", "Senhe Hao", "Brian Wheatman", "Prashant Pandey", "Helen Xu"], "title": "Bridging Cache-Friendliness and Concurrency: A Locality-Optimized In-Memory B-Skiplist", "comment": "Accepted into ICPP 2025", "summary": "Skiplists are widely used for in-memory indexing in many key-value stores,\nsuch as RocksDB and LevelDB, due to their ease of implementation and simple\nconcurrency control mechanisms. However, traditional skiplists suffer from poor\ncache locality, as they store only a single element per node, leaving\nperformance on the table. Minimizing last-level cache misses is key to\nmaximizing in-memory index performance, making high cache locality essential.\nIn this paper, we present a practical concurrent B-skiplist that enhances cache\nlocality and performance while preserving the simplicity of traditional\nskiplist structures and concurrency control schemes. Our key contributions\ninclude a top-down, single-pass insertion algorithm for B-skiplists and a\ncorresponding simple and efficient top-down concurrency control scheme. On 128\nthreads, the proposed concurrent B-skiplist achieves between 2x-9x higher\nthroughput compared to state-of-the-art concurrent skiplist implementations,\nincluding Facebook's concurrent skiplist from Folly and the Java\nConcurrentSkipListMap. Furthermore, we find that the B-skiplist achieves\ncompetitive (0.9x-1.7x) throughput on point workloads compared to\nstate-of-the-art cache-optimized tree-based indices (e.g., Masstree). For a\nmore complete picture of the performance, we also measure the latency of\nskiplist and tree-based indices and find that the B-skiplist achieves between\n3.5x-103x lower 99% latency compared to other concurrent skiplists and between\n0.85x-64x lower 99% latency compared to tree-based indices on point workloads\nwith inserts."}
{"id": "2507.21685", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.21685", "abs": "https://arxiv.org/abs/2507.21685", "authors": ["Marlon Etheredge", "Thomas Fahringer", "Felix Erlacher", "Elias Kohler", "Stefan Pedratscher", "Juan Aznar-Poveda", "Nishant Saurabh", "Adrien Lebre"], "title": "Collaborative State Machines: A Better Programming Model for the Cloud-Edge-IoT Continuum", "comment": null, "summary": "The development of Cloud-Edge-IoT applications requires robust programming\nmodels. Existing models often struggle to manage the dynamic and stateful\nnature of these applications effectively. This paper introduces the\nCollaborative State Machines (CSM) programming model to address these\ncomplexities. CSM facilitates the development of reactive, event-driven, and\nstateful applications targeting the Cloud-Edge-IoT continuum. Applications\nbuilt with CSM are composed of state machines that collaborate autonomously and\ncan be distributed across different layers of the continuum. Key features of\nCSM include (i) a sophisticated collaboration mechanism among state machines\nutilizing events and persistent data; (ii) encapsulation of state through the\ninherent state of state machines and persistent data; (iii) integration of\nactions and service invocations within states and state transitions, thereby\ndecoupling complex application logic from compute and data processing services;\nand (iv) an advanced data model that supports the processing of local, static,\nand persistent data with defined scope and lifetime. In addition to introducing\nthe CSM programming model, we present a runtime system and a comprehensive\nevaluation of our approach. This evaluation is based on three use cases: a\nstress test on a large-scale infrastructure, a surveillance system application,\nand a complex smart factory scenario, all deployed on the Grid'5000 testbed.\nOur results demonstrate a 12x increase in throughput through novel language\nfeatures in the stress test. Compared to Serverless Workflow, a\nstate-of-the-art baseline system, we show a 2.3x improvement in processing time\nper processed image in a surveillance system use case, a 55x reduction in total\nprocessing time for a smart factory use case, and an overall improvement in\nproductivity across these use cases."}
{"id": "2507.21791", "categories": ["cs.DC", "cs.NA", "math.NA", "65F10, 65F25, 65G50, 65Y20"], "pdf": "https://arxiv.org/pdf/2507.21791", "abs": "https://arxiv.org/abs/2507.21791", "authors": ["Erin Carson", "Yuxin Ma"], "title": "The Performance of Low-Synchronization Variants of Reorthogonalized Block Classical Gram--Schmidt", "comment": "7 pages, 2 figures", "summary": "Numerous applications, such as Krylov subspace solvers, make extensive use of\nthe block classical Gram-Schmidt (BCGS) algorithm and its reorthogonalized\nvariants for orthogonalizing a set of vectors. For large-scale problems in\ndistributed memory settings, the communication cost, particularly the global\nsynchronization cost, is a major performance bottleneck. In recent years, many\nlow-synchronization BCGS variants have been proposed in an effort to reduce the\nnumber of synchronization points. The work [E. Carson, Y. Ma, arXiv preprint\n2411.07077] recently proposed stable one-synchronization and\ntwo-synchronization variants of BCGS, i.e., BCGSI+P-1S and BCGSI+P-2S. In this\nwork, we evaluate the performance of BCGSI+P-1S and BCGSI+P-2S on a distributed\nmemory system compared to other well-known low-synchronization BCGS variants.\nIn comparison to the classical reorthogonalized BCGS algorithm (BCGSI+),\nnumerical experiments demonstrate that BCGSI+P-1S and BCGSI+P-2S can achieve up\nto 4 times and 2 times speedups, respectively, and perform similarly to other\n(less stable) one-synchronization and two-synchronization variants. BCGSI+P-1S\nand BCGSI+P-2S are therefore recommended as the best choice in practice for\ncomputing an economic QR factorization on distributed memory systems due to\ntheir superior stability when compared to other variants with the same\nsynchronization cost."}
