{"id": "2509.20514", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.20514", "abs": "https://arxiv.org/abs/2509.20514", "authors": ["Ian McDougall", "Harish Batchu", "Michael Davies", "Karthikeyan Sankaralingam"], "title": "Pedagogically Motivated and Composable Open-Source RISC-V Processors for Computer Science Education", "comment": "8 pages, 2 figures", "summary": "While most instruction set architectures (ISAs) are only available to use\nthrough the purchase of a restrictive commercial license, the RISC-V ISA\npresents a free and open-source alternative. Due to this availability, many\nfree and open-source implementations have been developed and can be accessed on\nplatforms such as GitHub. If an open source, easy-to-use, and robust RISC-V\nimplementation could be obtained, it could be easily adapted for pedagogical\nand amateur use. In this work we accomplish three goals in relation to this\noutlook. First, we propose a set of criteria for evaluating the components of a\nRISC-V implementation's ecosystem from a pedagogical perspective. Second, we\nanalyze a number of existing open-source RISC-V implementations to determine\nhow many of the criteria they fulfill. We then develop a comprehensive solution\nthat meets all of these criterion and is released open-source for other\ninstructors to use. The framework is developed in a composable way that it's\ndifferent components can be disaggregated per individual course needs. Finally,\nwe also report on a limited study of student feedback."}
{"id": "2509.20543", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.20543", "abs": "https://arxiv.org/abs/2509.20543", "authors": ["Daniel Ruelas-Petrisko", "Farzam Gilani", "Anoop Mysore Nataraja", "Zoe Taylor", "Michael Taylor"], "title": "ZynqParrot: A Scale-Down Approach to Cycle-Accurate, FPGA-Accelerated Co-Emulation", "comment": null, "summary": "As processors increase in complexity, costs grow even more rapidly, both for\nfunctional verification and performance validation. Most often, silicon\ncharacterizations comprise simple performance counters, which are aggregated\nand separated to tell a story. Based on these inferences, performance engineers\nemploy microarchitectural simulation to inspect deeply into the core.\nUnfortunately, dramatically longer runtimes make simulation infeasible for long\nworkloads.\n  We propose a Scale-Down approach to modelling and validation. Rather than\nup-sizing a prototyping platform to fit large and complex system designs, we\nshow that it can be more accurate, faster, and more economical to decompose a\nsystem into manageable sub-components that can be prototyped independently. By\ncarefully designing the prototyping interface, it is possible to adhere to\nstrict non-interference of the Device Under Test (DUT). This allows architects\nto have the best of both worlds: the speed of FPGA acceleration while\neliminating the inaccuracies of Scale-Out and the inherent costs of Scale-Up.\n  In this work, we present ZynqParrot: a Scale-Down FPGA-based modelling\nplatform, capable of executing non-interfering, cycle-accurate co-emulations of\narbitrary RTL designs. ZynqParrot is capable of verifying functionality and\nperformance with arbitrary granularity. We also provide case studies using\nZynqParrot to analyze the full-stack performance of an open-source RISC-V\nprocessor."}
{"id": "2509.20603", "categories": ["cs.DC", "cs.AI", "cs.AR", "cs.ET", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.20603", "abs": "https://arxiv.org/abs/2509.20603", "authors": ["Angel M. Beltre", "Jeff Ogden", "Kevin Pedretti"], "title": "Experience Deploying Containerized GenAI Services at an HPC Center", "comment": "10 pages, 12 figures", "summary": "Generative Artificial Intelligence (GenAI) applications are built from\nspecialized components -- inference servers, object storage, vector and graph\ndatabases, and user interfaces -- interconnected via web-based APIs. While\nthese components are often containerized and deployed in cloud environments,\nsuch capabilities are still emerging at High-Performance Computing (HPC)\ncenters. In this paper, we share our experience deploying GenAI workloads\nwithin an established HPC center, discussing the integration of HPC and cloud\ncomputing environments. We describe our converged computing architecture that\nintegrates HPC and Kubernetes platforms running containerized GenAI workloads,\nhelping with reproducibility. A case study illustrates the deployment of the\nLlama Large Language Model (LLM) using a containerized inference server (vLLM)\nacross both Kubernetes and HPC platforms using multiple container runtimes. Our\nexperience highlights practical considerations and opportunities for the HPC\ncontainer community, guiding future research and tool development."}
{"id": "2509.21137", "categories": ["cs.DC", "cs.AR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.21137", "abs": "https://arxiv.org/abs/2509.21137", "authors": ["Huynh Q. N. Vo", "Md Tawsif Rahman Chowdhury", "Paritosh Ramanan", "Gozde Tutuncuoglu", "Junchi Yang", "Feng Qiu", "Murat Yildirim"], "title": "From GPUs to RRAMs: Distributed In-Memory Primal-Dual Hybrid Gradient Method for Solving Large-Scale Linear Optimization Problem", "comment": "Main Article (12 Pages, 3 Figures), Appendix (4 Pages)", "summary": "The exponential growth of computational workloads is surpassing the\ncapabilities of conventional architectures, which are constrained by\nfundamental limits. In-memory computing (IMC) with RRAM provides a promising\nalternative by providing analog computations with significant gains in latency\nand energy use. However, existing algorithms developed for conventional\narchitectures do not translate to IMC, particularly for constrained\noptimization problems where frequent matrix reprogramming remains\ncost-prohibitive for IMC applications. Here we present a distributed in-memory\nprimal-dual hybrid gradient (PDHG) method, specifically co-designed for arrays\nof RRAM devices. Our approach minimizes costly write cycles, incorporates\nrobustness against device non-idealities, and leverages a symmetric\nblock-matrix formulation to unify operations across distributed crossbars. We\nintegrate a physics-based simulation framework called MELISO+ to evaluate\nperformance under realistic device conditions. Benchmarking against\nGPU-accelerated solvers on large-scale linear programs demonstrates that our\nRRAM-based solver achieves comparable accuracy with up to three orders of\nmagnitude reductions in energy consumption and latency. These results\ndemonstrate the first PDHG-based LP solver implemented on RRAMs, showcasing the\ntransformative potential of algorithm-hardware co-design for solving\nlarge-scale optimization through distributed in-memory computing."}
{"id": "2509.20426", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20426", "abs": "https://arxiv.org/abs/2509.20426", "authors": ["Mahmoud Samir Fayed"], "title": "Dual-Language General-Purpose Self-Hosted Visual Language and new Textual Programming Language for Applications", "comment": "PhD thesis", "summary": "Most visual programming languages (VPLs) are domain-specific, with few\ngeneral-purpose VPLs like Programming Without Coding Technology (PWCT). These\ngeneral-purpose VPLs are developed using textual programming languages and\nimproving them requires textual programming. In this thesis, we designed and\ndeveloped PWCT2, a dual-language (Arabic/English), general-purpose,\nself-hosting visual programming language. Before doing so, we specifically\ndesigned a textual programming language called Ring for its development. Ring\nis a dynamically typed language with a lightweight implementation, offering\nsyntax customization features. It permits the creation of domain-specific\nlanguages through new features that extend object-oriented programming,\nallowing for specialized languages resembling Cascading Style Sheets (CSS) or\nSupernova language. The Ring Compiler and Virtual Machine are designed using\nthe PWCT visual programming language where the visual implementation is\ncomposed of 18,945 components that generate 24,743 lines of C code, which\nincreases the abstraction level and hides unnecessary details. Using PWCT to\ndevelop Ring allowed us to realize several issues in PWCT, which led to the\ndevelopment of the PWCT2 visual programming language using the Ring textual\nprogramming language. PWCT2 provides approximately 36 times faster code\ngeneration and requires 20 times less storage for visual source files. It also\nallows for the conversion of Ring code into visual code, enabling the creation\nof a self-hosting VPL that can be developed using itself. PWCT2 consists of\napproximately 92,000 lines of Ring code and comes with 394 visual components.\nPWCT2 is distributed to many users through the Steam platform and has received\npositive feedback, On Steam, 1772 users have launched the software, and the\ntotal recorded usage time exceeds 17,000 hours, encouraging further research\nand development."}
{"id": "2509.20563", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.20563", "abs": "https://arxiv.org/abs/2509.20563", "authors": ["Skyler Ruiter", "Jiannan Tian", "Fengguang Song"], "title": "FZModules: A Heterogeneous Computing Framework for Customizable Scientific Data Compression Pipelines", "comment": null, "summary": "Modern scientific simulations and instruments generate data volumes that\noverwhelm memory and storage, throttling scalability. Lossy compression\nmitigates this by trading controlled error for reduced footprint and throughput\ngains, yet optimal pipelines are highly data and objective specific, demanding\ncompression expertise. GPU compressors supply raw throughput but often\nhard-code fused kernels that hinder rapid experimentation, and underperform in\nrate-distortion. We present FZModules, a heterogeneous framework for assembling\nerror-bounded custom compression pipelines from high-performance modules\nthrough a concise extensible interface. We further utilize an asynchronous\ntask-backed execution library that infers data dependencies, manages memory\nmovement, and exposes branch and stage level concurrency for powerful\nasynchronous compression pipelines. Evaluating three pipelines built with\nFZModules on four representative scientific datasets, we show they can compare\nend-to-end speedup of fused-kernel GPU compressors while achieving similar\nrate-distortion to higher fidelity CPU or hybrid compressors, enabling rapid,\ndomain-tailored design."}
{"id": "2509.20534", "categories": ["cs.PL", "cs.SC", "68W30", "I.1.1; G.4"], "pdf": "https://arxiv.org/pdf/2509.20534", "abs": "https://arxiv.org/abs/2509.20534", "authors": ["Bowen Zhu", "Aayush Sabharwal", "Songchen Tan", "Yingbo Ma", "Alan Edelman", "Christopher Rackauckas"], "title": "Efficient Symbolic Computation vis Hash Consing", "comment": null, "summary": "Symbolic computation systems suffer from memory inefficiencies due to\nredundant storage of structurally identical subexpressions, commonly known as\nexpression swell, which degrades performance in both classical computer algebra\nand emerging AI-driven mathematical reasoning tools. In this paper, we present\nthe first integration of hash consing into JuliaSymbolics, a high-performance\nsymbolic toolkit in Julia, by employing a global weak-reference hash table that\ncanonicalizes expressions and eliminates duplication. This approach reduces\nmemory consumption and accelerates key operations such as differentiation,\nsimplification, and code generation, while seamlessly integrating with Julia's\nmetaprogramming and just-in-time compilation infrastructure. Benchmark\nevaluations across different computational domains reveal substantial\nimprovements: symbolic computations are accelerated by up to 3.2 times, memory\nusage is reduced by up to 2 times, code generation is up to 5 times faster,\nfunction compilation up to 10 times faster, and numerical evaluation up to 100\ntimes faster for larger models. While certain workloads with fewer duplicate\nunknown-variable expressions show more modest gains or even slight overhead in\ninitial computation stages, downstream processing consistently benefits\nsignificantly. These findings underscore the importance of hash consing in\nscaling symbolic computation and pave the way for future work integrating hash\nconsing with e-graphs for enhanced equivalence-aware expression sharing in\nAI-driven pipelines."}
{"id": "2509.20603", "categories": ["cs.DC", "cs.AI", "cs.AR", "cs.ET", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.20603", "abs": "https://arxiv.org/abs/2509.20603", "authors": ["Angel M. Beltre", "Jeff Ogden", "Kevin Pedretti"], "title": "Experience Deploying Containerized GenAI Services at an HPC Center", "comment": "10 pages, 12 figures", "summary": "Generative Artificial Intelligence (GenAI) applications are built from\nspecialized components -- inference servers, object storage, vector and graph\ndatabases, and user interfaces -- interconnected via web-based APIs. While\nthese components are often containerized and deployed in cloud environments,\nsuch capabilities are still emerging at High-Performance Computing (HPC)\ncenters. In this paper, we share our experience deploying GenAI workloads\nwithin an established HPC center, discussing the integration of HPC and cloud\ncomputing environments. We describe our converged computing architecture that\nintegrates HPC and Kubernetes platforms running containerized GenAI workloads,\nhelping with reproducibility. A case study illustrates the deployment of the\nLlama Large Language Model (LLM) using a containerized inference server (vLLM)\nacross both Kubernetes and HPC platforms using multiple container runtimes. Our\nexperience highlights practical considerations and opportunities for the HPC\ncontainer community, guiding future research and tool development."}
{"id": "2509.21039", "categories": ["cs.DC", "cs.CE", "cs.ET", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.21039", "abs": "https://arxiv.org/abs/2509.21039", "authors": ["William F. Godoy", "Tatiana Melnichenko", "Pedro Valero-Lara", "Wael Elwasif", "Philip Fackler", "Rafael Ferreira Da Silva", "Keita Teranishi", "Jeffrey S. Vetter"], "title": "Mojo: MLIR-Based Performance-Portable HPC Science Kernels on GPUs for the Python Ecosystem", "comment": "Accepted at the IEEE/ACM SC25 Conference WACCPD Workshop. The\n  International Conference for High Performance Computing, Networking, Storage,\n  and Analysis, St. Louis, MO, Nov 16-21, 2025. 15 pages, 7 figures. WFG and TM\n  contributed equally", "summary": "We explore the performance and portability of the novel Mojo language for\nscientific computing workloads on GPUs. As the first language based on the\nLLVM's Multi-Level Intermediate Representation (MLIR) compiler infrastructure,\nMojo aims to close performance and productivity gaps by combining Python's\ninteroperability and CUDA-like syntax for compile-time portable GPU\nprogramming. We target four scientific workloads: a seven-point stencil\n(memory-bound), BabelStream (memory-bound), miniBUDE (compute-bound), and\nHartree-Fock (compute-bound with atomic operations); and compare their\nperformance against vendor baselines on NVIDIA H100 and AMD MI300A GPUs. We\nshow that Mojo's performance is competitive with CUDA and HIP for memory-bound\nkernels, whereas gaps exist on AMD GPUs for atomic operations and for fast-math\ncompute-bound kernels on both AMD and NVIDIA GPUs. Although the learning curve\nand programming requirements are still fairly low-level, Mojo can close\nsignificant gaps in the fragmented Python ecosystem in the convergence of\nscientific computing and AI."}
{"id": "2509.20776", "categories": ["cs.DC", "cs.MS", "G.4"], "pdf": "https://arxiv.org/pdf/2509.20776", "abs": "https://arxiv.org/abs/2509.20776", "authors": ["Elaheh Hassani", "Md Taufique Hussain", "Ariful Azad"], "title": "Distributed-memory Algorithms for Sparse Matrix Permutation, Extraction, and Assignment", "comment": "32 pages", "summary": "We present scalable distributed-memory algorithms for sparse matrix\npermutation, extraction, and assignment. Our methods follow an\nIdentify-Exchange-Build (IEB) strategy where each process identifies the local\nnonzeros to be sent, exchanges the required data, and then builds its local\nsubmatrix from the received elements. This approach reduces communication\ncompared to SpGEMM-based methods in distributed memory. By employing\nsynchronization-free multithreaded algorithms, we further accelerate local\ncomputations, achieving substantially better performance than existing\nlibraries such as CombBLAS and PETSc. We design efficient software for these\noperations and evaluate their performance on two university clusters and the\nPerlmutter supercomputer. Our experiments span a variety of application\nscenarios, including matrix permutation for load balancing, matrix reordering,\nsubgraph extraction, and streaming graph applications. In all cases, we compare\nour algorithms against CombBLAS, the most comprehensive distributed library for\nthese operations, and, in some scenarios, against PETSc. Overall, this work\nprovides a comprehensive study of algorithms, software implementations,\nexperimental evaluations, and applications for sparse matrix permutation,\nextraction, and assignment."}
{"id": "2509.20819", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.20819", "abs": "https://arxiv.org/abs/2509.20819", "authors": ["Andre Merzky", "Mikhail Titov", "Matteo Turilli", "Shantenu Jha"], "title": "Integrating and Characterizing HPC Task Runtime Systems for hybrid AI-HPC workloads", "comment": "12 pages, 1 table, 8 figures", "summary": "Scientific workflows increasingly involve both HPC and machine-learning\ntasks, combining MPI-based simulations, training, and inference in a single\nexecution. Launchers such as Slurm's srun constrain concurrency and throughput,\nmaking them unsuitable for dynamic and heterogeneous workloads. We present a\nperformance study of RADICAL-Pilot (RP) integrated with Flux and Dragon, two\ncomplementary runtime systems that enable hierarchical resource management and\nhigh-throughput function execution. Using synthetic and production-scale\nworkloads on Frontier, we characterize the task execution properties of RP\nacross runtime configurations. RP+Flux sustains up to 930 tasks/s, and\nRP+Flux+Dragon exceeds 1,500 tasks/s with over 99.6% utilization. In contrast,\nsrun peaks at 152 tasks/s and degrades with scale, with utilization below 50%.\nFor IMPECCABLE.v2 drug discovery campaign, RP+Flux reduces makespan by 30-60%\nrelative to srun/Slurm and increases throughput more than four times on up to\n1,024. These results demonstrate hybrid runtime integration in RP as a scalable\napproach for hybrid AI-HPC workloads."}
{"id": "2509.21009", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.21009", "abs": "https://arxiv.org/abs/2509.21009", "authors": ["Wei Gao", "Yuheng Zhao", "Dakai An", "Tianyuan Wu", "Lunxi Cao", "Shaopan Xiong", "Ju Huang", "Weixun Wang", "Siran Yang", "Wenbo Su", "Jiamang Wang", "Lin Qu", "Bo Zheng", "Wei Wang"], "title": "RollPacker: Mitigating Long-Tail Rollouts for Fast, Synchronous RL Post-Training", "comment": "16pages,14 figures", "summary": "Reinforcement Learning (RL) is a pivotal post-training technique for\nenhancing the reasoning capabilities of Large Language Models (LLMs). However,\nsynchronous RL post-training often suffers from significant GPU\nunderutilization, referred to as bubbles, caused by imbalanced response lengths\nwithin rollout steps. Many RL systems attempt to alleviate this problem by\nrelaxing synchronization, but this can compromise training accuracy. In this\npaper, we introduce tail batching, a novel rollout scheduling strategy for\nsynchronous RL that systematically consolidates prompts leading to long-tail\nresponses into a small subset of rollout steps (long rounds), while ensuring\nthat the majority of steps (short rounds) involve only balanced, short\nrollouts. By excluding long responses from short rounds and rescheduling them\ninto a few designated long rounds, tail batching effectively reduces GPU idle\ntime during rollouts and significantly accelerates RL training without\nsacrificing accuracy. We present RollPacker, a system that fully harnesses the\nbenefits of tail batching through holistic optimizations across all three RL\nstages: elastic parallelism adaptation for rollout, dynamic resource allocation\nand scheduling for reward, and stream-based training. Empirical results show\nthat RollPacker achieves a 2.03x-2.56x end-to-end training time reduction\ncompared to veRL and up to 2.24x speedup compared to RLHFuse for the Qwen2.5\nfamily of LLMs on up to 128 H800 GPUs."}
{"id": "2509.21037", "categories": ["cs.DC", "cs.MS", "D.1.3; G.1.3; G.4"], "pdf": "https://arxiv.org/pdf/2509.21037", "abs": "https://arxiv.org/abs/2509.21037", "authors": ["Jakub Homola", "Ondřej Meca", "Lubomír Říha", "Tomáš Brzobohatý"], "title": "Utilizing Sparsity in the GPU-accelerated Assembly of Schur Complement Matrices in Domain Decomposition Methods", "comment": "12 pages (originally 10 pages without references), 10 figures,\n  submitted to SC25 conference", "summary": "Schur complement matrices emerge in many domain decomposition methods that\ncan solve complex engineering problems using supercomputers. Today, as most of\nthe high-performance clusters' performance lies in GPUs, these methods should\nalso be accelerated.\n  Typically, the offloaded components are the explicitly assembled dense Schur\ncomplement matrices used later in the iterative solver for multiplication with\na vector. As the explicit assembly is expensive, it represents a significant\noverhead associated with this approach to acceleration. It has already been\nshown that the overhead can be minimized by assembling the Schur complements\ndirectly on the GPU.\n  This paper shows that the GPU assembly can be further improved by wisely\nutilizing the sparsity of the input matrices. In the context of FETI methods,\nwe achieved a speedup of 5.1 in the GPU section of the code and 3.3 for the\nwhole assembly, making the acceleration beneficial from as few as 10\niterations."}
{"id": "2509.21039", "categories": ["cs.DC", "cs.CE", "cs.ET", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.21039", "abs": "https://arxiv.org/abs/2509.21039", "authors": ["William F. Godoy", "Tatiana Melnichenko", "Pedro Valero-Lara", "Wael Elwasif", "Philip Fackler", "Rafael Ferreira Da Silva", "Keita Teranishi", "Jeffrey S. Vetter"], "title": "Mojo: MLIR-Based Performance-Portable HPC Science Kernels on GPUs for the Python Ecosystem", "comment": "Accepted at the IEEE/ACM SC25 Conference WACCPD Workshop. The\n  International Conference for High Performance Computing, Networking, Storage,\n  and Analysis, St. Louis, MO, Nov 16-21, 2025. 15 pages, 7 figures. WFG and TM\n  contributed equally", "summary": "We explore the performance and portability of the novel Mojo language for\nscientific computing workloads on GPUs. As the first language based on the\nLLVM's Multi-Level Intermediate Representation (MLIR) compiler infrastructure,\nMojo aims to close performance and productivity gaps by combining Python's\ninteroperability and CUDA-like syntax for compile-time portable GPU\nprogramming. We target four scientific workloads: a seven-point stencil\n(memory-bound), BabelStream (memory-bound), miniBUDE (compute-bound), and\nHartree-Fock (compute-bound with atomic operations); and compare their\nperformance against vendor baselines on NVIDIA H100 and AMD MI300A GPUs. We\nshow that Mojo's performance is competitive with CUDA and HIP for memory-bound\nkernels, whereas gaps exist on AMD GPUs for atomic operations and for fast-math\ncompute-bound kernels on both AMD and NVIDIA GPUs. Although the learning curve\nand programming requirements are still fairly low-level, Mojo can close\nsignificant gaps in the fragmented Python ecosystem in the convergence of\nscientific computing and AI."}
{"id": "2509.21137", "categories": ["cs.DC", "cs.AR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.21137", "abs": "https://arxiv.org/abs/2509.21137", "authors": ["Huynh Q. N. Vo", "Md Tawsif Rahman Chowdhury", "Paritosh Ramanan", "Gozde Tutuncuoglu", "Junchi Yang", "Feng Qiu", "Murat Yildirim"], "title": "From GPUs to RRAMs: Distributed In-Memory Primal-Dual Hybrid Gradient Method for Solving Large-Scale Linear Optimization Problem", "comment": "Main Article (12 Pages, 3 Figures), Appendix (4 Pages)", "summary": "The exponential growth of computational workloads is surpassing the\ncapabilities of conventional architectures, which are constrained by\nfundamental limits. In-memory computing (IMC) with RRAM provides a promising\nalternative by providing analog computations with significant gains in latency\nand energy use. However, existing algorithms developed for conventional\narchitectures do not translate to IMC, particularly for constrained\noptimization problems where frequent matrix reprogramming remains\ncost-prohibitive for IMC applications. Here we present a distributed in-memory\nprimal-dual hybrid gradient (PDHG) method, specifically co-designed for arrays\nof RRAM devices. Our approach minimizes costly write cycles, incorporates\nrobustness against device non-idealities, and leverages a symmetric\nblock-matrix formulation to unify operations across distributed crossbars. We\nintegrate a physics-based simulation framework called MELISO+ to evaluate\nperformance under realistic device conditions. Benchmarking against\nGPU-accelerated solvers on large-scale linear programs demonstrates that our\nRRAM-based solver achieves comparable accuracy with up to three orders of\nmagnitude reductions in energy consumption and latency. These results\ndemonstrate the first PDHG-based LP solver implemented on RRAMs, showcasing the\ntransformative potential of algorithm-hardware co-design for solving\nlarge-scale optimization through distributed in-memory computing."}
{"id": "2509.21275", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.21275", "abs": "https://arxiv.org/abs/2509.21275", "authors": ["Shiju Wang", "Yujie Wang", "Ao Sun", "Fangcheng Fu", "Zijian Zhu", "Bin Cui", "Xu Han", "Kaisheng Ma"], "title": "Data-Centric Elastic Pipeline Parallelism for Efficient Long-Context LLM Training", "comment": null, "summary": "Long context training is crucial for LLM's context extension. Existing\nschemes, such as sequence parallelism, incur substantial communication\noverhead. Pipeline parallelism (PP) reduces this cost, but its effectiveness\nhinges on partitioning granularity. Batch-level PP dividing input samples\nexhibits high memory consumption in long-context scenario, whereas token-level\nPP splitting sequences into slices alleviates memory overhead but may incur\nhardware under-utilization. This trade-off motivates adaptively selecting PP\ngranularity to match resource and workload characteristics. Moreover, sequence\nlength distribution of the real-world dataset exhibits skewness, posing a\nchallenge on PP's workload balance and efficient scheduling. Current static PP\nscheduling methods overlook the variance of sequence length, leading to\nsuboptimal performance. In this paper, we propose Elastic Pipeline Parallelism\n(EPP) that orchestrates token-level PP and batch-level PP to adapt to resource\nand workload heterogeneity. We build InfiniPipe, a distributed training system\nthat unleashes the potential of EPP via (1) a resource-aware and\nworkload-balanced sequence processor that splits long sequences and packs short\nones; and (2) a co-optimization methodology that jointly optimizes pipeline\nschedule and gradient checkpointing via a mechanism named stage-aware\nchunk-level adaptive checkpointing. Comprehensive experiments demonstrate that\nInfiniPipe achieves a 1.69x speedup over state-of-the-art systems."}
