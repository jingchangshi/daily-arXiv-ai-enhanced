<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]
- [cs.DC](#cs.DC) [Total: 8]
- [cs.AR](#cs.AR) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Filling the Gaps of Polarity: Implementing Dependent Data and Codata Types with Implicit Arguments](https://arxiv.org/abs/2511.15819)
*Bohdan Liesnikov,David Binder,Tim Süberkrüb*

Main category: cs.PL

TL;DR: 本文提出了一个支持隐式参数的算法类型系统和推理算法，以完善Polarity语言的功能，使其能够对称处理归纳类型和余归纳类型。


<details>
  <summary>Details</summary>
Motivation: Polarity语言虽然能够对称处理归纳类型和余归纳类型，但缺乏现代依赖类型语言应有的隐式参数等特性，这限制了其实用性。

Method: 开发了完整的算法类型系统描述和统一的推理算法，涵盖任意归纳和余归纳类型，包括规约语义、转换检查和模式匹配的统一算法。

Result: 提供了Polarity类型系统的完整算法描述和统一的推理算法，正在进行中的实现已可用。

Conclusion: 本文的统一算法和设计决策可为其他支持对称处理归纳和余归纳类型的依赖类型语言提供蓝图。

Abstract: The expression problem describes a fundamental tradeoff between two types of extensibility: extending a type with new operations, such as by pattern matching on an algebraic data type in functional programming, and extending a type with new constructors, such as by adding a new object implementing an interface in object-oriented programming. Most dependently typed languages have good support for the former style through inductive types, but support for the latter style through coinductive types is usually much poorer. Polarity is a language that treats both kinds of types symmetrically and allows the developer to switch between type representations.However, it currently lacks several features expected of a state-of-the-art dependently typed language, such as implicit arguments. The central aim of this paper is to provide an algorithmic type system and inference algorithm for implicit arguments that respect the core symmetry of the language. Our work provides two key contributions: a complete algorithmic description of the type system backing Polarity, and a comprehensive description of a unification algorithm that covers arbitrary inductive and coinductive types. We give rules for reduction semantics, conversion checking, and a unification algorithm for pattern-matching, which are essential for a usable implementation. A work-in-progress implementation of the algorithms in this paper is available at https://polarity-lang.github.io/. We expect that the comprehensive account of the unification algorithm and our design decisions can serve as a blueprint for other dependently typed languages that support inductive and coinductive types symmetrically.

</details>


### [2] [Chorex: Restartable, Language-Integrated Choreographies](https://arxiv.org/abs/2511.15820)
*Ashton Wiersdorf,Ben Greenman*

Main category: cs.PL

TL;DR: Chorex是一种将编排编程引入Elixir的语言，通过元编程实现完整编排功能，支持容错机制和状态恢复。


<details>
  <summary>Details</summary>
Motivation: 构建健壮的分布式应用程序，解决参与者故障时的容错问题，实现编排语言与宿主语言的紧密集成。

Method: 使用元编程在Elixir中实现编排编程，采用检查点机制进行状态恢复，通过静态分析检测编排要求与参与者实现的匹配问题。

Result: 成功实现支持故障容错的编排语言，能够在参与者崩溃时自动恢复，并保持与宿主语言的紧密集成。

Conclusion: Chorex的投影策略（输出无状态函数集合）是支持可重启参与者的可行方法，可推广到其他语言。

Abstract: We built Chorex, a language that brings choreographic programming to Elixir as a path toward robust distributed applications. Chorex is unique among choreographic languages because it tolerates failure among actors: when an actor crashes, Chorex spawns a new process, restores state using a checkpoint, and updates the network configuration for all actors. Chorex also proves that full-featured choreographies can be implemented via metaprogramming, and that doing so achieves tight integration with the host language. For example, mismatches between choreography requirements and an actor implementation are reported statically and in terms of source code rather than macro-expanded code. This paper illustrates Chorex on several examples, ranging from a higher-order bookseller to a secure remote password protocol, details its implementation, and measures the overhead of checkpointing. We conjecture that Chorex's projection strategy, which outputs sets of stateless functions, is a viable approach for other languages to support restartable actors.

</details>


### [3] [BlueScript: A Disaggregated Virtual Machine for Microcontrollers](https://arxiv.org/abs/2511.15821)
*Fumika Mochizuki,Tetsuro Yamazaki,Shigeru Chiba*

Main category: cs.PL

TL;DR: 提出了一种分解式虚拟机，将尽可能多的组件卸载到主机上，以在内存受限的微控制器上提供丰富的功能。


<details>
  <summary>Details</summary>
Motivation: 微控制器虚拟机由于内存限制功能有限，现有方案缺乏交互响应性和高执行速度，需要利用主机丰富资源来增强虚拟机功能。

Method: 设计并实现了BlueScript VM，采用影子机器数据结构在主机上镜像微控制器的执行状态，以减少通信开销。

Result: 卸载组件不会严重影响预期收益，卸载的增量编译器比MicroPython和Espruino执行速度更快，同时保持与MicroPython相当的交互性。

Conclusion: 证明了即使在内存受限的微控制器上，通过组件卸载也能提供丰富功能的可行性。

Abstract: Virtual machines (VMs) are highly beneficial for microcontroller development. 
In particular, interactive programming environments greatly facilitate iterative development processes, 
and higher execution speeds expand the range of applications that can be developed. 
However, due to their limited memory size, microcontroller VMs provide a limited set of features. 
Widely used VMs for microcontrollers often lack interactive responsiveness and/or high execution speed. 
While researchers have investigated offloading certain VM components to other machines,the types of components that can be offloaded are still restricted. 
In this paper, we propose a disaggregated VM that offloads as many components as possible to a host machine. 
This makes it possible to exploit the abundant memory of the host machine and its powerful processing capability to provide rich features through the VM. 
As an instance of a disaggregated VM, we design and implement a BlueScript VM. 
The BlueScript VM is a virtual machine for microcontrollers that provides an interactive development environment. 
We offload most of the components of the BlueScript VM to a host machine. 
To reduce communication overhead between the host machine and the microcontroller,  
we employed a data structure called a shadow machine on the host machine, 
which mirrors the execution state of the microcontroller. 
Through our experiments, we confirmed that offloading components does not seriously compromise their expected benefits.  
We assess that an offloaded incremental compiler results in faster execution speed than MicroPython and Espruino,  
while keeping interactivity comparable with MicroPython.  
In addition, our experiments observe that the offloaded dynamic compiler improves VM performance. 
Through this investigation, we demonstrate the feasibility of providing rich features even on VMs for memory-limited microcontrollers.

</details>


### [4] [Operon: Incremental Construction of Ragged Data via Named Dimensions](https://arxiv.org/abs/2511.16080)
*Sungbin Moon,Jiho Park,Suyoung Hwang,Donghyun Koh,Seunghyun Moon,Minhyeong Lee*

Main category: cs.PL

TL;DR: Operon是一个基于Rust的工作流引擎，专门处理不规则数据，通过命名维度和显式依赖关系提供静态验证和动态调度，在机器学习数据生成管道中表现出色。


<details>
  <summary>Details</summary>
Motivation: 现代数据处理工作流经常遇到不规则数据，现有工作流引擎缺乏对可变长度元素形状和依赖关系的原生支持，用户需要手动管理复杂的索引和依赖关系。

Method: 提出Operon工作流引擎，使用命名维度和显式依赖关系的形式化方法，提供领域特定语言进行静态验证，运行时系统根据数据形状增量发现动态调度任务。

Result: Operon比现有工作流引擎减少14.94倍基线开销，在扩展工作负载时保持接近线性的端到端输出速率，特别适合机器学习应用中的大规模数据生成管道。

Conclusion: Operon通过数学形式化方法证明其增量构造算法保证并行环境中的确定性和融合执行，其显式建模部分已知状态的能力支持强大的持久化和恢复机制。

Abstract: Modern data processing workflows frequently encounter ragged data: collections with variable-length elements that arise naturally in domains like natural language processing, scientific measurements, and autonomous AI agents. Existing workflow engines lack native support for tracking the shapes and dependencies inherent to ragged data, forcing users to manage complex indexing and dependency bookkeeping manually. We present Operon, a Rust-based workflow engine that addresses these challenges through a novel formalism of named dimensions with explicit dependency relations. Operon provides a domain-specific language where users declare pipelines with dimension annotations that are statically verified for correctness, while the runtime system dynamically schedules tasks as data shapes are incrementally discovered during execution. We formalize the mathematical foundation for reasoning about partial shapes and prove that Operon's incremental construction algorithm guarantees deterministic and confluent execution in parallel settings. The system's explicit modeling of partially-known states enables robust persistence and recovery mechanisms, while its per-task multi-queue architecture achieves efficient parallelism across heterogeneous task types. Empirical evaluation demonstrates that Operon outperforms an existing workflow engine with 14.94x baseline overhead reduction while maintaining near-linear end-to-end output rates as workloads scale, making it particularly suitable for large-scale data generation pipelines in machine learning applications.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [5] [A Scalable NorthPole System with End-to-End Vertical Integration for Low-Latency and Energy-Efficient LLM Inference](https://arxiv.org/abs/2511.15950)
*Michael V. DeBole,Rathinakumar Appuswamy,Neil McGlohon,Brian Taba,Steven K. Esser,Filipp Akopyan,John V. Arthur,Arnon Amir,Alexander Andreopoulos,Peter J. Carlson,Andrew S. Cassidy,Pallab Datta,Myron D. Flickner,Rajamohan Gandhasri,Guillaume J. Garreau,Megumi Ito,Jennifer L. Klamo,Jeffrey A. Kusnitz,Nathaniel J. McClatchey,Jeffrey L. McKinstry,Tapan K. Nayak,Carlos Ortega Otero,Hartmut Penner,William P. Risk,Jun Sawada,Jay Sivagnaname,Daniel F. Smith,Rafael Sousa,Ignacio Terrizzano,Takanori Ueda,Trent Gray-Donald,David Cox,Dharmendra S. Modha*

Main category: cs.DC

TL;DR: 一个集成288个NorthPole神经推理加速器卡的研究原型系统，在42U机架空间内提供115 peta-ops计算能力和3.7 PB/s内存带宽，功耗仅30kW，可同时运行3个80亿参数模型实例，支持28个用户并行使用。


<details>
  <summary>Details</summary>
Motivation: 为企业在现有数据中心环境中部署可扩展、高效的AI推理服务，特别是支持企业级AI应用中的代理工作流程。

Method: 采用垂直集成的端到端系统架构，结合NorthPole神经推理加速器卡、离线训练算法、高性能运行时栈和容器化推理流水线。

Result: 系统在4位整数精度下提供115 peta-ops计算能力，3.7 PB/s内存带宽，功耗30kW，重量730kg，可在2.8ms延迟下同时支持28个用户使用80亿参数模型。

Conclusion: 该系统具有可扩展性、模块化和可重构性，支持不同模型大小和上下文长度，适合在企业数据中心环境中部署AI应用。

Abstract: A vertically integrated, end-to-end, research prototype system combines 288 NorthPole neural inference accelerator cards, offline training algorithms, a high-performance runtime stack, and a containerized inference pipeline to deliver a scalable and efficient cloud inference service. The system delivers 115 peta-ops at 4-bit integer precision and 3.7 PB/s of memory bandwidth across 18 2U servers, while consuming only 30 kW of power and weighing 730 kg in a 0.67 m^2 42U rack footprint. The system can run 3 simultaneous instances of the 8-billion-parameter open-source IBM Granite-3.3-8b-instruct model at 2,048 context length with 28 simultaneous users and a per-user inter-token latency of 2.8 ms. The system is scalable, modular, and reconfigurable, supporting various model sizes and context lengths, and is ideal for deploying agentic workflows for enterprise AI applications in existing data center (cloud, on-prem) environments. For example, the system can support 18 instances of a 3-billion-parameter model or a single instance of a 70-billion-parameter model.

</details>


### [6] [Can Asymmetric Tile Buffering Be Beneficial?](https://arxiv.org/abs/2511.16041)
*Chengyue Wang,Wesley Pang,Xinrui Wu,Gregory Jun,Luis Romero,Endri Taka,Diana Marculescu,Tony Nowatzki,Pranathi Vasireddy,Joseph Melber,Deming Chen,Jason Cong*

Main category: cs.DC

TL;DR: 提出了一种称为非对称瓦片缓冲（ATB）的新技术，通过解耦输入和输出操作数的缓冲瓦片维度，显著提升了通用矩阵乘法（GEMM）的性能。


<details>
  <summary>Details</summary>
Motivation: 传统对称瓦片缓冲方法中，输入A沿M维的缓冲瓦片大小与输出C的瓦片大小匹配，这种对称性限制了性能优化。ATB通过解耦这些维度来获得更高的算术强度。

Method: 开发了包含ATB收益（更高算术强度）和开销（更高内核切换成本）的性能模型，指导如何选择有效的ATB分块因子。在AMD XDNA2 AI Engine上进行了案例研究。

Result: 在AMD XDNA2 AI Engine上应用ATB，混合精度BFP16-BF16 GEMM性能从4.8 TFLOPS提升到24.6 TFLOPS，实现了4.54倍加速，创下了XDNA2 AIE的新性能记录。

Conclusion: ATB是一种简单但强大的技术，首次证明了非对称瓦片缓冲的实用性和显著效益，为现代AI工作负载中的GEMM计算提供了重要的性能优化方法。

Abstract: General matrix multiplication (GEMM) is the computational backbone of modern AI workloads, and its efficiency is critically dependent on effective tiling strategies. Conventional approaches employ symmetric tile buffering, where the buffered tile size of the input $A$ along the dimension $M$ matches the output tile size of $C$.
  In this paper, we introduce asymmetric tile buffering (ATB), a simple but powerful technique that decouples the buffered tile dimensions of the input and output operands. We show, for the first time, that ATB is both practical and highly beneficial. To explain this effect, we develop a performance model that incorporates both the benefits of ATB (higher arithmetic intensity) and its overheads (higher kernel switching costs), providing insight into how to select effective ATB tiling factors. As a case study, we apply ATB to AMD's latest XDNA2 AI Engine (AIE), achieving up to a 4.54x speedup, from 4.8 to 24.6 TFLOPS on mixed-precision BFP16--BF16 GEMM, establishing a new performance record for XDNA2 AIE.

</details>


### [7] [Mitigating Shared Storage Congestion Using Control Theory](https://arxiv.org/abs/2511.16177)
*Thomas Collignon,Kouds Halitim,Raphaël Bleuse,Sophie Cerf,Bogdan Robu,Éric Rutten,Lionel Seinturier,Alexandre van Kempen*

Main category: cs.DC

TL;DR: 提出基于控制理论的自适应方法，动态调节客户端I/O速率，缓解HPC系统中的I/O拥塞，提高性能稳定性


<details>
  <summary>Details</summary>
Motivation: 传统I/O栈优化方法具有工作负载特定性，需要专业知识且难以泛化；共享HPC环境中资源拥塞导致性能不可预测，引发减速和超时问题

Method: 利用少量运行时系统负载指标，基于控制理论实现客户端I/O速率的动态调节，在多节点集群中实现控制器

Result: 实验表明该方法有效缓解I/O拥塞，总运行时间减少达20%，降低尾部延迟，同时保持稳定性能

Conclusion: 基于控制理论的自适应I/O速率调节是解决HPC系统I/O拥塞的有效方法，能显著提升性能稳定性

Abstract: Efficient data access in High-Performance Computing (HPC) systems is essential to the performance of intensive computing tasks. Traditional optimizations of the I/O stack aim to improve peak performance but are often workload specific and require deep expertise, making them difficult to generalize or re-use. In shared HPC environments, resource congestion can lead to unpredictable performance, causing slowdowns and timeouts. To address these challenges, we propose a self-adaptive approach based on Control Theory to dynamically regulate client-side I/O rates. Our approach leverages a small set of runtime system load metrics to reduce congestion and enhance performance stability. We implement a controller in a multi-node cluster and evaluate it on a real testbed under a representative workload. Experimental results demonstrate that our method effectively mitigates I/O congestion, reducing total runtime by up to 20% and lowering tail latency, while maintaining stable performance.

</details>


### [8] [Optimizing Communication in Byzantine Agreement Protocols with Slim-HBBFT](https://arxiv.org/abs/2511.15957)
*Nasit S Sony,Xianzhong Ding*

Main category: cs.DC

TL;DR: Slim-HBBFT是一个改进的原子广播协议，通过在异步网络中只选择部分节点的请求进行广播，将通信复杂度降低了O(n)倍。


<details>
  <summary>Details</summary>
Motivation: 传统异步拜占庭协议需要广播所有节点的请求，通信成本高昂。当请求重复时，这种高成本协议并不合理。

Method: 设计了优先可证明广播(P-PB)协议，仅为选定的节点生成广播证明，并基于此构建Slim-HBBFT原子广播协议。

Result: 协议在保持安全性的同时，显著降低了通信复杂度。

Conclusion: Slim-HBBFT通过选择性广播策略，在异步网络中实现了高效且安全的原子广播。

Abstract: Byzantine agreement protocols in asynchronous networks have received renewed interest because they do not rely on network behavior to achieve termination. Conventional asynchronous Byzantine agreement protocols require every party to broadcast its requests (e.g., transactions), and at the end of the protocol, parties agree on one party's request. If parties agree on one party's requests while exchanging every party's request, the protocol becomes expensive. These protocols are used to design an atomic broadcast (ABC) protocol where parties agree on $\langle n-f \rangle$ parties' requests (assuming $n=3f+1$, where $n$ is the total number of parties, and $f$ is the number of Byzantine parties). Although the parties agree on a subset of requests in the ABC protocol, if the requests do not vary (are duplicated), investing in a costly protocol is not justified. We propose Slim-HBBFT, an atomic broadcast protocol that considers requests from a fraction of $n$ parties and improves communication complexity by a factor of $O(n)$. At the core of our design is a prioritized provable-broadcast (P-PB) protocol that generates proof of broadcast only for selected parties. We use the P-PB protocol to design the Slim-HBBFT atomic broadcast protocol. Additionally, we conduct a comprehensive security analysis to demonstrate that Slim-HBBFT satisfies the properties of the Asynchronous Common Subset protocol, ensuring robust security and reliability.

</details>


### [9] [Efficient Chromosome Parallelization for Precision Medicine Genomic Workflows](https://arxiv.org/abs/2511.15977)
*Daniel Mas Montserrat,Ray Verma,Míriam Barrabés,Francisco M. de la Vega,Carlos D. Bustamante,Alexander G. Ioannidis*

Main category: cs.DC

TL;DR: 提出了多种自适应内存优化机制，用于并行化染色体级生物信息学工作流，包括符号回归模型预测内存使用、动态调度器和静态调度器，以减少内存溢出并提高执行效率。


<details>
  <summary>Details</summary>
Motivation: 大规模基因组工作流处理数十到数百GB的数据时，会出现高内存峰值、磁盘I/O密集和内存不足导致的任务失败问题。静态资源分配方法难以处理不同染色体RAM需求的变异性。

Method: 1. 开发符号回归模型估计每个染色体的内存消耗，并引入插值偏置保守最小化过度分配；2. 提出动态调度器使用多项式回归模型自适应预测RAM使用，将任务打包视为背包问题；3. 提出静态调度器优化染色体处理顺序以最小化峰值内存。

Result: 在模拟和真实基因组流程中的评估显示，所提方法能够减少内存溢出并在线程间平衡负载，实现了更快的端到端执行。

Conclusion: 这些方法展示了优化大规模基因组工作流的潜力，通过自适应内存管理提高了资源利用率和执行效率。

Abstract: Large-scale genomic workflows used in precision medicine can process datasets spanning tens to hundreds of gigabytes per sample, leading to high memory spikes, intensive disk I/O, and task failures due to out-of-memory errors. Simple static resource allocation methods struggle to handle the variability in per-chromosome RAM demands, resulting in poor resource utilization and long runtimes. In this work, we propose multiple mechanisms for adaptive, RAM-efficient parallelization of chromosome-level bioinformatics workflows. First, we develop a symbolic regression model that estimates per-chromosome memory consumption for a given task and introduces an interpolating bias to conservatively minimize over-allocation. Second, we present a dynamic scheduler that adaptively predicts RAM usage with a polynomial regression model, treating task packing as a Knapsack problem to optimally batch jobs based on predicted memory requirements. Additionally, we present a static scheduler that optimizes chromosome processing order to minimize peak memory while preserving throughput. Our proposed methods, evaluated on simulations and real-world genomic pipelines, provide new mechanisms to reduce memory overruns and balance load across threads. We thereby achieve faster end-to-end execution, showcasing the potential to optimize large-scale genomic workflows.

</details>


### [10] [Fast LLM Post-training via Decoupled and Best-of-N Speculation](https://arxiv.org/abs/2511.16193)
*Rongxin Cheng,Kai Zhou,Xingda Wei,Siyuan Liu,Mingcong Han,Mingjing Ai,Yeju Zhou,Baoquan Zhong,Wencong Xiao,Xin Liu,Rong Chen,Haibo Chen*

Main category: cs.DC

TL;DR: SpecActor使用推测解码技术加速大语言模型后训练中的rollout阶段，通过动态解耦推测执行和动态Best-of-N推测方法，在保持正确性的同时实现1.3-1.7倍的加速。


<details>
  <summary>Details</summary>
Motivation: 大语言模型后训练中的rollout阶段（使用训练好的模型生成token）占据了大部分训练时间，而传统的推测解码在大批量配置下效率不高。

Method: 采用动态解耦推测执行方法最大化GPU计算效率，以及动态Best-of-N推测方法根据rollout进度选择和组合不同的草稿方法。

Result: SpecActor比常见的后训练基线快1.3-1.7倍，比简单采用推测解码的rollout快1.3-1.5倍。

Conclusion: SpecActor通过创新的推测解码方法有效解决了大语言模型后训练中rollout阶段的性能瓶颈问题。

Abstract: Rollout dominates the training time in large language model (LLM) post-training, where the trained model is used to generate tokens given a batch of prompts. SpecActor achieves fast rollout with speculative decoding that deploys a fast path (e.g., a smaller model) to accelerate the unparallelizable generation, while the correctness is guaranteed by fast parallel verification of the outputs with the original model. SpecActor addresses two foundational challenges in speculative rollout by (1) a \emph{dynamic decoupled speculation} execution method that maximizes the GPU computational efficiency to realize speedup for large-batch execution -- a configuration common in training but unfriendly to speculative execution and (2) a \emph{dynamic Best-of-N speculation} method that selects and combines different drafting methods according to the rollout progress. It substantially improves the speculation accuracy even when the best drafting method is unknown a priori, meanwhile without requiring adding extra computation resources. {\sys} is {1.3--1.7}\,$\times$ faster than common post-training baselines, and is {1.3--1.5}\,$\times$ faster compared to naively adopting speculative decoding for rollout.

</details>


### [11] [Optimizing Federated Learning in the Era of LLMs: Message Quantization and Streaming](https://arxiv.org/abs/2511.16450)
*Ziyue Xu,Zhihong Zhang,Holger R. Roth,Chester Chen,Yan Cheng,Andrew Feng*

Main category: cs.DC

TL;DR: NVIDIA FLARE通过消息量化和容器/文件流技术，解决了联邦学习中大语言模型的通信开销和内存约束问题，提升了联邦学习的效率和可扩展性。


<details>
  <summary>Details</summary>
Motivation: 联邦学习在保护数据隐私的同时训练分布式模型，但大语言模型的巨大参数量加剧了内存和通信约束，需要高效的传输和处理方法。

Method: 使用消息量化减少消息大小，以及容器/文件流技术实现高效内存管理，增强与现有工作流的集成。

Result: 这些技术显著提升了联邦学习与大语言模型的鲁棒性和效率，在真实场景中表现更好。

Conclusion: NVIDIA FLARE的先进通信能力有效解决了联邦学习在大语言模型时代面临的挑战，确保了实际部署的可行性。

Abstract: Federated Learning (FL) offers a promising solution for training machine learning models across distributed data sources while preserving data privacy. However, FL faces critical challenges related to communication overhead and local resource constraints, especially in the era of Large Language Models (LLMs) with billions of parameters. The sheer size of these models exacerbates both memory and communication constraints, making efficient transmission and processing essential for practical deployment. NVIDIA FLARE, an open-source SDK for federated learning, addresses these challenges by introducing advanced communication capabilities. Building upon existing solutions for large object streaming, we enhance FL workflows for LLMs through two key techniques: message quantization and container/file streaming. Quantization reduces message size, while streaming enables efficient memory management, improving scalability and integration with existing workflows. These advancements significantly enhance the robustness and efficiency of FL with LLMs, ensuring better performance in real-world federated learning scenarios.

</details>


### [12] [Distributed MIS Algorithms for Rational Agents using Games](https://arxiv.org/abs/2511.16533)
*Nithin Salevemula,Shreyas Pai*

Main category: cs.DC

TL;DR: 该论文研究了在分布式网络中计算最大独立集的问题，其中节点是理性代理，其收益取决于是否加入MIS。提出了两种基于效用模型的算法，通过邻居节点间的成对交互生成随机性，确保在理性行为下仍能打破对称性。


<details>
  <summary>Details</summary>
Motivation: 传统的分布式算法假设节点遵循协议，但在理性代理可能偏离协议以增加预期效用的场景下失效。标准MIS算法依赖诚实随机性或唯一标识符来打破对称性，但理性代理可能操纵随机性，仅依赖标识符可能导致不公平，使某些节点加入MIS的概率为零，从而缺乏参与动机。

Method: 提出了两种基于效用模型的算法，其中随机性通过邻居节点间的成对交互生成，视为简单游戏，单个节点无法单方面影响结果。这允许在保持与理性行为兼容的同时打破对称性。

Result: 对于两种算法，证明了在执行过程的每个阶段，给定任何历史，假设其他节点遵循算法，没有代理能通过单边偏离增加其预期效用。当所有节点遵循协议时，每个节点都有正概率加入MIS，最终输出正确的MIS。在温和的附加假设下，两种算法都以高概率在O(log n)轮内终止。

Conclusion: 提出的算法在理性分布式设置中提供了更强的保证，超越了颤抖手完美均衡，确保了公平性和正确性，同时保持了高效的时间复杂度。

Abstract: We study the problem of computing a Maximal Independent Set (MIS) in distributed networks where each node is a rational agent whose payoff depends on whether it joins the MIS. Classical distributed algorithms assume that nodes follow the prescribed protocol, but this assumption fails when nodes are strategic and may deviate if doing so increases their expected utility.
  Standard MIS algorithms rely on honest randomness or unique identifiers to break symmetry. In rational settings, however, agents may manipulate randomness, and relying solely on identifiers can create unfairness, giving some nodes zero probability of joining the MIS and thus no incentive to participate. To address these issues, we propose two algorithms based on a utility model in which agents seek locally correct solutions while also having preferences over which solution is chosen. Randomness in our algorithms is generated through pairwise interactions between neighboring nodes, viewed as simple games in which no single node can unilaterally affect the outcome. This allows symmetry breaking while remaining compatible with rational behavior.
  For both algorithms, we prove that at every stage of the execution, given any history, no agent can increase its expected utility through a unilateral deviation, assuming others follow the algorithm. This gives a stronger guarantee than Trembling-Hand Perfect Equilibrium. When all nodes follow the protocol, every node has a positive probability of joining the MIS, and the final output is a correct MIS. Under mild additional assumptions, both algorithms terminate in $O(\log n)$ rounds with high probability.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [13] [CIMinus: Empowering Sparse DNN Workloads Modeling and Exploration on SRAM-based CIM Architectures](https://arxiv.org/abs/2511.16368)
*Yingjie Qi,Jianlei Yang,Rubing Yang,Cenlin Duan,Xiaolin He,Ziyan He,Weitao Pan,Weisheng Zhao*

Main category: cs.AR

TL;DR: CIMinus是一个用于CIM架构上稀疏DNN工作负载成本建模的框架，提供组件级能耗分析和整体延迟评估，填补了理论设计与实际实现之间的差距。


<details>
  <summary>Details</summary>
Motivation: CIM系统在利用稀疏性方面面临挑战，由于刚性阵列结构的限制，且缺乏对稀疏DNN工作负载的统一系统化视图和建模方法。

Method: 提出CIMinus框架，在组件级别进行能耗分析，评估整体工作负载延迟，并在当代CIM架构上进行验证。

Result: 验证了CIMinus在当代CIM架构上的适用性，通过两个用例展示了稀疏模式影响和映射策略有效性。

Conclusion: CIMinus为稀疏DNN工作负载在CIM架构上的成本建模提供了系统化方法，有助于弥合理论设计与实际实现之间的差距。

Abstract: Compute-in-memory (CIM) has emerged as a pivotal direction for accelerating workloads in the field of machine learning, such as Deep Neural Networks (DNNs). However, the effective exploitation of sparsity in CIM systems presents numerous challenges, due to the inherent limitations in their rigid array structures. Designing sparse DNN dataflows and developing efficient mapping strategies also become more complex when accounting for diverse sparsity patterns and the flexibility of a multi-macro CIM structure. Despite these complexities, there is still an absence of a unified systematic view and modeling approach for diverse sparse DNN workloads in CIM systems. In this paper, we propose CIMinus, a framework dedicated to cost modeling for sparse DNN workloads on CIM architectures. It provides an in-depth energy consumption analysis at the level of individual components and an assessment of the overall workload latency. We validate CIMinus against contemporary CIM architectures and demonstrate its applicability in two use-cases. These cases provide valuable insights into both the impact of sparsity patterns and the effectiveness of mapping strategies, bridging the gap between theoretical design and practical implementation.

</details>


### [14] [Unsupervised Graph Neural Network Framework for Balanced Multipatterning in Advanced Electronic Design Automation Layouts](https://arxiv.org/abs/2511.16374)
*Abdelrahman Helaly,Nourhan Sakr,Kareem Madkour,Ilhami Torunoglu*

Main category: cs.AR

TL;DR: 提出了一种混合工作流，将多图案分解转化为约束图着色问题，主要目标是最小化特征违规，次要目标是平衡每个掩模上的特征数量。


<details>
  <summary>Details</summary>
Motivation: 解决启发式回溯和SAT求解器在处理复杂约束和次要目标时的困难，为EDA工作流提供可扩展的布局分解方案。

Method: 结合GNN代理（无监督训练生成初始颜色预测）和优化策略（GNN启发式和模拟退火）的混合工作流。

Result: 在专有数据集和公开开源布局上的实验评估显示，实现了无冲突分解和一致的色彩平衡。

Conclusion: 该框架为EDA工作流中的可扩展布局分解提供了可重复、数据高效且可部署的基准。

Abstract: Multipatterning is an essential decomposition strategy in electronic design automation (EDA) that overcomes lithographic limitations when printing dense circuit layouts. Although heuristic-based backtracking and SAT solvers can address these challenges, they often struggle to simultaneously handle both complex constraints and secondary objectives. In this study, we present a hybrid workflow that casts multipatterning as a variant of a constrained graph coloring problem with the primary objective of minimizing feature violations and a secondary objective of balancing the number of features on each mask. Our pipeline integrates two main components: (1) A GNN-based agent, trained in an unsupervised manner to generate initial color predictions, which are refined by (2) refinement strategies (a GNN-based heuristic and simulated annealing) that together enhance solution quality and balance. Experimental evaluation in both proprietary data sets and publicly available open source layouts demonstrate complete conflict-free decomposition and consistent color balancing. The proposed framework provides a reproducible, data-efficient and deployable baseline for scalable layout decomposition in EDA workflows.

</details>
