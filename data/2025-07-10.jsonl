{"id": "2507.06376", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2507.06376", "abs": "https://arxiv.org/abs/2507.06376", "authors": ["Elisavet Lydia Alvanaki", "Kevin Lee", "Luca P. Carloni"], "title": "SLDB: An End-To-End Heterogeneous System-on-Chip Benchmark Suite for LLM-Aided Design", "comment": null, "summary": "Over the last few years, Large Language Models (LLMs) have emerged as a\nvaluable tool for Electronic Design Automation (EDA). State-of-the-art research\nin LLM-aided design has demonstrated the ability of LLMs to generate\nsyntactically correct RTL code, showcasing encouraging prospects for\nintegrating AI into the hardware design process. A key enabler of these\nadvancements is the availability of high-quality benchmarks to evaluate new\napproaches. However, existing datasets and benchmarks fall short of\nsystem-level design, as they focus primarily on component-level information and\nlow-complexity designs. To address this gap, we introduce the System-Level\nDesign Benchmark (SLDB), a dataset tailored for evaluating LLMs in system-level\nintegration and configuration tasks. SLDB includes a curated benchmark suite of\n10 baseline SoC designs, whose components can be combined into an exponential\nnumber of distinct tile-based SoCs through a synthetic library. The dataset\nprovides full SoC configurations, accelerator integration code, communication\nparameters, and accelerator-aware system configurations, along with\ntesting-application code, compatible with the ESP platform[1]."}
{"id": "2507.06512", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.06512", "abs": "https://arxiv.org/abs/2507.06512", "authors": ["Siyu Qiu", "Muzhi Wang", "Raheel Afsharmazayejani", "Mohammad Moradi Shahmiri", "Benjamin Tan", "Hammond Pearce"], "title": "Towards LLM-based Root Cause Analysis of Hardware Design Failures", "comment": "6 pages. Accepted for publication in IEEE COINS 2025 Special Session\n  on LLMs for EDA and Security", "summary": "With advances in large language models (LLMs), new opportunities have emerged\nto develop tools that support the digital hardware design process. In this\nwork, we explore how LLMs can assist with explaining the root cause of design\nissues and bugs that are revealed during synthesis and simulation, a necessary\nmilestone on the pathway towards widespread use of LLMs in the hardware design\nprocess and for hardware security analysis. We find promising results: for our\ncorpus of 34 different buggy scenarios, OpenAI's o3-mini reasoning model\nreached a correct determination 100% of the time under pass@5 scoring, with\nother state of the art models and configurations usually achieving more than\n80% performance and more than 90% when assisted with retrieval-augmented\ngeneration."}
{"id": "2507.07044", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2507.07044", "abs": "https://arxiv.org/abs/2507.07044", "authors": ["Mehrdad Morsali", "Chengwei Zhou", "Deniz Najafi", "Sreetama Sarkar", "Pietro Mercati", "Navid Khoshavi", "Peter Beerel", "Mahdi Nikdast", "Gourav Datta", "Shaahin Angizi"], "title": "Opto-ViT: Architecting a Near-Sensor Region of Interest-Aware Vision Transformer Accelerator with Silicon Photonics", "comment": null, "summary": "Vision Transformers (ViTs) have emerged as a powerful architecture for\ncomputer vision tasks due to their ability to model long-range dependencies and\nglobal contextual relationships. However, their substantial compute and memory\ndemands hinder efficient deployment in scenarios with strict energy and\nbandwidth limitations. In this work, we propose OptoViT, the first near-sensor,\nregion-aware ViT accelerator leveraging silicon photonics (SiPh) for real-time\nand energy-efficient vision processing. Opto-ViT features a hybrid\nelectronic-photonic architecture, where the optical core handles\ncompute-intensive matrix multiplications using Vertical-Cavity Surface-Emitting\nLasers (VCSELs) and Microring Resonators (MRs), while nonlinear functions and\nnormalization are executed electronically. To reduce redundant computation and\npatch processing, we introduce a lightweight Mask Generation Network (MGNet)\nthat identifies regions of interest in the current frame and prunes irrelevant\npatches before ViT encoding. We further co-optimize the ViT backbone using\nquantization-aware training and matrix decomposition tailored for photonic\nconstraints. Experiments across device fabrication, circuit and architecture\nco-design, to classification, detection, and video tasks demonstrate that\nOptoViT achieves 100.4 KFPS/W with up to 84% energy savings with less than 1.6%\naccuracy loss, while enabling scalable and efficient ViT deployment at the\nedge."}
{"id": "2507.06360", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.06360", "abs": "https://arxiv.org/abs/2507.06360", "authors": ["Dustin Jamner", "Gabriel Kammer", "Ritam Nag", "Adam Chlipala"], "title": "Pyrosome: Verified Compilation for Modular Metatheory", "comment": null, "summary": "We present Pyrosome, a generic framework for modular language metatheory that\nembodies a novel approach to extensible semantics and compilation, implemented\nin Coq. Common techniques for semantic reasoning are often tied to the specific\nstructures of the languages and compilers that they support. In Pyrosome,\nverified compilers are fully extensible, meaning that to extend a language\n(even with a new kind of effect) simply requires defining and verifying the\ncompilation of the new feature, reusing the old correctness theorem for all\nother cases. The novel enabling idea is an inductive formulation of equivalence\npreservation that supports the addition of new rules to the source language,\ntarget language, and compiler.\n  Pyrosome defines a formal, deeply embedded notion of programming languages\nwith semantics given by dependently sorted equational theories, so all\ncompiler-correctness proofs boil down to type-checking and equational\nreasoning. We support vertical composition of any compilers expressed in our\nframework in addition to feature extension. As a case study, we present a\nmultipass compiler from System F with simple references, through CPS\ntranslation and closure conversion. Specifically, we demonstrate how we can\nbuild such a compiler incrementally by starting with a compiler for simply\ntyped lambda-calculus and adding natural numbers, the unit type, recursive\nfunctions, and a global heap, then extending judgments with a type environment\nand adding type abstraction, all while reusing the original theorems. We also\npresent a linear version of the simply typed CPS pass and compile a small\nimperative language to the simply typed target to show how Pyrosome handles\nsubstructural typing and imperative features."}
{"id": "2507.06471", "categories": ["cs.DC", "cs.DS"], "pdf": "https://arxiv.org/pdf/2507.06471", "abs": "https://arxiv.org/abs/2507.06471", "authors": ["Fuhuan Li", "Zhihui Du", "David A. Bader"], "title": "Designing Parallel Algorithms for Community Detection using Arachne", "comment": null, "summary": "The rise of graph data in various fields calls for efficient and scalable\ncommunity detection algorithms. In this paper, we present parallel\nimplementations of two widely used algorithms: Label Propagation and Louvain,\nspecifically designed to leverage the capabilities of Arachne which is a\nPython-accessible, open-source framework for large-scale graph analysis. Our\nimplementations achieve substantial speedups over existing Python-based tools\nlike NetworkX and igraph, which lack efficient parallelization, and are\ncompetitive with parallel frameworks such as NetworKit. Experimental results\nshow that Arachne-based methods outperform these baselines, achieving speedups\nof up to 710x over NetworkX, 75x over igraph, and 12x over NetworKit.\nAdditionally, we analyze the scalability of our implementation under varying\nthread counts, demonstrating how different phases contribute to overall\nperformance gains of the parallel Louvain algorithm. Arachne, including our\ncommunity detection implementation, is open-source and available at\nhttps://github.com/Bears-R-Us/arkouda-njit ."}
{"id": "2507.06456", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.06456", "abs": "https://arxiv.org/abs/2507.06456", "authors": ["Scott Kovach", "Praneeth Kolichala", "Kyle A. Miller", "David Broman", "Fredrik Kjolstad"], "title": "Fast Collection Operations from Indexed Stream Fusion", "comment": null, "summary": "We present a system of efficient methods for traversing and combining\nassociative collection data structures. A distinguishing feature of the system\nis that, like traditional sequential iterator libraries, it does not require\nspecialized compiler infrastructure or staged compilation for efficiency and\ncomposability. By using a representation based on indexed streams, the library\ncan express complex joins over input collections while using no intermediate\nallocations. We implement the library for the Lean, Morphic, and Rust\nprogramming languages and provide a mechanized proof of functional correctness\nin Lean."}
{"id": "2507.06608", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.06608", "abs": "https://arxiv.org/abs/2507.06608", "authors": ["Xiaoxiang Shi", "Colin Cai", "Junjia Du", "Zhanda Zhu", "Xingda Wei", "Zhihao Jia"], "title": "Nexus: Taming Throughput-Latency Tradeoff in LLM Serving via Efficient GPU Sharing", "comment": null, "summary": "Current prefill-decode (PD) disaggregation is typically deployed at the level\nof entire serving engines, assigning separate GPUs to handle prefill and decode\nphases. While effective at reducing latency, this approach demands more\nhardware. To improve GPU utilization, Chunked Prefill mixes prefill and decode\nrequests within the same batch, but introduces phase interference between\nprefill and decode.\n  While existing PD disaggregation solutions separate the phases across GPUs,\nwe ask: can the same decoupling be achieved within a single serving engine? The\nkey challenge lies in managing the conflicting resource requirements of prefill\nand decode when they share the same hardware. In this paper, we first show that\nchunked prefill requests cause interference with decode requests due to their\ndistinct requirements for GPU resources. Second, we find that GPU resources\nexhibit diminishing returns. Beyond a saturation point, increasing GPU\nallocation yields negligible latency improvements. This insight enables us to\nsplit a single GPU's resources and dynamically allocate them to prefill and\ndecode on the fly, effectively disaggregating the two phases within the same\nGPU.\n  Across a range of models and workloads, our system Nexus achieves up to 2.2x\nhigher throughput, 20x lower TTFT, and 2.5x lower TBT than vLLM. It also\noutperforms SGLang with up to 2x higher throughput, 2x lower TTFT, and 1.7x\nlower TBT, and achieves 1.4x higher throughput than vLLM-disaggregation using\nonly half the number of GPUs."}
{"id": "2507.06584", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2507.06584", "abs": "https://arxiv.org/abs/2507.06584", "authors": ["Qiong Feng", "Xiaotian Ma", "Ziyuan Feng", "Marat Akhin", "Wei Song", "Peng Liang"], "title": "Finding Compiler Bugs through Cross-Language Code Generator and Differential Testing", "comment": "The 40th ACM SIGPLAN International Conference on Object-Oriented\n  Programming, Systems, Languages, and Applications (OOPSLA)", "summary": "Compilers play a central role in translating high-level code into executable\nprograms, making their correctness essential for ensuring code safety and\nreliability. While extensive research has focused on verifying the correctness\nof compilers for single-language compilation, the correctness of cross-language\ncompilation - which involves the interaction between two languages and their\nrespective compilers - remains largely unexplored. To fill this research gap,\nwe propose CrossLangFuzzer, a novel framework that introduces a universal\nintermediate representation (IR) for JVM-based languages and automatically\ngenerates cross-language test programs with diverse type parameters and complex\ninheritance structures. After generating the initial IR, CrossLangFuzzer\napplies three mutation techniques - LangShuffler, FunctionRemoval, and\nTypeChanger - to enhance program diversity. By evaluating both the original and\nmutated programs across multiple compiler versions, CrossLangFuzzer\nsuccessfully uncovered 10 confirmed bugs in the Kotlin compiler, 4 confirmed\nbugs in the Groovy compiler, 7 confirmed bugs in the Scala 3 compiler, 2\nconfirmed bugs in the Scala 2 compiler, and 1 confirmed bug in the Java\ncompiler. Among all mutators, TypeChanger is the most effective, detecting 11\nof the 24 compiler bugs. Furthermore, we analyze the symptoms and root causes\nof cross-compilation bugs, examining the respective responsibilities of\nlanguage compilers when incorrect behavior occurs during cross-language\ncompilation. To the best of our knowledge, this is the firstwork specifically\nfocused on identifying and diagnosing compiler bugs in cross-language\ncompilation scenarios. Our research helps to understand these challenges and\ncontributes to improving compiler correctness in multi-language environments."}
{"id": "2507.06653", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.06653", "abs": "https://arxiv.org/abs/2507.06653", "authors": ["Xiangyu Zhi", "Meng Chen", "Xiao Yan", "Baotong Lu", "Hui Li", "Qianxi Zhang", "Qi Chen", "James Cheng"], "title": "Towards Efficient and Scalable Distributed Vector Search with RDMA", "comment": null, "summary": "Similarity-based vector search facilitates many important applications such\nas search and recommendation but is limited by the memory capacity and\nbandwidth of a single machine due to large datasets and intensive data read. In\nthis paper, we present CoTra, a system that scales up vector search for\ndistributed execution. We observe a tension between computation and\ncommunication efficiency, which is the main challenge for good scalability,\ni.e., handling the local vectors on each machine independently blows up\ncomputation as the pruning power of vector index is not fully utilized, while\nrunning a global index over all machines introduces rich data dependencies and\nthus extensive communication. To resolve such tension, we leverage the fact\nthat vector search is approximate in nature and robust to asynchronous\nexecution. In particular, we run collaborative vector search over the machines\nwith algorithm-system co-designs including clustering-based data partitioning\nto reduce communication, asynchronous execution to avoid communication stall,\nand task push to reduce network traffic. To make collaborative search\nefficient, we introduce a suite of system optimizations including task\nscheduling, communication batching, and storage format. We evaluate CoTra on\nreal datasets and compare with four baselines. The results show that when using\n16 machines, the query throughput of CoTra scales to 9.8-13.4x over a single\nmachine and is 2.12-3.58x of the best-performing baseline at 0.95 recall@10."}
{"id": "2507.06939", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.06939", "abs": "https://arxiv.org/abs/2507.06939", "authors": ["Guilherme Espada", "Alcides Fonseca"], "title": "Sound Interval-Based Synthesis for Probabilistic Programs", "comment": null, "summary": "Probabilistic programming has become a standard practice to model stochastic\nevents and learn about the behavior of nature in different scientific contexts,\nranging from Genetics and Ecology to Linguistics and Psychology. However,\ndomain practitioners (such as biologists) also need to be experts in statistics\nin order to select which probabilistic model is suitable for a given particular\nproblem, relying then on probabilistic inference engines such as Stan, Pyro or\nEdward to fine-tune the parameters of that particular model. Probabilistic\nProgramming would be more useful if the model selection is made automatic,\nwithout requiring statistics expertise from the end user. Automatically\nselecting the model is challenging because of the large search space of\nprobabilistic programs needed to be explored, because the fact that most of\nthat search space contains invalid programs, and because invalid programs may\nonly be detected in some executions, due to its probabilistic nature. We\npropose a type system to statically reject invalid probabilistic programs, a\ntype-directed synthesis algorithm that guarantees that generated programs are\ntype-safe by construction, and an heuristic search procedure to handle the vast\nsearch space. We collect a number of probabilistic programs from the\nliterature, and use them to compare our method with both a type-agnostic random\nsearch, and a data-guided method from the literature (DaPPer). Our results show\nthat our technique both outperforms random search and DaPPer, specially on more\ncomplex programs. This drastic performance difference in synthesis allows for\nfast sampling of programs and enables techniques that previously suffered from\nthe complexity of synthesis, such as Genetic Programming, to be applied."}
