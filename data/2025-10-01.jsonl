{"id": "2509.25391", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.25391", "abs": "https://arxiv.org/abs/2509.25391", "authors": ["Fernanda Zapata Bascuñán", "Alan Ezequiel Fuster"], "title": "smallNet: Implementation of a convolutional layer in tiny FPGAs", "comment": null, "summary": "Since current neural network development systems in Xilinx and VLSI require\ncodevelopment with Python libraries, the first stage of a convolutional network\nhas been implemented by developing a convolutional layer entirely in Verilog.\nThis handcoded design, free of IP cores and based on a filter polynomial like\nstructure, enables straightforward deployment not only on low cost FPGAs but\nalso on SoMs, SoCs, and ASICs. We analyze the limitations of numerical\nrepresentations and compare our implemented architecture, smallNet, with its\ncomputer based counterpart, demonstrating a 5.1x speedup, over 81%\nclassification accuracy, and a total power consumption of just 1.5 W. The\nalgorithm is validated on a single-core Cora Z7, demonstrating its feasibility\nfor real time, resource-constrained embedded applications."}
{"id": "2509.25626", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.25626", "abs": "https://arxiv.org/abs/2509.25626", "authors": ["Yi Hu", "Huiyang Zhou"], "title": "LLM-Powered Code Analysis and Optimization for Gaussian Splatting Kernels", "comment": null, "summary": "3D Gaussian splatting (3DGS) is a transformative technique with profound\nimplications on novel view synthesis and real-time rendering. Given its\nimportance, there have been many attempts to improve its performance. However,\nwith the increasing complexity of GPU architectures and the vast search space\nof performance-tuning parameters, it is a challenging task. Although manual\noptimizations have achieved remarkable speedups, they require domain expertise\nand the optimization process can be highly time consuming and error prone. In\nthis paper, we propose to exploit large language models (LLMs) to analyze and\noptimize Gaussian splatting kernels. To our knowledge, this is the first work\nto use LLMs to optimize highly specialized real-world GPU kernels. We reveal\nthe intricacies of using LLMs for code optimization and analyze the code\noptimization techniques from the LLMs. We also propose ways to collaborate with\nLLMs to further leverage their capabilities. For the original 3DGS code on the\nMipNeRF360 datasets, LLMs achieve significant speedups, 19% with Deepseek and\n24% with GPT-5, demonstrating the different capabilities of different LLMs. By\nfeeding additional information from performance profilers, the performance\nimprovement from LLM-optimized code is enhanced to up to 42% and 38% on\naverage. In comparison, our best-effort manually optimized version can achieve\na performance improvement up to 48% and 39% on average, showing that there are\nstill optimizations beyond the capabilities of current LLMs. On the other hand,\neven upon a newly proposed 3DGS framework with algorithmic optimizations,\nSeele, LLMs can still further enhance its performance by 6%, showing that there\nare optimization opportunities missed by domain experts. This highlights the\npotential of collaboration between domain experts and LLMs."}
{"id": "2509.25853", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.25853", "abs": "https://arxiv.org/abs/2509.25853", "authors": ["Jingyao Zhang", "Jaewoo Park", "Jongeun Lee", "Elaheh Sadredini"], "title": "SAIL: SRAM-Accelerated LLM Inference System with Lookup-Table-based GEMV", "comment": null, "summary": "Large Language Model (LLM) inference requires substantial computational\nresources, yet CPU-based inference remains essential for democratizing AI due\nto the widespread availability of CPUs compared to specialized accelerators.\nHowever, efficient LLM inference on CPUs faces two fundamental challenges: (1)\nexisting CPU architectures struggle with low-precision arithmetic required by\nquantized models, where optimal bit precision varies across models and layers;\nand (2) the memory-bound nature of the token generation phase creates severe\nperformance bottlenecks. To address these challenges, we propose SAIL\n(SRAM-Accelerated Inference of LLMs), a CPU-based inference solution that\nefficiently supports arbitrary bit precisions with minimal overhead. SAIL\nintegrates three key innovations: First, we introduce Batched LUT-based General\nMatrix-Vector Multiplication (LUT-GEMV) with SRAM-based processing-in-memory,\nenabling high data reuse through lookup tables and reducing memory movement.\nSecond, our Pattern-Aware LUT optimization identifies and exploits redundancy\nin input activation patterns, reducing computation cycles by 13.8\\%. Third, we\ndevelop an in-memory type conversion algorithm that leverages PIM's parallelism\nfor efficient de-/quantization operations, alleviating pressure on CPU's vector\nunits. Our architecture requires only 2\\% hardware overhead and a single new\ninstruction, while maintaining dual functionality as both compute and storage\nunits. Experimental evaluations using a modified gem5 simulator demonstrate\nthat SAIL achieves up to 10.7x speedup and 19.9x higher tokens per dollar\ncompared to ARM Neoverse-N1 CPU baselines, and up to 7.04x better cost\nefficiency than NVIDIA V100 GPUs, establishing a practical path for efficient\nCPU-based LLM inference."}
{"id": "2509.26065", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2509.26065", "abs": "https://arxiv.org/abs/2509.26065", "authors": ["Alberto Scionti", "Paolo Savio", "Francesco Lubrano", "Olivier Terzo", "Marco Ferretti", "Florin Apopei", "Juri Bellucci", "Ennio Spano", "Luca Carriere"], "title": "Runtime Energy Monitoring for RISC-V Soft-Cores", "comment": null, "summary": "Energy efficiency is one of the major concern in designing advanced computing\ninfrastructures. From single nodes to large-scale systems (data centers),\nmonitoring the energy consumption of the computing system when applications run\nis a critical task. Designers and application developers often rely on software\ntools and detailed architectural models to extract meaningful information and\ndetermine the system energy consumption. However, when a design space\nexploration is required, designers may incur in continuous tuning of the models\nto match with the system under evaluation. To overcome such limitations, we\npropose a holistic approach to monitor energy consumption at runtime without\nthe need of running complex (micro-)architectural models. Our approach is based\non a measurement board coupled with a FPGA-based System-on-Module. The\nmeasuring board captures currents and voltages (up to tens measuring points)\ndriving the FPGA and exposes such values through a specific memory region. A\nrunning service reads and computes energy consumption statistics without\nconsuming extra resources on the FPGA device. Our approach is also scalable to\nmonitoring of multi-nodes infrastructures (clusters). We aim to leverage this\nframework to perform experiments in the context of an aeronautical design\napplication; specifically, we will look at optimizing performance and energy\nconsumption of a shallow artificial neural network on RISC-V based soft-cores."}
{"id": "2509.25415", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.25415", "abs": "https://arxiv.org/abs/2509.25415", "authors": ["Jan Droll"], "title": "Permuting Transactions in Ethereum Blocks: An Empirical Study", "comment": "17 pages, 6 figures, experiment code available", "summary": "Several recent proposals implicitly or explicitly suggest making use of\nrandomized transaction ordering within a block to mitigate centralization\neffects and to improve fairness in the Ethereum ecosystem. However,\ntransactions and blocks are subject to gas limits and protocol rules. In a\nrandomized transaction order, the behavior of transactions may change depending\non other transactions in the same block, leading to invalid blocks and varying\ngas consumptions. In this paper, we quantify and characterize protocol\nviolations, execution errors and deviations in gas consumption of blocks and\ntransactions to examine technical deployability. For that, we permute and\nexecute the transactions of over 335,000 Ethereum Mainnet blocks multiple\ntimes. About 22% of block permutations are invalid due to protocol violations\ncaused by privately mined transactions or blocks close to their gas limit.\nAlso, almost all transactions which show execution errors under permutation but\nnot in the original order are privately mined transactions. Only 6% of\ntransactions show deviations in gas consumption and 98% of block permutations\ndeviate at most 10% from their original gas consumption. From a technical\nperspective, these results suggest that randomized transaction ordering may be\nfeasible if transaction selection is handled carefully."}
{"id": "2509.26043", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.26043", "abs": "https://arxiv.org/abs/2509.26043", "authors": ["Alberto Scionti", "Paolo Savio", "Francesco Lubrano", "Federico Stirano", "Antonino Nespola", "Olivier Terzo", "Corrado De Sio", "Luca Sterpone"], "title": "Enabling Time-Aware Priority Traffic Management over Distributed FPGA Nodes", "comment": null, "summary": "Network Interface Cards (NICs) greatly evolved from simple basic devices\nmoving traffic in and out of the network to complex heterogeneous systems\noffloading host CPUs from performing complex tasks on in-transit packets. These\nlatter comprise different types of devices, ranging from NICs accelerating\nfixed specific functions (e.g., on-the-fly data compression/decompression,\nchecksum computation, data encryption, etc.) to complex Systems-on-Chip (SoC)\nequipped with both general purpose processors and specialized engines\n(Smart-NICs). Similarly, Field Programmable Gate Arrays (FPGAs) moved from pure\nreprogrammable devices to modern heterogeneous systems comprising\ngeneral-purpose processors, real-time cores and even AI-oriented engines.\nFurthermore, the availability of high-speed network interfaces (e.g., SFPs)\nmakes modern FPGAs a good choice for implementing Smart-NICs. In this work, we\nextended the functionalities offered by an open-source NIC implementation\n(Corundum) by enabling time-aware traffic management in hardware, and using\nthis feature to control the bandwidth associated with different traffic\nclasses. By exposing dedicated control registers on the AXI bus, the driver of\nthe NIC can easily configure the transmission bandwidth of different\nprioritized queues. Basically, each control register is associated with a\nspecific transmission queue (Corundum can expose up to thousands of\ntransmission and receiving queues), and sets up the fraction of time in a\ntransmission window which the queue is supposed to get access the output port\nand transmit the packets. Queues are then prioritized and associated to\ndifferent traffic classes through the Linux QDISC mechanism. Experimental\nevaluation demonstrates that the approach allows to properly manage the\nbandwidth reserved to the different transmission flows."}
{"id": "2509.25555", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.25555", "abs": "https://arxiv.org/abs/2509.25555", "authors": ["Amirreza Sokhankhosh", "Khalid Hassan", "Sara Rouhani"], "title": "Enhancing Split Learning with Sharded and Blockchain-Enabled SplitFed Approaches", "comment": "Accepted by the 2025 IEEE International Conference on Blockchain\n  (Blockchain)", "summary": "Collaborative and distributed learning techniques, such as Federated Learning\n(FL) and Split Learning (SL), hold significant promise for leveraging sensitive\ndata in privacy-critical domains. However, FL and SL suffer from key\nlimitations -- FL imposes substantial computational demands on clients, while\nSL leads to prolonged training times. To overcome these challenges, SplitFed\nLearning (SFL) was introduced as a hybrid approach that combines the strengths\nof FL and SL. Despite its advantages, SFL inherits scalability, performance,\nand security issues from SL. In this paper, we propose two novel frameworks:\nSharded SplitFed Learning (SSFL) and Blockchain-enabled SplitFed Learning\n(BSFL). SSFL addresses the scalability and performance constraints of SFL by\ndistributing the workload and communication overhead of the SL server across\nmultiple parallel shards. Building upon SSFL, BSFL replaces the centralized\nserver with a blockchain-based architecture that employs a committee-driven\nconsensus mechanism to enhance fairness and security. BSFL incorporates an\nevaluation mechanism to exclude poisoned or tampered model updates, thereby\nmitigating data poisoning and model integrity attacks. Experimental evaluations\nagainst baseline SL and SFL approaches show that SSFL improves performance and\nscalability by 31.2% and 85.2%, respectively. Furthermore, BSFL increases\nresilience to data poisoning attacks by 62.7% while maintaining superior\nperformance under normal operating conditions. To the best of our knowledge,\nBSFL is the first blockchain-enabled framework to implement an end-to-end\ndecentralized SplitFed Learning system."}
{"id": "2509.25605", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.25605", "abs": "https://arxiv.org/abs/2509.25605", "authors": ["Brian Kelley", "Sivasankaran Rajamanickam"], "title": "LAPIS: A Performance Portable, High Productivity Compiler Framework", "comment": "14 pages (10 excluding references and appendices). 5 figures", "summary": "Portability, performance, and productivity are three critical dimensions for\nevaluating a programming model or compiler infrastructure. Several modern\nprogramming models for computational science focus on performance and\nportability. On the other end, several machine learning focused programming\nmodels focus on portability and productivity. A clear solution that is strong\nin all three dimensions has yet to emerge. A second related problem arises when\nuse cases from computational science converge with machine learning. The\ndisparate popular frameworks of these fields require programmers to manually\nintegrate codes written in different frameworks. Finally, several programming\nframeworks lack easy options for extensibility as any new computer architecture\nchange require complex changes to the programming models. We present LAPIS, an\nMLIR-based compiler that addresses all three of these challenges. We\ndemonstrate that LAPIS can automatically lower sparse and dense linear algebra\nkernels from computational science and artificial intelligence use cases. We\nalso show how LAPIS facilitates the integration of codes between PyTorch and\nKokkos. We compare kernel performance with the default MLIR implementations on\ndiverse architectures to demonstrate portability. By developing a dialect that\nis built on the principles of the Kokkos ecosystem, LAPIS also allows\nextensibility of the framework to new architectures."}
{"id": "2509.25700", "categories": ["cs.DC", "cs.GT", "cs.NI"], "pdf": "https://arxiv.org/pdf/2509.25700", "abs": "https://arxiv.org/abs/2509.25700", "authors": ["Houyi Qi", "Minghui Liwang", "Liqun Fu", "Sai Zou", "Xinlei Yi", "Wei Ni", "Huaiyu Dai"], "title": "PAST: Pilot and Adaptive Orchestration for Timely and Resilient Service Delivery in Edge-Assisted UAV Networks under Spatio-Temporal Dynamics", "comment": null, "summary": "Incentive-driven resource trading is essential for UAV applications with\nintensive, time-sensitive computing demands. Traditional spot trading suffers\nfrom negotiation delays and high energy costs, while conventional futures\ntrading struggles to adapt to the dynamic, uncertain UAV-edge environment. To\naddress these challenges, we propose PAST (pilot-and-adaptive stable trading),\na novel framework for edge-assisted UAV networks with spatio-temporal dynamism.\nPAST integrates two complementary mechanisms: PilotAO (pilot trading agreements\nwith overbooking), a risk-aware, overbooking-enabled early-stage\ndecision-making module that establishes long-term, mutually beneficial\nagreements and boosts resource utilization; and AdaptAO (adaptive trading\nagreements with overbooking rate update), an intelligent adaptation module that\ndynamically updates agreements and overbooking rates based on UAV mobility,\nsupply-demand variations, and agreement performance. Together, these mechanisms\nenable both stability and flexibility, guaranteeing individual rationality,\nstrong stability, competitive equilibrium, and weak Pareto optimality.\nExtensive experiments on real-world datasets show that PAST consistently\noutperforms benchmark methods in decision-making overhead, task completion\nlatency, resource utilization, and social welfare. By combining predictive\nplanning with real-time adjustments, PAST offers a valuable reference on robust\nand adaptive practice for improving low-altitude mission performance."}
{"id": "2509.25919", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.25919", "abs": "https://arxiv.org/abs/2509.25919", "authors": ["Jay H. Park", "Youngju Cho", "Choungsol Lee", "Moonwook Oh", "Euiseong Seo"], "title": "Accelerating LLM Inference with Precomputed Query Storage", "comment": null, "summary": "Large language model (LLM) inference often suffers from high latency,\nparticularly in resource-constrained environments such as on-device or edge\ndeployments. To address this challenge, we present StorInfer, a novel\nstorage-assisted LLM inference system that accelerates response time by\nprecomputing and storing predictable query-response pairs offline. When a user\nquery semantically matches a precomputed query, StorInfer bypasses expensive\nGPU inference and instantly returns the stored response, significantly reducing\nlatency and compute costs. To maximize coverage and effectiveness, StorInfer\nemploys an LLM-driven generator that adaptively produces diverse and\ndeduplicated queries based on a given knowledge base. This is achieved via two\ntechniques: adaptive query masking, which prevents regeneration of similar\nqueries, and adaptive sampling, which dynamically tunes generation parameters\nto promote semantic diversity. The resulting query-response pairs are embedded\nand indexed using a disk-backed vector database to enable fast,\nsimilarity-based retrieval at runtime. Using this approach, we generated 150K\nunique precomputed pairs (taking up to 830 MB of storage space), achieving up\nto 17.3% latency reduction with no loss in response quality. Our evaluation\nacross multiple QA datasets demonstrates the practicality and scalability of\nstorage-assisted inference, especially in scenarios with predictable query\ndistributions. StorInfer highlights a promising direction in leveraging storage\nas a primary enabler for efficient, low-latency LLM deployment."}
{"id": "2509.26043", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.26043", "abs": "https://arxiv.org/abs/2509.26043", "authors": ["Alberto Scionti", "Paolo Savio", "Francesco Lubrano", "Federico Stirano", "Antonino Nespola", "Olivier Terzo", "Corrado De Sio", "Luca Sterpone"], "title": "Enabling Time-Aware Priority Traffic Management over Distributed FPGA Nodes", "comment": null, "summary": "Network Interface Cards (NICs) greatly evolved from simple basic devices\nmoving traffic in and out of the network to complex heterogeneous systems\noffloading host CPUs from performing complex tasks on in-transit packets. These\nlatter comprise different types of devices, ranging from NICs accelerating\nfixed specific functions (e.g., on-the-fly data compression/decompression,\nchecksum computation, data encryption, etc.) to complex Systems-on-Chip (SoC)\nequipped with both general purpose processors and specialized engines\n(Smart-NICs). Similarly, Field Programmable Gate Arrays (FPGAs) moved from pure\nreprogrammable devices to modern heterogeneous systems comprising\ngeneral-purpose processors, real-time cores and even AI-oriented engines.\nFurthermore, the availability of high-speed network interfaces (e.g., SFPs)\nmakes modern FPGAs a good choice for implementing Smart-NICs. In this work, we\nextended the functionalities offered by an open-source NIC implementation\n(Corundum) by enabling time-aware traffic management in hardware, and using\nthis feature to control the bandwidth associated with different traffic\nclasses. By exposing dedicated control registers on the AXI bus, the driver of\nthe NIC can easily configure the transmission bandwidth of different\nprioritized queues. Basically, each control register is associated with a\nspecific transmission queue (Corundum can expose up to thousands of\ntransmission and receiving queues), and sets up the fraction of time in a\ntransmission window which the queue is supposed to get access the output port\nand transmit the packets. Queues are then prioritized and associated to\ndifferent traffic classes through the Linux QDISC mechanism. Experimental\nevaluation demonstrates that the approach allows to properly manage the\nbandwidth reserved to the different transmission flows."}
{"id": "2509.26092", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.26092", "abs": "https://arxiv.org/abs/2509.26092", "authors": ["Kuan-Wei Lu", "Ding-Yong Hong", "Pangfeng Liu", "Jan-Jan Wu"], "title": "Efficient Distributed Training via Dual Batch Sizes and Cyclic Progressive Learning", "comment": null, "summary": "Distributed machine learning is critical for training deep learning models on\nlarge datasets and with numerous parameters. Current research primarily focuses\non leveraging additional hardware resources and powerful computing units to\naccelerate the training process. As a result, larger batch sizes are often\nemployed to speed up training. However, training with large batch sizes can\nlead to lower accuracy due to poor generalization. To address this issue, we\npropose the dual batch size learning scheme, a distributed training method\nbuilt on the parameter server framework. This approach maximizes training\nefficiency by utilizing the largest batch size that the hardware can support\nwhile incorporating a smaller batch size to enhance model generalization. By\nusing two different batch sizes simultaneously, this method reduces testing\nloss and enhances generalization, with minimal extra training time.\nAdditionally, to mitigate the time overhead caused by dual batch size learning,\nwe propose the cyclic progressive learning scheme. This technique gradually\nadjusts image resolution from low to high during training, significantly\nboosting training speed. By combining cyclic progressive learning with dual\nbatch size learning, our hybrid approach improves both model generalization and\ntraining efficiency. Experimental results using ResNet-18 show that, compared\nto conventional training methods, our method can improve accuracy by 3.3% while\nreducing training time by 10.6% on CIFAR-100, and improve accuracy by 0.1%\nwhile reducing training time by 35.7% on ImageNet."}
{"id": "2509.26120", "categories": ["cs.DC", "cs.AI", "cs.PF"], "pdf": "https://arxiv.org/pdf/2509.26120", "abs": "https://arxiv.org/abs/2509.26120", "authors": ["Leszek Sliwko", "Vladimir Getov"], "title": "AGOCS -- Accurate Google Cloud Simulator Framework", "comment": "This is the accepted author's version of the paper. The final\n  published version is available in the Proceedings of the 2016 IEEE\n  International Conferences on Ubiquitous Intelligence and Computing (UIC),\n  Advanced and Trusted Computing (ATC), Scalable Computing and Communications\n  (ScalCom), Cloud and Big Data Computing (CBDCom), Internet of People (IoP),\n  and Smart World Congress (SmartWorld)", "summary": "This paper presents the Accurate Google Cloud Simulator (AGOCS) - a novel\nhigh-fidelity Cloud workload simulator based on parsing real workload traces,\nwhich can be conveniently used on a desktop machine for day-to-day research.\nOur simulation is based on real-world workload traces from a Google Cluster\nwith 12.5K nodes, over a period of a calendar month. The framework is able to\nreveal very precise and detailed parameters of the executed jobs, tasks and\nnodes as well as to provide actual resource usage statistics. The system has\nbeen implemented in Scala language with focus on parallel execution and an\neasy-to-extend design concept. The paper presents the detailed structural\nframework for AGOCS and discusses our main design decisions, whilst also\nsuggesting alternative and possibly performance enhancing future approaches.\nThe framework is available via the Open Source GitHub repository."}
{"id": "2509.26182", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.26182", "abs": "https://arxiv.org/abs/2509.26182", "authors": ["Chris Tong", "Youhe Jiang", "Gufeng Chen", "Tianyi Zhao", "Sibian Lu", "Wenjie Qu", "Eric Yang", "Lynn Ai", "Binhang Yuan"], "title": "Parallax: Efficient LLM Inference Service over Decentralized Environment", "comment": null, "summary": "Deploying a large language model (LLM) inference service remains costly\nbecause centralized serving depends on specialized GPU clusters and\nhigh-bandwidth interconnects in datacenters. An appealing alternative is to\nleverage collaborative decentralized GPU pools. However, heterogeneity in GPU\nand limited interconnected network bandwidth, along with potentially dynamic\navailability, make efficient scheduling the central challenge in this scenario.\nIn this paper, we present Parallax, a decentralized LLM serving system that\nturns a pool of heterogeneous GPUs into an efficient inference platform via a\ntwo-phase scheduler. Parallax decomposes planning into (i) model allocation,\nwhich places layers of each replica across diverse GPUs to jointly optimize\nlatency and throughput under memory and link-bandwidth constraints, and (ii)\nrequest-time GPU pipeline selection, which stitches layers from different\nreplicas into end-to-end execution chains that balance load and adapt to\ncurrent conditions. We implement Parallax and evaluate it on open-source LLMs\ndeployed over real volunteer nodes. Parallax consistently reduces latency and\nincreases throughput relative to decentralized baselines, demonstrating that\nprincipled scheduling can make volunteer compute a practical, affordable\nsubstrate for LLM inference.\n  Github Repo at: https://github.com/GradientHQ/parallax."}
{"id": "2509.26193", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2509.26193", "abs": "https://arxiv.org/abs/2509.26193", "authors": ["Fabian Czappa", "Marvin Kaster", "Felix Wolf"], "title": "I Like To Move It -- Computation Instead of Data in the Brain", "comment": null, "summary": "The detailed functioning of the human brain is still poorly understood. Brain\nsimulations are a well-established way to complement experimental research, but\nmust contend with the computational demands of the approximately $10^{11}$\nneurons and the $10^{14}$ synapses connecting them, the network of the latter\nreferred to as the connectome. Studies suggest that changes in the connectome\n(i.e., the formation and deletion of synapses, also known as structural\nplasticity) are essential for critical tasks such as memory formation and\nlearning. The connectivity update can be efficiently computed using a\nBarnes-Hut-inspired approximation that lowers the computational complexity from\n$O(n^2)$ to $O(n log n)$, where n is the number of neurons. However, updating\nsynapses, which relies heavily on RMA, and the spike exchange between neurons,\nwhich requires all-to-all communication at every time step, still hinder\nscalability. We present a new algorithm that significantly reduces the\ncommunication overhead by moving computation instead of data. This shrinks the\ntime it takes to update connectivity by a factor of six and the time it takes\nto exchange spikes by more than two orders of magnitude."}
{"id": "2509.26253", "categories": ["cs.DC", "cs.PF", "C.4; I.m; I.2.8"], "pdf": "https://arxiv.org/pdf/2509.26253", "abs": "https://arxiv.org/abs/2509.26253", "authors": ["Floris-Jan Willemsen", "Rob V. van Nieuwpoort", "Ben van Werkhoven"], "title": "Efficient Construction of Large Search Spaces for Auto-Tuning", "comment": null, "summary": "Automatic performance tuning, or auto-tuning, accelerates high-performance\ncodes by exploring vast spaces of code variants. However, due to the large\nnumber of possible combinations and complex constraints, constructing these\nsearch spaces can be a major bottleneck. Real-world applications have been\nencountered where the search space construction takes minutes to hours or even\ndays. Current state-of-the-art techniques for search space construction, such\nas chain-of-trees, lack a formal foundation and only perform adequately on a\nspecific subset of search spaces.\n  We show that search space construction for constraint-based auto-tuning can\nbe reformulated as a Constraint Satisfaction Problem (CSP). Building on this\ninsight with a CSP solver, we develop a runtime parser that translates\nuser-defined constraint functions into solver-optimal expressions, optimize the\nsolver to exploit common structures in auto-tuning constraints, and integrate\nthese and other advances in open-source tools. These contributions\nsubstantially improve performance and accessibility while preserving\nflexibility.\n  We evaluate our approach using a diverse set of benchmarks, demonstrating\nthat our optimized solver reduces construction time by four orders of magnitude\nversus brute-force enumeration, three orders of magnitude versus an unoptimized\nCSP solver, and one to two orders of magnitude versus leading auto-tuning\nframeworks built on chain-of-trees. We thus eliminate a critical scalability\nbarrier for auto-tuning and provide a drop-in solution that enables the\nexploration of previously unattainable problem scales in auto-tuning and\nrelated domains."}
{"id": "2509.26529", "categories": ["cs.DC", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.26529", "abs": "https://arxiv.org/abs/2509.26529", "authors": ["Shangshu Qian", "Lin Tan", "Yongle Zhang"], "title": "CSnake: Detecting Self-Sustaining Cascading Failure via Causal Stitching of Fault Propagations", "comment": "Accepted by EuroSys 2026", "summary": "Recent studies have revealed that self-sustaining cascading failures in\ndistributed systems frequently lead to widespread outages, which are\nchallenging to contain and recover from. Existing failure detection techniques\nstruggle to expose such failures prior to deployment, as they typically require\na complex combination of specific conditions to be triggered. This challenge\nstems from the inherent nature of cascading failures, as they typically involve\na sequence of fault propagations, each activated by distinct conditions.\n  This paper presents CSnake, a fault injection framework to expose\nself-sustaining cascading failures in distributed systems. CSnake uses the\nnovel idea of causal stitching, which causally links multiple single-fault\ninjections in different tests to simulate complex fault propagation chains. To\nidentify these chains, CSnake designs a counterfactual causality analysis of\nfault propagations - fault causality analysis (FCA): FCA compares the execution\ntrace of a fault injection run with its corresponding profile run (i.e., same\ntest w/o the injection) and identifies any additional faults triggered, which\nare considered to have a causal relationship with the injected fault.\n  To address the large search space of fault and workload combinations, CSnake\nemploys a three-phase allocation protocol of test budget that prioritizes\nfaults with unique and diverse causal consequences, increasing the likelihood\nof uncovering conditional fault propagations. Furthermore, to avoid incorrectly\nconnecting fault propagations from workloads with incompatible conditions,\nCSnake performs a local compatibility check that approximately checks the\ncompatibility of the path constraints associated with connected fault\npropagations with low overhead.\n  CSnake detected 15 bugs that cause self-sustaining cascading failures in five\nsystems, five of which have been confirmed with two fixed."}
