{"id": "2601.09114", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.09114", "abs": "https://arxiv.org/abs/2601.09114", "authors": ["Yufan Xia", "Marco De La Pierre", "Amanda S. Barnard", "Giuseppe Maria Junior Barca"], "title": "A Machine Learning Approach Towards Runtime Optimisation of Matrix Multiplication", "comment": "2023 IEEE International Parallel and Distributed Processing Symposium (IPDPS)", "summary": "The GEneral Matrix Multiplication (GEMM) is one of the essential algorithms in scientific computing. Single-thread GEMM implementations are well-optimised with techniques like blocking and autotuning. However, due to the complexity of modern multi-core shared memory systems, it is challenging to determine the number of threads that minimises the multi-thread GEMM runtime. We present a proof-of-concept approach to building an Architecture and Data-Structure Aware Linear Algebra (ADSALA) software library that uses machine learning to optimise the runtime performance of BLAS routines. More specifically, our method uses a machine learning model on-the-fly to automatically select the optimal number of threads for a given GEMM task based on the collected training data. Test results on two different HPC node architectures, one based on a two-socket Intel Cascade Lake and the other on a two-socket AMD Zen 3, revealed a 25 to 40 per cent speedup compared to traditional GEMM implementations in BLAS when using GEMM of memory usage within 100 MB.", "AI": {"tldr": "\u4f7f\u7528\u673a\u5668\u5b66\u4e60\u52a8\u6001\u9009\u62e9\u6700\u4f18\u7ebf\u7a0b\u6570\u4ee5\u4f18\u5316GEMM\u6027\u80fd\uff0c\u5728\u4e24\u79cdHPC\u67b6\u6784\u4e0a\u5b9e\u73b025-40%\u52a0\u901f", "motivation": "\u73b0\u4ee3\u591a\u6838\u5171\u4eab\u5185\u5b58\u7cfb\u7edf\u590d\u6742\uff0c\u96be\u4ee5\u786e\u5b9a\u6700\u5c0f\u5316\u591a\u7ebf\u7a0bGEMM\u8fd0\u884c\u65f6\u7684\u7ebf\u7a0b\u6570\uff0c\u9700\u8981\u667a\u80fd\u4f18\u5316\u65b9\u6cd5", "method": "\u6784\u5efaADSALA\u8f6f\u4ef6\u5e93\uff0c\u4f7f\u7528\u673a\u5668\u5b66\u4e60\u6a21\u578b\u5b9e\u65f6\u6839\u636e\u8bad\u7ec3\u6570\u636e\u4e3a\u7ed9\u5b9aGEMM\u4efb\u52a1\u81ea\u52a8\u9009\u62e9\u6700\u4f18\u7ebf\u7a0b\u6570", "result": "\u5728Intel Cascade Lake\u548cAMD Zen 3\u4e24\u79cdHPC\u8282\u70b9\u67b6\u6784\u4e0a\u6d4b\u8bd5\uff0c\u5185\u5b58\u4f7f\u7528100MB\u5185\u7684GEMM\u76f8\u6bd4\u4f20\u7edfBLAS\u5b9e\u73b0\u83b7\u5f9725-40%\u52a0\u901f", "conclusion": "\u673a\u5668\u5b66\u4e60\u65b9\u6cd5\u80fd\u6709\u6548\u4f18\u5316GEMM\u6027\u80fd\uff0c\u8bc1\u660eADSALA\u6982\u5ff5\u53ef\u884c\uff0c\u4e3a\u7ebf\u6027\u4ee3\u6570\u5e93\u4f18\u5316\u63d0\u4f9b\u65b0\u65b9\u5411"}}
{"id": "2601.09146", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2601.09146", "abs": "https://arxiv.org/abs/2601.09146", "authors": ["Lingkang Shangguan"], "title": "Transaction-Driven Dynamic Reconfiguration for Certificate-Based Payment Systems", "comment": "draft initial version", "summary": "We present a transaction-driven dynamic reconfiguration protocol in Modern payment systems based on Byzantine Consistent Broadcast which can achieve high performance by avoiding global transaction ordering. We demonstrate the fundamental paradigm of modern payment systems, which combines user nonce based transactions ordering with periodic system-wide consensus mechanisms. Building on this foundation, we design PDCC(Payment Dynamic Config Change), which can lead a smooth reconfiguration process without impacting the original system's performance.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u62dc\u5360\u5ead\u4e00\u81f4\u6027\u5e7f\u64ad\u7684\u4ea4\u6613\u9a71\u52a8\u52a8\u6001\u91cd\u914d\u7f6e\u534f\u8baePDCC\uff0c\u901a\u8fc7\u907f\u514d\u5168\u5c40\u4ea4\u6613\u6392\u5e8f\u5b9e\u73b0\u9ad8\u6027\u80fd\u652f\u4ed8\u7cfb\u7edf", "motivation": "\u73b0\u4ee3\u652f\u4ed8\u7cfb\u7edf\u9700\u8981\u9ad8\u6027\u80fd\u7684\u52a8\u6001\u91cd\u914d\u7f6e\u80fd\u529b\uff0c\u540c\u65f6\u907f\u514d\u4f20\u7edf\u5168\u5c40\u4ea4\u6613\u6392\u5e8f\u5e26\u6765\u7684\u6027\u80fd\u74f6\u9888", "method": "\u57fa\u4e8e\u62dc\u5360\u5ead\u4e00\u81f4\u6027\u5e7f\u64ad\uff0c\u7ed3\u5408\u7528\u6237nonce\u7684\u4ea4\u6613\u6392\u5e8f\u548c\u5468\u671f\u6027\u7cfb\u7edf\u8303\u56f4\u5171\u8bc6\u673a\u5236\uff0c\u8bbe\u8ba1PDCC\u534f\u8bae\u5b9e\u73b0\u5e73\u6ed1\u91cd\u914d\u7f6e", "result": "PDCC\u80fd\u591f\u5728\u4e0d\u5f71\u54cd\u539f\u7cfb\u7edf\u6027\u80fd\u7684\u60c5\u51b5\u4e0b\u5b9e\u73b0\u5e73\u6ed1\u7684\u91cd\u914d\u7f6e\u8fc7\u7a0b", "conclusion": "\u4ea4\u6613\u9a71\u52a8\u7684\u52a8\u6001\u91cd\u914d\u7f6e\u534f\u8bae\u4e3a\u73b0\u4ee3\u652f\u4ed8\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ad8\u6027\u80fd\u7684\u91cd\u914d\u7f6e\u89e3\u51b3\u65b9\u6848\uff0c\u907f\u514d\u4e86\u5168\u5c40\u6392\u5e8f\u7684\u5f00\u9500"}}
{"id": "2601.09184", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2601.09184", "abs": "https://arxiv.org/abs/2601.09184", "authors": ["Yifei Xie", "Btissam Er-Rahmadi", "Xiao Chen", "Tiejun Ma", "Jane Hillston"], "title": "Optimizing View Change for Byzantine Fault Tolerance in Parallel Consensus", "comment": null, "summary": "The parallel Byzantine Fault Tolerant (BFT) protocol is viewed as a promising solution to address the consensus scalability issue of the permissioned blockchain. One of the main challenges in parallel BFT is the view change process that happens when the leader node fails, which can lead to performance bottlenecks. Existing parallel BFT protocols typically rely on passive view change mechanisms with blind leader rotation. Such approaches frequently select unavailable or slow nodes as leaders, resulting in degraded performance. To address these challenges, we propose a View Change Optimization (VCO) model based on mixed integer programming that optimizes leader selection and follower reassignment across parallel committees by considering communication delays and failure scenarios. We applied a decomposition method with efficient subproblems and improved benders cuts to solve the VCO model. Leveraging the results of improved decomposition solution method, we propose an efficient iterative backup leader selection algorithm as views proceed. By performing experiments in Microsoft Azure cloud environments, we demonstrate that the VCO-driven parallel BFT outperforms existing configuration methods under both normal operation and faulty condition. The results show that the VCO model is effective as network size increases, making it a suitable solution for high-performance parallel BFT systems.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u6df7\u5408\u6574\u6570\u89c4\u5212\u7684\u89c6\u56fe\u53d8\u66f4\u4f18\u5316\u6a21\u578b\uff0c\u901a\u8fc7\u4f18\u5316\u9886\u5bfc\u8005\u9009\u62e9\u548c\u8ffd\u968f\u8005\u91cd\u65b0\u5206\u914d\u6765\u63d0\u5347\u5e76\u884cBFT\u534f\u8bae\u6027\u80fd", "motivation": "\u73b0\u6709\u5e76\u884cBFT\u534f\u8bae\u7684\u89c6\u56fe\u53d8\u66f4\u673a\u5236\u91c7\u7528\u88ab\u52a8\u76f2\u9009\u9886\u5bfc\u8005\uff0c\u7ecf\u5e38\u9009\u62e9\u4e0d\u53ef\u7528\u6216\u6162\u901f\u8282\u70b9\u4f5c\u4e3a\u9886\u5bfc\u8005\uff0c\u5bfc\u81f4\u6027\u80fd\u4e0b\u964d\uff0c\u9700\u8981\u4f18\u5316\u9886\u5bfc\u8005\u9009\u62e9\u7b56\u7565", "method": "\u63d0\u51fa\u57fa\u4e8e\u6df7\u5408\u6574\u6570\u89c4\u5212\u7684\u89c6\u56fe\u53d8\u66f4\u4f18\u5316\u6a21\u578b\uff0c\u91c7\u7528\u5206\u89e3\u65b9\u6cd5\u5904\u7406\u9ad8\u6548\u5b50\u95ee\u9898\u5e76\u6539\u8fdbBenders\u5272\uff0c\u57fa\u4e8e\u5206\u89e3\u7ed3\u679c\u8bbe\u8ba1\u8fed\u4ee3\u5907\u4efd\u9886\u5bfc\u8005\u9009\u62e9\u7b97\u6cd5", "result": "\u5728\u5fae\u8f6fAzure\u4e91\u73af\u5883\u4e2d\u5b9e\u9a8c\u8868\u660e\uff0cVCO\u9a71\u52a8\u7684\u5e76\u884cBFT\u5728\u6b63\u5e38\u8fd0\u884c\u548c\u6545\u969c\u6761\u4ef6\u4e0b\u5747\u4f18\u4e8e\u73b0\u6709\u914d\u7f6e\u65b9\u6cd5\uff0c\u4e14\u968f\u7740\u7f51\u7edc\u89c4\u6a21\u589e\u5927\u6548\u679c\u66f4\u663e\u8457", "conclusion": "VCO\u6a21\u578b\u80fd\u6709\u6548\u4f18\u5316\u5e76\u884cBFT\u7684\u89c6\u56fe\u53d8\u66f4\u8fc7\u7a0b\uff0c\u4e3a\u9ad8\u6027\u80fd\u5e76\u884cBFT\u7cfb\u7edf\u63d0\u4f9b\u5408\u9002\u89e3\u51b3\u65b9\u6848"}}
{"id": "2601.09002", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2601.09002", "abs": "https://arxiv.org/abs/2601.09002", "authors": ["Peter M. Kogge"], "title": "Annotated PIM Bibliography", "comment": "Initial version. Will be updated with more references and detail in future releases", "summary": "Processing in Memory (PIM) and similar terms such as Compute In Memory (CIM), Logic in Memory (LIM), In Memory Computing (IMC), and Near Memory Computing (NMC) have gained attention recently as a potentially ``revolutionary new'' technique. The truth, however, is that many examples of the technology go back over 60 years. This document attempts to provide an annotated bibliography of PIM technology that attempts to cover the whole time-frame, and is organized to augment a forth-coming article.", "AI": {"tldr": "\u672c\u6587\u63d0\u4f9b\u4e86\u4e00\u4efd\u5173\u4e8e\u5185\u5b58\u5904\u7406\uff08PIM\uff09\u6280\u672f\u7684\u6ce8\u91ca\u4e66\u76ee\uff0c\u6db5\u76d6\u517660\u591a\u5e74\u7684\u53d1\u5c55\u5386\u53f2\uff0c\u65e8\u5728\u8865\u5145\u5373\u5c06\u53d1\u8868\u7684\u6587\u7ae0\u3002", "motivation": "\u867d\u7136\u5185\u5b58\u5904\u7406\uff08PIM\uff09\u53ca\u76f8\u5173\u6280\u672f\u6700\u8fd1\u88ab\u89c6\u4e3a\"\u9769\u547d\u6027\u65b0\u6280\u672f\"\uff0c\u4f46\u5b9e\u9645\u4e0a\u8bb8\u591a\u76f8\u5173\u6280\u672f\u53ef\u4ee5\u8ffd\u6eaf\u523060\u591a\u5e74\u524d\u3002\u672c\u6587\u65e8\u5728\u63d0\u4f9b\u4e00\u4e2a\u5168\u9762\u7684\u6ce8\u91ca\u4e66\u76ee\uff0c\u8986\u76d6\u6574\u4e2a\u65f6\u95f4\u8303\u56f4\uff0c\u4ee5\u7ea0\u6b63\u4eba\u4eec\u5bf9PIM\u6280\u672f\u5386\u53f2\u53d1\u5c55\u7684\u8bef\u89e3\u3002", "method": "\u4f5c\u8005\u901a\u8fc7\u6574\u7406\u548c\u6ce8\u91caPIM\u6280\u672f\u76f8\u5173\u7684\u6587\u732e\u8d44\u6599\uff0c\u521b\u5efa\u4e86\u4e00\u4e2a\u6309\u65f6\u95f4\u987a\u5e8f\u7ec4\u7ec7\u7684\u6ce8\u91ca\u4e66\u76ee\u3002\u8be5\u4e66\u76ee\u6db5\u76d6\u4e86PIM\u3001CIM\u3001LIM\u3001IMC\u3001NMC\u7b49\u4e0d\u540c\u672f\u8bed\u4e0b\u7684\u76f8\u5173\u6280\u672f\u53d1\u5c55\u3002", "result": "\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5168\u9762\u7684PIM\u6280\u672f\u5386\u53f2\u53d1\u5c55\u6ce8\u91ca\u4e66\u76ee\uff0c\u5c55\u793a\u4e86\u8be5\u6280\u672f\u4ece60\u591a\u5e74\u524d\u81f3\u4eca\u7684\u6f14\u53d8\u8fc7\u7a0b\uff0c\u63ed\u793a\u4e86PIM\u5e76\u975e\u5168\u65b0\u6982\u5ff5\u800c\u662f\u6709\u6df1\u539a\u5386\u53f2\u6e0a\u6e90\u3002", "conclusion": "\u5185\u5b58\u5904\u7406\u6280\u672f\u6709\u7740\u60a0\u4e45\u7684\u5386\u53f2\u6e0a\u6e90\uff0c\u800c\u975e\u6700\u8fd1\u624d\u51fa\u73b0\u7684\u9769\u547d\u6027\u521b\u65b0\u3002\u901a\u8fc7\u63d0\u4f9b\u5168\u9762\u7684\u5386\u53f2\u89c6\u89d2\uff0c\u672c\u6587\u6709\u52a9\u4e8e\u66f4\u51c6\u786e\u5730\u7406\u89e3PIM\u6280\u672f\u7684\u53d1\u5c55\u8109\u7edc\u548c\u6f14\u53d8\u8fc7\u7a0b\u3002"}}
{"id": "2601.09258", "categories": ["cs.DC", "cs.LG", "cs.OS"], "pdf": "https://arxiv.org/pdf/2601.09258", "abs": "https://arxiv.org/abs/2601.09258", "authors": ["Du Yin", "Jiayi Ren", "Xiayu Sun", "Tianyao Zhou", "Haizhu Zhou", "Ruiyan Ma", "Danyang Zhang"], "title": "LatencyPrism: Online Non-intrusive Latency Sculpting for SLO-Guaranteed LLM Inference", "comment": "12 pages, 6 figures", "summary": "LLM inference latency critically determines user experience and operational costs, directly impacting throughput under SLO constraints. Even brief latency spikes degrade service quality despite acceptable average performance. However, distributed inference environments featuring diverse software frameworks and XPU architectures combined with dynamic workloads make latency analysis challenging. Constrained by intrusive designs that necessitate service restarts or even suspension, and by hardware-bound implementations that fail to adapt to heterogeneous inference environments, existing AI profiling methods are often inadequate for real-time production analysis.\n  We present LatencyPrism, the first zero-intrusion multi-platform latency sculpting system. It aims to break down the inference latency across pipeline, proactively alert on inference latency anomalies, and guarantee adherence to SLOs, all without requiring code modifications or service restarts. LatencyPrism has been deployed across thousands of XPUs for over six months. It enables low-overhead real-time monitoring at batch level with alerts triggered in milliseconds. This approach distinguishes between workload-driven latency variations and anomalies indicating underlying issues with an F1-score of 0.98. We also conduct extensive experiments and investigations into root cause analysis to demonstrate LatencyPrism's capability.", "AI": {"tldr": "LatencyPrism\u662f\u4e00\u4e2a\u96f6\u4fb5\u5165\u3001\u591a\u5e73\u53f0\u7684\u5ef6\u8fdf\u96d5\u523b\u7cfb\u7edf\uff0c\u7528\u4e8e\u5b9e\u65f6\u76d1\u63a7\u548c\u5206\u6790LLM\u63a8\u7406\u5ef6\u8fdf\uff0c\u65e0\u9700\u4ee3\u7801\u4fee\u6539\u6216\u670d\u52a1\u91cd\u542f\uff0c\u80fd\u533a\u5206\u6b63\u5e38\u5ef6\u8fdf\u53d8\u5316\u4e0e\u5f02\u5e38\uff0c\u51c6\u786e\u7387\u8fbe0.98 F1-score\u3002", "motivation": "LLM\u63a8\u7406\u5ef6\u8fdf\u76f4\u63a5\u5f71\u54cd\u7528\u6237\u4f53\u9a8c\u548c\u8fd0\u8425\u6210\u672c\uff0c\u5206\u5e03\u5f0f\u63a8\u7406\u73af\u5883\u7684\u8f6f\u4ef6\u6846\u67b6\u548c\u786c\u4ef6\u67b6\u6784\u591a\u6837\u6027\uff0c\u52a0\u4e0a\u52a8\u6001\u5de5\u4f5c\u8d1f\u8f7d\uff0c\u4f7f\u5f97\u5ef6\u8fdf\u5206\u6790\u53d8\u5f97\u56f0\u96be\u3002\u73b0\u6709AI\u5206\u6790\u65b9\u6cd5\u8981\u4e48\u9700\u8981\u4fb5\u5165\u6027\u8bbe\u8ba1\uff08\u9700\u8981\u670d\u52a1\u91cd\u542f\u6216\u6682\u505c\uff09\uff0c\u8981\u4e48\u786c\u4ef6\u7ed1\u5b9a\u65e0\u6cd5\u9002\u5e94\u5f02\u6784\u73af\u5883\uff0c\u4e0d\u9002\u5408\u5b9e\u65f6\u751f\u4ea7\u5206\u6790\u3002", "method": "LatencyPrism\u91c7\u7528\u96f6\u4fb5\u5165\u591a\u5e73\u53f0\u5ef6\u8fdf\u96d5\u523b\u7cfb\u7edf\uff0c\u65e0\u9700\u4ee3\u7801\u4fee\u6539\u6216\u670d\u52a1\u91cd\u542f\u3002\u7cfb\u7edf\u80fd\u591f\u5206\u89e3\u63a8\u7406\u5ef6\u8fdf\u8de8\u6d41\u6c34\u7ebf\uff0c\u4e3b\u52a8\u9884\u8b66\u63a8\u7406\u5ef6\u8fdf\u5f02\u5e38\uff0c\u5e76\u4fdd\u8bc1SLO\u9075\u5b88\u3002\u652f\u6301\u4f4e\u5f00\u9500\u7684\u6279\u7ea7\u522b\u5b9e\u65f6\u76d1\u63a7\uff0c\u6beb\u79d2\u7ea7\u89e6\u53d1\u8b66\u62a5\u3002", "result": "\u5df2\u5728\u6570\u5343\u4e2aXPU\u4e0a\u90e8\u7f72\u8d85\u8fc7\u516d\u4e2a\u6708\uff0c\u80fd\u591f\u4ee5\u6beb\u79d2\u7ea7\u89e6\u53d1\u8b66\u62a5\u8fdb\u884c\u5b9e\u65f6\u76d1\u63a7\u3002\u7cfb\u7edf\u80fd\u533a\u5206\u5de5\u4f5c\u8d1f\u8f7d\u9a71\u52a8\u7684\u5ef6\u8fdf\u53d8\u5316\u4e0e\u6307\u793a\u6f5c\u5728\u95ee\u9898\u7684\u5f02\u5e38\uff0cF1-score\u8fbe\u52300.98\u3002\u901a\u8fc7\u5e7f\u6cdb\u5b9e\u9a8c\u548c\u6839\u672c\u539f\u56e0\u5206\u6790\u9a8c\u8bc1\u4e86\u7cfb\u7edf\u80fd\u529b\u3002", "conclusion": "LatencyPrism\u662f\u9996\u4e2a\u96f6\u4fb5\u5165\u591a\u5e73\u53f0\u5ef6\u8fdf\u96d5\u523b\u7cfb\u7edf\uff0c\u6210\u529f\u89e3\u51b3\u4e86\u5206\u5e03\u5f0fLLM\u63a8\u7406\u73af\u5883\u4e2d\u7684\u5ef6\u8fdf\u76d1\u63a7\u548c\u5206\u6790\u6311\u6218\uff0c\u65e0\u9700\u4fee\u6539\u4ee3\u7801\u6216\u91cd\u542f\u670d\u52a1\uff0c\u5728\u771f\u5b9e\u751f\u4ea7\u73af\u5883\u4e2d\u8868\u73b0\u51fa\u8272\u3002"}}
{"id": "2601.09217", "categories": ["cs.PL", "cs.AR"], "pdf": "https://arxiv.org/pdf/2601.09217", "abs": "https://arxiv.org/abs/2601.09217", "authors": ["Izumi Tanaka", "Ken Sakayori", "Shinya Takamaeda-Yamazaki", "Naoki Kobayashi"], "title": "Relational Hoare Logic for High-Level Synthesis of Hardware Accelerators", "comment": "An extended version of the paper to appear in Proceedings of ESOP 2026", "summary": "High-level synthesis (HLS) is a powerful tool for developing efficient hardware accelerators that rely on specialized memory systems to achieve sufficient on-chip data reuse and off-chip bandwidth utilization. However, even with HLS, designing such systems still requires careful manual tuning, as automatic optimizations provided by existing tools are highly sensitive to programming style and often lack transparency. To address these issues, we present a formal translation framework based on relational Hoare logic, which enables robust and transparent transformations. Our method recognizes complex memory access patterns in na\u00efve HLS programs and automatically transforms them by inserting on-chip buffers to enforce linear access to off-chip memory, and by replacing non-sequential processing with stream processing, while preserving program semantics. Experiments using our prototype translator, combined with an off-the-shelf HLS compiler and a real FPGA board, have demonstrated significant performance improvements.", "AI": {"tldr": "\u63d0\u51fa\u57fa\u4e8e\u5173\u7cfbHoare\u903b\u8f91\u7684\u5f62\u5f0f\u5316\u7ffb\u8bd1\u6846\u67b6\uff0c\u81ea\u52a8\u4f18\u5316HLS\u7a0b\u5e8f\u4e2d\u7684\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u901a\u8fc7\u63d2\u5165\u7247\u4e0a\u7f13\u51b2\u548c\u6d41\u5904\u7406\u66ff\u6362\u975e\u987a\u5e8f\u5904\u7406\uff0c\u663e\u8457\u63d0\u5347\u6027\u80fd\u3002", "motivation": "\u73b0\u6709HLS\u5de5\u5177\u7684\u5185\u5b58\u81ea\u52a8\u4f18\u5316\u5bf9\u7f16\u7a0b\u98ce\u683c\u654f\u611f\u4e14\u7f3a\u4e4f\u900f\u660e\u5ea6\uff0c\u9700\u8981\u5927\u91cf\u624b\u52a8\u8c03\u4f18\uff0c\u96be\u4ee5\u8bbe\u8ba1\u9ad8\u6548\u7684\u5185\u5b58\u7cfb\u7edf\u3002", "method": "\u57fa\u4e8e\u5173\u7cfbHoare\u903b\u8f91\u7684\u5f62\u5f0f\u5316\u7ffb\u8bd1\u6846\u67b6\uff0c\u8bc6\u522b\u6734\u7d20HLS\u7a0b\u5e8f\u4e2d\u7684\u590d\u6742\u5185\u5b58\u8bbf\u95ee\u6a21\u5f0f\uff0c\u81ea\u52a8\u63d2\u5165\u7247\u4e0a\u7f13\u51b2\u4ee5\u5f3a\u5236\u7ebf\u6027\u8bbf\u95ee\u5916\u90e8\u5185\u5b58\uff0c\u5e76\u7528\u6d41\u5904\u7406\u66ff\u6362\u975e\u987a\u5e8f\u5904\u7406\u3002", "result": "\u539f\u578b\u7ffb\u8bd1\u5668\u7ed3\u5408\u5546\u7528HLS\u7f16\u8bd1\u5668\u548c\u771f\u5b9eFPGA\u677f\u8fdb\u884c\u5b9e\u9a8c\uff0c\u5c55\u793a\u4e86\u663e\u8457\u7684\u6027\u80fd\u63d0\u5347\u3002", "conclusion": "\u63d0\u51fa\u7684\u5f62\u5f0f\u5316\u6846\u67b6\u80fd\u591f\u5b9e\u73b0\u7a33\u5065\u900f\u660e\u7684\u7a0b\u5e8f\u8f6c\u6362\uff0c\u6709\u6548\u89e3\u51b3HLS\u4e2d\u5185\u5b58\u7cfb\u7edf\u8bbe\u8ba1\u7684\u81ea\u52a8\u5316\u4f18\u5316\u95ee\u9898\u3002"}}
{"id": "2601.09334", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2601.09334", "abs": "https://arxiv.org/abs/2601.09334", "authors": ["Valerio Besozzi", "Matteo Della Bartola", "Patrizio Dazzi", "Marco Danelutto"], "title": "High-Performance Serverless Computing: A Systematic Literature Review on Serverless for HPC, AI, and Big Data", "comment": null, "summary": "The widespread deployment of large-scale, compute-intensive applications such as high-performance computing, artificial intelligence, and big data is leading to convergence between cloud and high-performance computing infrastructures. Cloud providers are increasingly integrating high-performance computing capabilities in their infrastructures, such as hardware accelerators and high-speed interconnects, while researchers in the high-performance computing community are starting to explore cloud-native paradigms to improve scalability, elasticity, and resource utilization. In this context, serverless computing emerges as a promising execution model to efficiently handle highly dynamic, parallel, and distributed workloads. This paper presents a comprehensive systematic literature review of 122 research articles published between 2018 and early 2025, exploring the use of the serverless paradigm to develop, deploy, and orchestrate compute-intensive applications across cloud, high-performance computing, and hybrid environments. From these, a taxonomy comprising eight primary research directions and nine targeted use case domains is proposed, alongside an analysis of recent publication trends and collaboration networks among authors, highlighting the growing interest and interconnections within this emerging research field. Overall, this work aims to offer a valuable foundation for both new researchers and experienced practitioners, guiding the development of next-generation serverless solutions for parallel compute-intensive applications.", "AI": {"tldr": "\u672c\u6587\u5bf92018-2025\u5e74\u95f4122\u7bc7\u7814\u7a76\u8bba\u6587\u8fdb\u884c\u7cfb\u7edf\u6027\u6587\u732e\u7efc\u8ff0\uff0c\u63a2\u8ba8\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u5728\u4e91\u8ba1\u7b97\u3001\u9ad8\u6027\u80fd\u8ba1\u7b97\u53ca\u6df7\u5408\u73af\u5883\u4e2d\u5904\u7406\u8ba1\u7b97\u5bc6\u96c6\u578b\u5e94\u7528\u7684\u5e94\u7528\uff0c\u63d0\u51fa\u4e86\u5305\u542b8\u4e2a\u7814\u7a76\u65b9\u5411\u30019\u4e2a\u7528\u4f8b\u9886\u57df\u7684\u5206\u7c7b\u4f53\u7cfb\u3002", "motivation": "\u968f\u7740\u9ad8\u6027\u80fd\u8ba1\u7b97\u3001\u4eba\u5de5\u667a\u80fd\u548c\u5927\u6570\u636e\u7b49\u8ba1\u7b97\u5bc6\u96c6\u578b\u5e94\u7528\u7684\u5e7f\u6cdb\u90e8\u7f72\uff0c\u4e91\u8ba1\u7b97\u4e0e\u9ad8\u6027\u80fd\u8ba1\u7b97\u57fa\u7840\u8bbe\u65bd\u6b63\u5728\u878d\u5408\u3002\u4e91\u63d0\u4f9b\u5546\u5f00\u59cb\u96c6\u6210\u9ad8\u6027\u80fd\u8ba1\u7b97\u80fd\u529b\uff08\u5982\u786c\u4ef6\u52a0\u901f\u5668\u3001\u9ad8\u901f\u4e92\u8fde\uff09\uff0c\u800c\u9ad8\u6027\u80fd\u8ba1\u7b97\u793e\u533a\u4e5f\u5f00\u59cb\u63a2\u7d22\u4e91\u539f\u751f\u8303\u5f0f\u4ee5\u63d0\u9ad8\u53ef\u6269\u5c55\u6027\u3001\u5f39\u6027\u548c\u8d44\u6e90\u5229\u7528\u7387\u3002\u5728\u6b64\u80cc\u666f\u4e0b\uff0c\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u6210\u4e3a\u5904\u7406\u9ad8\u5ea6\u52a8\u6001\u3001\u5e76\u884c\u548c\u5206\u5e03\u5f0f\u5de5\u4f5c\u8d1f\u8f7d\u7684\u6709\u524d\u666f\u6267\u884c\u6a21\u578b\u3002", "method": "\u91c7\u7528\u7cfb\u7edf\u6027\u6587\u732e\u7efc\u8ff0\u65b9\u6cd5\uff0c\u5206\u6790\u4e862018\u5e74\u81f32025\u5e74\u521d\u671f\u95f4\u53d1\u8868\u7684122\u7bc7\u7814\u7a76\u8bba\u6587\u3002\u4ece\u8fd9\u4e9b\u6587\u732e\u4e2d\u63d0\u53d6\u5173\u952e\u4fe1\u606f\uff0c\u63d0\u51fa\u4e86\u5305\u542b\u516b\u4e2a\u4e3b\u8981\u7814\u7a76\u65b9\u5411\u3001\u4e5d\u4e2a\u76ee\u6807\u7528\u4f8b\u9886\u57df\u7684\u5206\u7c7b\u4f53\u7cfb\uff0c\u5e76\u5206\u6790\u4e86\u8fd1\u671f\u7684\u53d1\u8868\u8d8b\u52bf\u548c\u4f5c\u8005\u5408\u4f5c\u7f51\u7edc\u3002", "result": "\u7814\u7a76\u5c55\u793a\u4e86\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u5728\u4e91\u8ba1\u7b97\u3001\u9ad8\u6027\u80fd\u8ba1\u7b97\u548c\u6df7\u5408\u73af\u5883\u4e2d\u5904\u7406\u5e76\u884c\u8ba1\u7b97\u5bc6\u96c6\u578b\u5e94\u7528\u7684\u65e5\u76ca\u589e\u957f\u7684\u5174\u8da3\u548c\u76f8\u4e92\u8054\u7cfb\u3002\u63d0\u51fa\u4e86\u4e00\u4e2a\u5168\u9762\u7684\u5206\u7c7b\u6846\u67b6\uff0c\u4e3a\u7814\u7a76\u4eba\u5458\u548c\u5b9e\u8df5\u8005\u63d0\u4f9b\u4e86\u6e05\u6670\u7684\u8def\u7ebf\u56fe\uff0c\u7a81\u51fa\u4e86\u8be5\u65b0\u5174\u7814\u7a76\u9886\u57df\u7684\u53d1\u5c55\u8d8b\u52bf\u548c\u5408\u4f5c\u6a21\u5f0f\u3002", "conclusion": "\u8fd9\u9879\u5de5\u4f5c\u4e3a\u65b0\u624b\u7814\u7a76\u4eba\u5458\u548c\u7ecf\u9a8c\u4e30\u5bcc\u7684\u5b9e\u8df5\u8005\u63d0\u4f9b\u4e86\u6709\u4ef7\u503c\u7684\u57fa\u7840\uff0c\u6307\u5bfc\u4e0b\u4e00\u4ee3\u65e0\u670d\u52a1\u5668\u89e3\u51b3\u65b9\u6848\u7684\u5f00\u53d1\uff0c\u4ee5\u652f\u6301\u5e76\u884c\u8ba1\u7b97\u5bc6\u96c6\u578b\u5e94\u7528\u3002\u65e0\u670d\u52a1\u5668\u8ba1\u7b97\u5728\u878d\u5408\u4e91\u548c\u9ad8\u6027\u80fd\u8ba1\u7b97\u73af\u5883\u4e2d\u5c55\u73b0\u51fa\u5de8\u5927\u6f5c\u529b\uff0c\u80fd\u591f\u6709\u6548\u5904\u7406\u52a8\u6001\u3001\u5e76\u884c\u548c\u5206\u5e03\u5f0f\u5de5\u4f5c\u8d1f\u8f7d\u3002"}}
{"id": "2601.09583", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2601.09583", "abs": "https://arxiv.org/abs/2601.09583", "authors": ["Berke Ates", "Philipp Schaad", "Timo Schneider", "Alexandru Calotoiu", "Torsten Hoefler"], "title": "MLIR-Forge: A Modular Framework for Language Smiths", "comment": null, "summary": "Optimizing compilers are essential for the efficient and correct execution of software across various scientific fields. Domain-specific languages (DSL) typically use higher level intermediate representations (IR) in their compiler pipelines for domain-specific optimizations. As these IRs add to complexity, it is crucial to test them thoroughly. Random program generators have proven to be an effective tool to test compilers through differential and fuzz testing. However, developing specialized program generators for compiler IRs is not straightforward and demands considerable resources. We introduce MLIR-Forge, a novel random program generator framework that leverages the flexibility of MLIR, aiming to simplify the creation of specialized program generators. MLIR-Forge achieves this by splitting the generation process into fundamental building blocks that are language specific, and reusable program creation logic that constructs random programs from these building blocks. This hides complexity and furthermore, even the language specific components can be defined using a set of common tools. We demonstrate MLIR-Forge's capabilities by generating MLIR with built-in dialects, WebAssembly, and a data-centric program representation, DaCe -- requiring less than a week of development time in total for each of them. Using the generated programs we conduct differential testing and find 9 MLIR, 15 WebAssembly, and 774 DaCe groups of bugs with the corresponding program generators, after running them until the rate of new bugs stagnates.", "AI": {"tldr": "MLIR-Forge\u662f\u4e00\u4e2a\u57fa\u4e8eMLIR\u7684\u968f\u673a\u7a0b\u5e8f\u751f\u6210\u6846\u67b6\uff0c\u65e8\u5728\u7b80\u5316\u9488\u5bf9\u7f16\u8bd1\u5668\u4e2d\u95f4\u8868\u793a\uff08IR\uff09\u7684\u4e13\u7528\u7a0b\u5e8f\u751f\u6210\u5668\u7684\u5f00\u53d1\uff0c\u901a\u8fc7\u5206\u79bb\u8bed\u8a00\u7279\u5b9a\u7ec4\u4ef6\u548c\u53ef\u91cd\u7528\u7a0b\u5e8f\u521b\u5efa\u903b\u8f91\u6765\u964d\u4f4e\u590d\u6742\u6027\u3002", "motivation": "\u9886\u57df\u7279\u5b9a\u8bed\u8a00\uff08DSL\uff09\u4f7f\u7528\u9ad8\u7ea7\u4e2d\u95f4\u8868\u793a\uff08IR\uff09\u8fdb\u884c\u4f18\u5316\uff0c\u4f46\u6d4b\u8bd5\u8fd9\u4e9bIR\u5f88\u590d\u6742\u3002\u968f\u673a\u7a0b\u5e8f\u751f\u6210\u5668\u662f\u6d4b\u8bd5\u7f16\u8bd1\u5668\u7684\u6709\u6548\u5de5\u5177\uff0c\u4f46\u4e3a\u7f16\u8bd1\u5668IR\u5f00\u53d1\u4e13\u7528\u7a0b\u5e8f\u751f\u6210\u5668\u65e2\u56f0\u96be\u53c8\u8017\u65f6\u3002", "method": "MLIR-Forge\u5c06\u751f\u6210\u8fc7\u7a0b\u5206\u89e3\u4e3a\u8bed\u8a00\u7279\u5b9a\u7684\u57fa\u7840\u6784\u5efa\u5757\u548c\u53ef\u91cd\u7528\u7684\u7a0b\u5e8f\u521b\u5efa\u903b\u8f91\uff0c\u5229\u7528MLIR\u7684\u7075\u6d3b\u6027\u7b80\u5316\u4e13\u7528\u7a0b\u5e8f\u751f\u6210\u5668\u7684\u521b\u5efa\u3002\u8bed\u8a00\u7279\u5b9a\u7ec4\u4ef6\u53ef\u4ee5\u4f7f\u7528\u4e00\u7ec4\u901a\u7528\u5de5\u5177\u5b9a\u4e49\u3002", "result": "\u4f7f\u7528MLIR-Forge\u4e3aMLIR\u5185\u7f6e\u65b9\u8a00\u3001WebAssembly\u548c\u6570\u636e\u4e2d\u5fc3\u7a0b\u5e8f\u8868\u793aDaCe\u751f\u6210\u7a0b\u5e8f\uff0c\u6bcf\u4e2a\u4ec5\u9700\u4e0d\u5230\u4e00\u5468\u7684\u5f00\u53d1\u65f6\u95f4\u3002\u901a\u8fc7\u5dee\u5206\u6d4b\u8bd5\u53d1\u73b0\u4e869\u4e2aMLIR\u300115\u4e2aWebAssembly\u548c774\u4e2aDaCe\u76f8\u5173\u7684bug\u7ec4\u3002", "conclusion": "MLIR-Forge\u663e\u8457\u964d\u4f4e\u4e86\u4e3a\u7f16\u8bd1\u5668IR\u521b\u5efa\u968f\u673a\u7a0b\u5e8f\u751f\u6210\u5668\u7684\u590d\u6742\u6027\uff0c\u6709\u6548\u652f\u6301\u5dee\u5206\u6d4b\u8bd5\u548c\u6a21\u7cca\u6d4b\u8bd5\uff0c\u80fd\u591f\u9ad8\u6548\u53d1\u73b0\u7f16\u8bd1\u5668\u5b9e\u73b0\u4e2d\u7684bug\u3002"}}
