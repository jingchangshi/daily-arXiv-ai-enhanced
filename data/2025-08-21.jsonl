{"id": "2508.14247", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14247", "abs": "https://arxiv.org/abs/2508.14247", "authors": ["Saswata Jana", "Subhajit Pramanick", "Adri Bhattacharya", "Partha Sarathi Mandal"], "title": "Time-optimal Asynchronous Minimal Vertex Covering by Myopic Robots", "comment": null, "summary": "In a connected graph with an autonomous robot swarm with limited visibility,\nit is natural to ask whether the robots can be deployed to certain vertices\nsatisfying a given property using only local knowledge. This paper\naffirmatively answers the question with a set of \\emph{myopic} (finite\nvisibility range) luminous robots with the aim of \\emph{filling a minimal\nvertex cover} (MVC) of a given graph $G = (V, E)$. The graph has special\nvertices, called \\emph{doors}, through which robots enter sequentially.\nStarting from the doors, the goal of the robots is to settle on a set of\nvertices that forms a minimal vertex cover of $G$ under the asynchronous\n($\\mathcal{ASYNC}$) scheduler. We are also interested in achieving the\n\\emph{minimum vertex cover} (MinVC, which is NP-hard \\cite{Karp1972} for\ngeneral graphs) for a specific graph class using the myopic robots. We\nestablish lower bounds on the visibility range for the robots and on the time\ncomplexity (which is $\\Omega(|E|)$). We present two algorithms for trees: one\nfor single door, which is both time and memory-optimal, and the other for\nmultiple doors, which is memory-optimal and achieves time-optimality when the\nnumber of doors is a constant. Interestingly, our technique achieves MinVC on\ntrees with a single door. We then move to the general graph, where we present\ntwo algorithms, one for the single door and the other for the multiple doors\nwith an extra memory of $O(\\log \\Delta)$ for the robots, where $\\Delta$ is the\nmaximum degree of $G$. All our algorithms run in $O(|E|)$ epochs."}
{"id": "2508.14271", "categories": ["cs.DC", "math.LO", "03F50, 03B70, 68Q42, 16Y60, 20M35", "F.1.1; F.4.1; F.4.2; G.2.1; G.2.2"], "pdf": "https://arxiv.org/pdf/2508.14271", "abs": "https://arxiv.org/abs/2508.14271", "authors": ["Saul Youssef"], "title": "Pure Data Spaces", "comment": "26 pages", "summary": "In a previous work, \"pure data\" is proposed as an axiomatic foundation for\nmathematics and computing, based on \"finite sequence\" as the foundational\nconcept rather than based on logic or type. Within this framework, objects with\nmathematical meaning are \"data\" and collections of mathematical objects must\nthen be associative data, called a \"space.\" A space is then the basic\ncollection in this framework analogous to sets in Set Theory or objects in\nCategory Theory. A theory of spaces is developed,where spaces are studied via\ntheir semiring of endomorphisms. To illustrate these concepts, and as a way of\nexploring the implications of the framework, pure data spaces are \"grown\norganically\" from the substrate of pure data with minimal combinatoric\ndefinitions. Familiar objects from classical mathematics emerge this way,\nincluding natural numbers, integers, rational numbers, boolean spaces, matrix\nalgebras, Gaussian Integers, Quaternions, and non-associative algebras like the\nInteger Octonions. Insights from these examples are discussed with a view\ntowards new directions in theory and new exploration."}
{"id": "2508.14319", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14319", "abs": "https://arxiv.org/abs/2508.14319", "authors": ["Parshan Javanrood", "Matei Ripeanu"], "title": "SSSP-Del: Fully Dynamic Distributed Algorithm for Single-Source Shortest Path", "comment": "Submitted to the IA^3 Workshop at SC25. Under review", "summary": "Modern graphs are both large and dynamic, presenting significant challenges\nfor fundamental queries, such as the Single-Source Shortest Path (SSSP)\nproblem. Naively recomputing the SSSP tree after each topology change is\nprohibitively expensive, causing on-demand computation to suffer from high\nlatency. Existing dynamic SSSP algorithms often cannot simultaneously handle\nboth edge additions and deletions, operate in distributed memory, and provide\nlow-latency query results. To address these challenges, this paper presents\nSSSP-Del, a new vertex-centric, asynchronous, and fully distributed algorithm\nfor dynamic SSSP. Operating in a shared-nothing architecture, our algorithm\nprocesses streams of both edge insertions and deletions. We conduct a\ncomprehensive evaluation on large real-world and synthetic graphs with millions\nof vertices, and provide a thorough analysis by evaluating result latency,\nsolution stability, and throughput."}
{"id": "2508.14457", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14457", "abs": "https://arxiv.org/abs/2508.14457", "authors": ["Yongrae Jo", "Chanik Park"], "title": "A Hierarchical Sharded Blockchain Balancing Performance and Availability", "comment": null, "summary": "Blockchain networks offer decentralization, transparency, and immutability\nfor managing critical data but encounter scalability problems as the number of\nnetwork members and transaction issuers grows. Sharding is considered a\npromising solution to enhance blockchain scalability. However, most existing\nblockchain sharding techniques prioritize performance at the cost of\navailability (e.g., a failure in a few servers holding a shard leads to data\nunavailability). In this paper, we propose PyloChain, a hierarchical sharded\nblockchain that balances availability and performance. PyloChain consists of\nmultiple lower-level local chains and one higher-level main chain. Each local\nchain speculatively executes local transactions to achieve high parallelism\nacross multiple local chains. The main chain leverages a directed-acyclic-graph\n(DAG)-based mempool to guarantee local block availability and to enable\nefficient Byzantine Fault Tolerance (BFT) consensus to execute global (or\ncross-shard) transactions within a collocated sharding. PyloChain speculatively\nexecutes local transactions across multiple local chains to achieve high\nparallelism. In order to reduce the number of aborted local transactions,\nPyloChain applies a simple scheduling technique to handle global transactions\nin the main chain. PyloChain provides a fine-grained auditing mechanism to\nmitigate faulty higher-level members by externalizing main chain operations to\nlower-level local members. We implemented and evaluated PyloChain,\ndemonstrating its performance scalability with 1.49x higher throughput and\n2.63x faster latency compared to the state-of-the-art balanced hierarchical\nsharded blockchain."}
{"id": "2508.14053", "categories": ["cs.AR", "cs.AI", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.14053", "abs": "https://arxiv.org/abs/2508.14053", "authors": ["Jinwei Tang", "Jiayin Qin", "Nuo Xu", "Pragnya Sudershan Nalla", "Yu Cao", "Yang", "Zhao", "Caiwen Ding"], "title": "MAHL: Multi-Agent LLM-Guided Hierarchical Chiplet Design with Adaptive Debugging", "comment": null, "summary": "As program workloads (e.g., AI) increase in size and algorithmic complexity,\nthe primary challenge lies in their high dimensionality, encompassing computing\ncores, array sizes, and memory hierarchies. To overcome these obstacles,\ninnovative approaches are required. Agile chip design has already benefited\nfrom machine learning integration at various stages, including logic synthesis,\nplacement, and routing. With Large Language Models (LLMs) recently\ndemonstrating impressive proficiency in Hardware Description Language (HDL)\ngeneration, it is promising to extend their abilities to 2.5D integration, an\nadvanced technique that saves area overhead and development costs. However,\nLLM-driven chiplet design faces challenges such as flatten design, high\nvalidation cost and imprecise parameter optimization, which limit its chiplet\ndesign capability. To address this, we propose MAHL, a hierarchical LLM-based\nchiplet design generation framework that features six agents which\ncollaboratively enable AI algorithm-hardware mapping, including hierarchical\ndescription generation, retrieval-augmented code generation, diverseflow-based\nvalidation, and multi-granularity design space exploration. These components\ntogether enhance the efficient generation of chiplet design with optimized\nPower, Performance and Area (PPA). Experiments show that MAHL not only\nsignificantly improves the generation accuracy of simple RTL design, but also\nincreases the generation accuracy of real-world chiplet design, evaluated by\nPass@5, from 0 to 0.72 compared to conventional LLMs under the best-case\nscenario. Compared to state-of-the-art CLARIE (expert-based), MAHL achieves\ncomparable or even superior PPA results under certain optimization objectives."}
{"id": "2508.14394", "categories": ["cs.PL", "cs.SE", "D.3; D.2.5; G.3"], "pdf": "https://arxiv.org/pdf/2508.14394", "abs": "https://arxiv.org/abs/2508.14394", "authors": ["Ryan Tjoa", "Poorva Garg", "Harrison Goldstein", "Todd Millstein", "Benjamin Pierce", "Guy Van den Broeck"], "title": "Tuning Random Generators: Property-Based Testing as Probabilistic Programming", "comment": "Extended version of OOPSLA '25 paper", "summary": "Property-based testing validates software against an executable specification\nby evaluating it on randomly generated inputs. The standard way that PBT users\ngenerate test inputs is via generators that describe how to sample test inputs\nthrough random choices. To achieve a good distribution over test inputs, users\nmust tune their generators, i.e., decide on the weights of these individual\nrandom choices. Unfortunately, it is very difficult to understand how to choose\nindividual generator weights in order to achieve a desired distribution, so\ntoday this process is tedious and limits the distributions that can be\npractically achieved.\n  In this paper, we develop techniques for the automatic and offline tuning of\ngenerators. Given a generator with undetermined symbolic weights and an\nobjective function, our approach automatically learns values for these weights\nthat optimize for the objective. We describe useful objective functions that\nallow users to (1) target desired distributions and (2) improve the diversity\nand validity of their test cases. We have implemented our approach in a novel\ndiscrete probabilistic programming system, Loaded Dice, that supports\ndifferentiation and parameter learning, and use it as a language for\ngenerators. We empirically demonstrate that our approach is effective at\noptimizing generator distributions according to the specified objective\nfunctions. We also perform a thorough evaluation on PBT benchmarks,\ndemonstrating that, when automatically tuned for diversity and validity, the\ngenerators exhibit a 3.1-7.4x speedup in bug finding."}
{"id": "2508.14506", "categories": ["cs.DC", "cs.DB", "cs.DS"], "pdf": "https://arxiv.org/pdf/2508.14506", "abs": "https://arxiv.org/abs/2508.14506", "authors": ["Hagit Attiya", "Antonio Fernández Anta", "Alessia Milani", "Alexandre Rapetti", "Corentin Travers"], "title": "Auditable Shared Objects: From Registers to Synchronization Primitives", "comment": null, "summary": "Auditability allows to track operations performed on a shared object,\nrecording who accessed which information. This gives data owners more control\non their data. Initially studied in the context of single-writer registers,\nthis work extends the notion of auditability to other shared objects, and\nstudies their properties.\n  We start by moving from single-writer to multi-writer registers, and provide\nan implementation of an auditable $n$-writer $m$-reader read / write register,\nwith $O(n+m)$ step complexity. This implementation uses $(m+n)$-sliding\nregisters, which have consensus number $m+n$. We show that this consensus\nnumber is necessary. The implementation extends naturally to support an\nauditable load-linked / store-conditional (LL/SC) shared object. LL/SC is a\nprimitive that supports efficient implementation of many shared objects.\nFinally, we relate auditable registers to other access control objects, by\nimplementing an anti-flickering deny list from auditable registers."}
{"id": "2508.14068", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.14068", "abs": "https://arxiv.org/abs/2508.14068", "authors": ["Chen Chen", "Jiaqi Yin", "Cunxi Yu"], "title": "Revisit Choice Network for Synthesis and Technology Mapping", "comment": "Accepted by ICCAD 2025", "summary": "Choice network construction is a critical technique for alleviating\nstructural bias issues in Boolean optimization, equivalence checking, and\ntechnology mapping. Previous works on lossless synthesis utilize independent\noptimization to generate multiple snapshots, and use simulation and SAT solvers\nto identify functionally equivalent nodes. These nodes are then merged into a\nsubject graph with choice nodes. However, such methods often neglect the\nquality of these choices, raising the question of whether they truly contribute\nto effective technology mapping.\n  This paper introduces Cristal, a novel methodology and framework for\nconstructing Boolean choice networks. Specifically, Cristal introduces a new\nflow of choice network-based synthesis and mapping, including representative\nlogic cone search, structural mutation for generating diverse choice structures\nvia equality saturation, and priority-ranking choice selection along with\nchoice network construction and validation. Through these techniques, Cristal\nconstructs fewer but higher-quality choices.\n  Our experimental results demonstrate that Cristal outperforms the\nstate-of-the-art Boolean choice network construction implemented in ABC in the\npost-mapping stage, achieving average reductions of 3.85%/8.35% (area/delay) in\ndelay-oriented mode, 0.11%/2.74% in area-oriented mode, and a 63.77% runtime\nreduction on large-scale cases across a diverse set of combinational circuits\nfrom the IWLS 2005, ISCAS'89, and EPFL benchmark suites."}
{"id": "2508.14614", "categories": ["cs.PL", "D.3.0; D.3.1"], "pdf": "https://arxiv.org/pdf/2508.14614", "abs": "https://arxiv.org/abs/2508.14614", "authors": ["Ashish Mishra", "Suresh Jagannathan"], "title": "Close is Good Enough: Component-Based Synthesis Modulo Logical Similarity", "comment": null, "summary": "Component-based synthesis (CBS) aims to generate loop-free programs from a\nset of libraries whose methods are annotated with specifications and whose\noutput must satisfy a set of logical constraints, expressed as a query. The\neffectiveness of a CBS algorithm critically depends on the severity of the\nconstraints imposed by the query. The more exact these constraints are, the\nsparser the space of feasible solutions. This maxim also applies when we enrich\nthe expressiveness of the specifications affixed to library methods. In both\ncases, the search must now contend with constraints that may only hold over a\nsmall number of the possible execution paths that can be enumerated by a CBS\nprocedure.\n  In this paper, we address this challenge by equipping CBS search with the\nability to reason about logical similarities among the paths it explores. Our\nsetting considers library methods equipped with refinement-type specifications\nthat enrich ordinary base types with a set of rich logical qualifiers to\nconstrain the set of values accepted by that type. We perform a search over a\ntree automata variant called Qualified Tree Automata that intelligently records\ninformation about enumerated terms, leveraging subtyping constraints over the\nrefinement types associated with these terms to enable reasoning about\nsimilarity among candidate solutions as search proceeds, thereby avoiding\nexploration of semantically similar paths.\n  We present an implementation of this idea in a tool called \\name, and provide\na comprehensive evaluation that demonstrates \\name's ability to synthesize\nsolutions to complex CBS queries that go well-beyond the capabilities of the\nexisting state-of-the-art."}
{"id": "2508.14524", "categories": ["cs.DC", "cs.CR"], "pdf": "https://arxiv.org/pdf/2508.14524", "abs": "https://arxiv.org/abs/2508.14524", "authors": ["Krishnendu Chatterjee", "Jan Matyáš Křišťan", "Stefan Schmid", "Jakub Svoboda", "Michelle Yeo"], "title": "Boosting Payment Channel Network Liquidity with Topology Optimization and Transaction Selection", "comment": null, "summary": "Payment channel networks (PCNs) are a promising technology that alleviates\nblockchain scalability by shifting the transaction load from the blockchain to\nthe PCN. Nevertheless, the network topology has to be carefully designed to\nmaximise the transaction throughput in PCNs. Additionally, users in PCNs also\nhave to make optimal decisions on which transactions to forward and which to\nreject to prolong the lifetime of their channels. In this work, we consider an\ninput sequence of transactions over $p$ parties. Each transaction consists of a\ntransaction size, source, and target, and can be either accepted or rejected\n(entailing a cost). The goal is to design a PCN topology among the $p$\ncooperating parties, along with the channel capacities, and then output a\ndecision for each transaction in the sequence to minimise the cost of creating\nand augmenting channels, as well as the cost of rejecting transactions. Our\nmain contribution is an $\\mathcal{O}(p)$ approximation algorithm for the\nproblem with $p$ parties. We further show that with some assumptions on the\ndistribution of transactions, we can reduce the approximation ratio to\n$\\mathcal{O}(\\sqrt{p})$. We complement our theoretical analysis with an\nempirical study of our assumptions and approach in the context of the Lightning\nNetwork."}
{"id": "2508.14123", "categories": ["cs.AR", "cs.AI", "physics.app-ph", "physics.optics"], "pdf": "https://arxiv.org/pdf/2508.14123", "abs": "https://arxiv.org/abs/2508.14123", "authors": ["Ankita Sharma", "YuQi Fu", "Vahid Ansari", "Rishabh Iyer", "Fiona Kuang", "Kashish Mistry", "Raisa Islam Aishy", "Sara Ahmad", "Joaquin Matres", "Dirk R. Englund", "Joyce K. S. Poon"], "title": "AI Agents for Photonic Integrated Circuit Design Automation", "comment": null, "summary": "We present Photonics Intelligent Design and Optimization (PhIDO), a\nmulti-agent framework that converts natural-language photonic integrated\ncircuit (PIC) design requests into layout mask files. We compare 7 reasoning\nlarge language models for PhIDO using a testbench of 102 design descriptions\nthat ranged from single devices to 112-component PICs. The success rate for\nsingle-device designs was up to 91%. For design queries with less than or equal\nto 15 components, o1, Gemini-2.5-pro, and Claude Opus 4 achieved the highest\nend-to-end pass@5 success rates of approximately 57%, with Gemini-2.5-pro\nrequiring the fewest output tokens and lowest cost. The next steps toward\nautonomous PIC development include standardized knowledge representations,\nexpanded datasets, extended verification, and robotic automation."}
{"id": "2508.14625", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14625", "abs": "https://arxiv.org/abs/2508.14625", "authors": ["Kathleen West", "Youssef Moawad", "Fabian Lehmann", "Vasilis Bountris", "Ulf Leser", "Yehia Elkhatib", "Lauritz Thamsen"], "title": "A Systematic Evaluation of the Potential of Carbon-Aware Execution for Scientific Workflows", "comment": "This is a pre-print of our paper currently under review", "summary": "Scientific workflows are widely used to automate scientific data analysis and\noften involve computationally intensive processing of large datasets on compute\nclusters. As such, their execution tends to be long-running and\nresource-intensive, resulting in substantial energy consumption and, depending\non the energy mix, carbon emissions. Meanwhile, a wealth of carbon-aware\ncomputing methods have been proposed, yet little work has focused specifically\non scientific workflows, even though they present a substantial opportunity for\ncarbon-aware computing because they are often significantly delay tolerant,\nefficiently interruptible, highly scalable and widely heterogeneous. In this\nstudy, we first exemplify the problem of carbon emissions associated with\nrunning scientific workflows, and then show the potential for carbon-aware\nworkflow execution. For this, we estimate the carbon footprint of seven\nreal-world Nextflow workflows executed on different cluster infrastructures\nusing both average and marginal carbon intensity data. Furthermore, we\nsystematically evaluate the impact of carbon-aware temporal shifting, and the\npausing and resuming of the workflow. Moreover, we apply resource scaling to\nworkflows and workflow tasks. Finally, we report the potential reduction in\noverall carbon emissions, with temporal shifting capable of decreasing\nemissions by over 80%, and resource scaling capable of decreasing emissions by\n67%."}
{"id": "2508.14245", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.14245", "abs": "https://arxiv.org/abs/2508.14245", "authors": ["Shuting Du", "Mohamed Ibrahim", "Zishen Wan", "Luqi Zheng", "Boheng Zhao", "Zhenkun Fan", "Che-Kai Liu", "Tushar Krishna", "Arijit Raychowdhury", "Haitong Li"], "title": "Cross-Layer Design of Vector-Symbolic Computing: Bridging Cognition and Brain-Inspired Hardware Acceleration", "comment": null, "summary": "Vector Symbolic Architectures (VSAs) have been widely deployed in various\ncognitive applications due to their simple and efficient operations. The\nwidespread adoption of VSAs has, in turn, spurred the development of numerous\nhardware solutions aimed at optimizing their performance. Despite these\nadvancements, a comprehensive and unified discourse on the convergence of\nhardware and algorithms in the context of VSAs remains somewhat limited. The\npaper aims to bridge the gap between theoretical software-level explorations\nand the development of efficient hardware architectures and emerging technology\nfabrics for VSAs, providing insights from the co-design aspect for researchers\nfrom either side. First, we introduce the principles of vector-symbolic\ncomputing, including its core mathematical operations and learning paradigms.\nSecond, we provide an in-depth discussion on hardware technologies for VSAs,\nanalyzing analog, mixed-signal, and digital circuit design styles. We compare\nhardware implementations of VSAs by carrying out detailed analysis of their\nperformance characteristics and tradeoffs, allowing us to extract design\nguidelines for the development of arbitrary VSA formulations. Third, we discuss\na methodology for cross-layer design of VSAs that identifies synergies across\nlayers and explores key ingredients for hardware/software co-design of VSAs.\nFinally, as a concrete demonstration of this methodology, we propose the first\nin-memory computing hierarchical cognition hardware system, showcasing the\nefficiency, flexibility, and scalability of this co-design approach. The paper\nconcludes with a discussion of open research challenges for future\nexplorations."}
{"id": "2508.14716", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14716", "abs": "https://arxiv.org/abs/2508.14716", "authors": ["Amores-Sesar Ignacio", "Grøndal Viktor", "Holmgård Adam", "Ottendal Mads"], "title": "DAG it off: Latency Prefers No Common Coins", "comment": null, "summary": "We introduce Black Marlin, the first Directed Acyclic Graph (DAG)-based\nByzantine atomic broadcast protocol in a partially synchronous setting that\nsuccessfully forgoes the reliable broadcast and common coin primitives. Black\nMarlin achieves the optimal latency of 3 rounds of communication (4.25 with\nByzantine faults) while maintaining optimal communication and amortized\ncommunication complexities. We present a formal security analysis of the\nprotocol, accompanied by empirical evidence that Black Marlin outperforms\nstate-of-the-art DAG-based protocols in both throughput and latency."}
{"id": "2508.14318", "categories": ["cs.AR", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14318", "abs": "https://arxiv.org/abs/2508.14318", "authors": ["Esha Choukse", "Brijesh Warrier", "Scot Heath", "Luz Belmont", "April Zhao", "Hassan Ali Khan", "Brian Harry", "Matthew Kappel", "Russell J. Hewett", "Kushal Datta", "Yu Pei", "Caroline Lichtenberger", "John Siegler", "David Lukofsky", "Zaid Kahn", "Gurpreet Sahota", "Andy Sullivan", "Charles Frederick", "Hien Thai", "Rebecca Naughton", "Daniel Jurnove", "Justin Harp", "Reid Carper", "Nithish Mahalingam", "Srini Varkala", "Alok Gautam Kumbhare", "Satyajit Desai", "Venkatesh Ramamurthy", "Praneeth Gottumukkala", "Girish Bhatia", "Kelsey Wildstone", "Laurentiu Olariu", "Mohammed Ayna", "Mike Kendrick", "Ricardo Bianchini", "Aaron Hurst", "Reza Zamani", "Xin Li", "Gene Oden", "Rory Carmichael", "Tom Li", "Apoorv Gupta", "Nilesh Dattani", "Lawrence Marwong", "Rob Nertney", "Jeff Liott", "Miro Enev", "Divya Ramakrishnan", "Ian Buck", "Jonah Alben"], "title": "Power Stabilization for AI Training Datacenters", "comment": null, "summary": "Large Artificial Intelligence (AI) training workloads spanning several tens\nof thousands of GPUs present unique power management challenges. These arise\ndue to the high variability in power consumption during the training. Given the\nsynchronous nature of these jobs, during every iteration there is a\ncomputation-heavy phase, where each GPU works on the local data, and a\ncommunication-heavy phase where all the GPUs synchronize on the data. Because\ncompute-heavy phases require much more power than communication phases, large\npower swings occur. The amplitude of these power swings is ever increasing with\nthe increase in the size of training jobs. An even bigger challenge arises from\nthe frequency spectrum of these power swings which, if harmonized with critical\nfrequencies of utilities, can cause physical damage to the power grid\ninfrastructure. Therefore, to continue scaling AI training workloads safely, we\nneed to stabilize the power of such workloads. This paper introduces the\nchallenge with production data and explores innovative solutions across the\nstack: software, GPU hardware, and datacenter infrastructure. We present the\npros and cons of each of these approaches and finally present a multi-pronged\napproach to solving the challenge. The proposed solutions are rigorously tested\nusing a combination of real hardware and Microsoft's in-house cloud power\nsimulator, providing critical insights into the efficacy of these interventions\nunder real-world conditions."}
{"id": "2508.14830", "categories": ["cs.DC", "cs.GT", "cs.NE", "cs.NI"], "pdf": "https://arxiv.org/pdf/2508.14830", "abs": "https://arxiv.org/abs/2508.14830", "authors": ["Kushagra Agrawal", "Polat Goktas", "Anjan Bandopadhyay", "Debolina Ghosh", "Junali Jasmine Jena", "Mahendra Kumar Gourisaria"], "title": "MOHAF: A Multi-Objective Hierarchical Auction Framework for Scalable and Fair Resource Allocation in IoT Ecosystems", "comment": null, "summary": "The rapid growth of Internet of Things (IoT) ecosystems has intensified the\nchallenge of efficiently allocating heterogeneous resources in highly dynamic,\ndistributed environments. Conventional centralized mechanisms and\nsingle-objective auction models, focusing solely on metrics such as cost\nminimization or revenue maximization, struggle to deliver balanced system\nperformance. This paper proposes the Multi-Objective Hierarchical Auction\nFramework (MOHAF), a distributed resource allocation mechanism that jointly\noptimizes cost, Quality of Service (QoS), energy efficiency, and fairness.\nMOHAF integrates hierarchical clustering to reduce computational complexity\nwith a greedy, submodular optimization strategy that guarantees a (1-1/e)\napproximation ratio. A dynamic pricing mechanism adapts in real time to\nresource utilization, enhancing market stability and allocation quality.\nExtensive experiments on the Google Cluster Data trace, comprising 3,553\nrequests and 888 resources, demonstrate MOHAF's superior allocation efficiency\n(0.263) compared to Greedy (0.185), First-Price (0.138), and Random (0.101)\nauctions, while achieving perfect fairness (Jain's index = 1.000). Ablation\nstudies reveal the critical influence of cost and QoS components in sustaining\nbalanced multi-objective outcomes. With near-linear scalability, theoretical\nguarantees, and robust empirical performance, MOHAF offers a practical and\nadaptable solution for large-scale IoT deployments, effectively reconciling\nefficiency, equity, and sustainability in distributed resource coordination."}
{"id": "2508.14375", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.14375", "abs": "https://arxiv.org/abs/2508.14375", "authors": ["Choongseok Song", "Doo Seok Jeong"], "title": "Computing-In-Memory Dataflow for Minimal Buffer Traffic", "comment": "IEEE International Conference on Computer Design", "summary": "Computing-In-Memory (CIM) offers a potential solution to the memory wall\nissue and can achieve high energy efficiency by minimizing data movement,\nmaking it a promising architecture for edge AI devices. Lightweight models like\nMobileNet and EfficientNet, which utilize depthwise convolution for feature\nextraction, have been developed for these devices. However, CIM macros often\nface challenges in accelerating depthwise convolution, including\nunderutilization of CIM memory and heavy buffer traffic. The latter, in\nparticular, has been overlooked despite its significant impact on latency and\nenergy consumption. To address this, we introduce a novel CIM dataflow that\nsignificantly reduces buffer traffic by maximizing data reuse and improving\nmemory utilization during depthwise convolution. The proposed dataflow is\ngrounded in solid theoretical principles, fully demonstrated in this paper.\nWhen applied to MobileNet and EfficientNet models, our dataflow reduces buffer\ntraffic by 77.4-87.0%, leading to a total reduction in data traffic energy and\nlatency by 10.1-17.9% and 15.6-27.8%, respectively, compared to the baseline\n(conventional weight-stationary dataflow)."}
{"id": "2508.14848", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14848", "abs": "https://arxiv.org/abs/2508.14848", "authors": ["Qiao Zhang", "Rabab Alomairy", "Dali Wang", "Zhuowei Gu", "Qinglei Cao"], "title": "Leveraging Hardware-Aware Computation in Mixed-Precision Matrix Multiply: A Tile-Centric Approach", "comment": null, "summary": "General Matrix Multiplication (GEMM) is a critical operation underpinning a\nwide range of applications in high-performance computing (HPC) and artificial\nintelligence (AI). The emergence of hardware optimized for low-precision\narithmetic necessitates a reevaluation of numerical algorithms to leverage\nmixed-precision computations, achieving improved performance and energy\nefficiency. This research introduces an adaptive mixed-precision GEMM framework\nthat supports different precision formats at fine-grained tile/block levels. We\nutilize the PaRSEC runtime system to balance workloads across various\narchitectures. The performance scales well on ARM CPU-based Fugaku\nsupercomputer, Nvidia GPU-based A100 DGX, and AMD GPU-based Frontier\nsupercomputer. This research aims to enhance computational efficiency and\naccuracy by bridging algorithmic advancements and hardware innovations, driving\ntransformative progress in various applications."}
{"id": "2508.14414", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.14414", "abs": "https://arxiv.org/abs/2508.14414", "authors": ["Ruiyang Ma", "Daikang Kuang", "Ziqian Liu", "Jiaxi Zhang", "Ping Fan", "Guojie Luo"], "title": "Wit-HW: Bug Localization in Hardware Design Code via Witness Test Case Generation", "comment": "Accepted by ICCAD'2025", "summary": "Debugging hardware designs requires significant manual effort during hardware\ndevelopment. After engineers identify a bug-triggering test case in\nsimulation-based hardware verification, they usually spend considerable time\nanalyzing the execution trace to localize the bug. Although numerous automated\nhardware debugging techniques exist, they are not applicable to large designs\nand deep bugs. A primary reason for their limitations is that these techniques\nonly utilize the information of a single bug-triggering test case for bug\nlocalization, which prevents them from effectively analyzing intricate hardware\nsystems and figure out the root cause of bugs. To solve this problem, in this\npaper, we transform the hardware bug localization problem into a test\ngeneration problem, aiming to find a set of effective witness test cases beyond\nthe initial bug-triggering test case to enhance hardware bug localization.\nWitness test cases refer to the cases that do not trigger the bug in the faulty\ndesign. By analyzing the execution differences between passing and failing test\ncases with spectrum-based method, we can eliminate innocent design statements\nand localize the buggy ones. To further refine the suspicious area, we define\nthe criteria for effective witness test cases and use a mutation-based strategy\nto generate such test cases. Based on this approach, we propose an automated\nhardware bug localization framework named Wit-HW. We evaluate Wit-HW on 41 bugs\nfrom various hardware designs. The experimental results show that Wit-HW\neffectively localize 49%, 73%, 88% bugs within Top-1, Top-5, Top-10 ranks,\nsignificantly outperforming state-of-the-art bug localization techniques.\nAdditionally, we evaluate Wit-HW on 13 real-world bugs collected from\nopen-source hardware projects, showcasing the robust performance of our method."}
{"id": "2508.14883", "categories": ["cs.DC", "cs.GT", "91-08", "J.1; H.1.m"], "pdf": "https://arxiv.org/pdf/2508.14883", "abs": "https://arxiv.org/abs/2508.14883", "authors": ["Benedikt Pittl", "Werner Mach", "Erich Schikuta"], "title": "The Cost Advantage of Virtual Machine Migrations: Empirical Insights into Amazon's EC2 Marketspace", "comment": null, "summary": "In recent years, cloud providers have introduced novel approaches for trading\nvirtual machines. For example, Virtustream introduced so-called muVMs to charge\ncloud computing resources while other providers such as Google, Microsoft, or\nAmazon re-invented their marketspaces. Today, the market leader Amazon runs six\nmarketspaces for trading virtual machines. Consumers can purchase bundles of\nvirtual machines, which are called cloud-portfolios, from multiple marketspaces\nand providers. An industry-relevant field of research is to identify best\npractices and guidelines on how such optimal portfolios are created. In the\npaper at hand, a cost analysis of cloud portfolios is presented. Therefore,\npricing data from Amazon was used as well as a real virtual machine utilization\ndataset from the Bitbrains datacenter. The results show that a cost optimum can\nonly be reached if heterogeneous portfolios are created where virtual machines\nare purchased from different marketspaces. Additionally, the cost-benefit of\nmigrating virtual machines to different marketplaces during runtime is\npresented. Such migrations are especially cost-effective for virtual machines\nof cloud-portfolios which run between 6 hours and 1 year. The paper further\nshows that most of the resources of virtual machines are never utilized by\nconsumers, which represents a significant future potential for cost\noptimization. For the validation of the results, a second dataset of the\nBitbrains datacenter was used, which contains utility data of virtual machines\nfrom a different domain of application."}
{"id": "2508.14582", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.14582", "abs": "https://arxiv.org/abs/2508.14582", "authors": ["Ryan Albert Antonio", "Joren Dumoulin", "Xiaoling Yi", "Josse Van Delm", "Yunhao Deng", "Guilherme Paim", "Marian Verhelst"], "title": "An Open-Source HW-SW Co-Development Framework Enabling Efficient Multi-Accelerator Systems", "comment": "7 pages, 10 figures, 1 table, to be published in ISLPED 2025", "summary": "Heterogeneous accelerator-centric compute clusters are emerging as efficient\nsolutions for diverse AI workloads. However, current integration strategies\noften compromise data movement efficiency and encounter compatibility issues in\nhardware and software. This prevents a unified approach that balances\nperformance and ease of use. To this end, we present SNAX, an open-source\nintegrated HW-SW framework enabling efficient multi-accelerator platforms\nthrough a novel hybrid-coupling scheme, consisting of loosely coupled\nasynchronous control and tightly coupled data access. SNAX brings reusable\nhardware modules designed to enhance compute accelerator utilization, and its\ncustomizable MLIR-based compiler to automate key system management tasks,\njointly enabling rapid development and deployment of customized\nmulti-accelerator compute clusters. Through extensive experimentation, we\ndemonstrate SNAX's efficiency and flexibility in a low-power heterogeneous SoC.\nAccelerators can easily be integrated and programmed to achieve > 10x\nimprovement in neural network performance compared to other accelerator systems\nwhile maintaining accelerator utilization of > 90% in full system operation."}
{"id": "2508.14318", "categories": ["cs.AR", "cs.AI", "cs.DC"], "pdf": "https://arxiv.org/pdf/2508.14318", "abs": "https://arxiv.org/abs/2508.14318", "authors": ["Esha Choukse", "Brijesh Warrier", "Scot Heath", "Luz Belmont", "April Zhao", "Hassan Ali Khan", "Brian Harry", "Matthew Kappel", "Russell J. Hewett", "Kushal Datta", "Yu Pei", "Caroline Lichtenberger", "John Siegler", "David Lukofsky", "Zaid Kahn", "Gurpreet Sahota", "Andy Sullivan", "Charles Frederick", "Hien Thai", "Rebecca Naughton", "Daniel Jurnove", "Justin Harp", "Reid Carper", "Nithish Mahalingam", "Srini Varkala", "Alok Gautam Kumbhare", "Satyajit Desai", "Venkatesh Ramamurthy", "Praneeth Gottumukkala", "Girish Bhatia", "Kelsey Wildstone", "Laurentiu Olariu", "Mohammed Ayna", "Mike Kendrick", "Ricardo Bianchini", "Aaron Hurst", "Reza Zamani", "Xin Li", "Gene Oden", "Rory Carmichael", "Tom Li", "Apoorv Gupta", "Nilesh Dattani", "Lawrence Marwong", "Rob Nertney", "Jeff Liott", "Miro Enev", "Divya Ramakrishnan", "Ian Buck", "Jonah Alben"], "title": "Power Stabilization for AI Training Datacenters", "comment": null, "summary": "Large Artificial Intelligence (AI) training workloads spanning several tens\nof thousands of GPUs present unique power management challenges. These arise\ndue to the high variability in power consumption during the training. Given the\nsynchronous nature of these jobs, during every iteration there is a\ncomputation-heavy phase, where each GPU works on the local data, and a\ncommunication-heavy phase where all the GPUs synchronize on the data. Because\ncompute-heavy phases require much more power than communication phases, large\npower swings occur. The amplitude of these power swings is ever increasing with\nthe increase in the size of training jobs. An even bigger challenge arises from\nthe frequency spectrum of these power swings which, if harmonized with critical\nfrequencies of utilities, can cause physical damage to the power grid\ninfrastructure. Therefore, to continue scaling AI training workloads safely, we\nneed to stabilize the power of such workloads. This paper introduces the\nchallenge with production data and explores innovative solutions across the\nstack: software, GPU hardware, and datacenter infrastructure. We present the\npros and cons of each of these approaches and finally present a multi-pronged\napproach to solving the challenge. The proposed solutions are rigorously tested\nusing a combination of real hardware and Microsoft's in-house cloud power\nsimulator, providing critical insights into the efficacy of these interventions\nunder real-world conditions."}
{"id": "2508.14798", "categories": ["cs.AR", "eess.SP"], "pdf": "https://arxiv.org/pdf/2508.14798", "abs": "https://arxiv.org/abs/2508.14798", "authors": ["Soumyo Bhattacharjee", "Federico Villani", "Christian Vogt", "Andrea Cossettini", "Luca Benini"], "title": "ListenToJESD204B: A Lightweight Open-Source JESD204B IP Core for FPGA-Based Ultrasound Acquisition systems", "comment": "This work has been accepted for publication in IEEE IWASI Conference\n  proceedings. The final published version will be available via IEEE Xplore", "summary": "The demand for hundreds of tightly synchronized channels operating at tens of\nMSPS in ultrasound systems exceeds conventional low-voltage differential\nsignaling links' bandwidth, pin count, and latency. Although the JESD204B\nserial interface mitigates these limitations, commercial FPGA IP cores are\nproprietary, costly, and resource-intensive. We present ListenToJESD204B, an\nopen-source receiver IP core released under a permissive Solderpad 0.51 license\nfor AMD Xilinx Zynq UltraScale+ devices. Written in synthesizable\nSystemVerilog, the core supports four GTH/GTY lanes at 12.8 Gb/s and provides\ncycle-accurate AXI-Stream data alongside deterministic Subclass~1 latency. It\noccupies only 107 configurable logic blocks (approximately 437 LUTs),\nrepresenting a 79\\% reduction compared to comparable commercially available IP.\nA modular data path featuring per-lane elastic buffers, SYSREF-locked LMFC\ngeneration, and optional LFSR descrambling facilitates scaling to high lane\ncounts. We verified protocol compliance through simulation against the Xilinx\nJESD204C IP in JESD204B mode and on hardware using TI AFE58JD48 ADCs. Block\nstability was verified by streaming 80 MSPS, 16-bit samples over two 12.8 Gb/s\nlinks for 30 minutes with no errors."}
