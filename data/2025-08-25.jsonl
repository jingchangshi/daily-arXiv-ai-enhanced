{"id": "2508.15919", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.15919", "abs": "https://arxiv.org/abs/2508.15919", "authors": ["Zahra Yousefijamarani", "Xinglu Wang", "Qian Wang", "Morgan Lindsay Heisler", "Taha Shabani", "Niloofar Gholipour", "Parham Yassini", "Hong Chang", "Kan Chen", "Qiantao Zhang", "Xiaolong Bai", "Jiannan Wang", "Ying Xiong", "Yong Zhang", "Zhenan Fan"], "title": "HyperFlexis: Joint Design of Algorithms and Systems for Multi-SLO Serving and Fast Scaling", "comment": null, "summary": "Modern large language model (LLM) serving systems face challenges from highly\nvariable requests with diverse lengths, priorities, and stage-specific\nservice-level objectives (SLOs). Meeting these requires real-time scheduling,\nrapid and cost-effective scaling, and support for both collocated and\ndisaggregated Prefill/Decode (P/D) architectures.\n  We present \\textbf{HyperFlexis}, a unified LLM serving system that integrates\nalgorithmic and system-level innovations to jointly optimize scheduling and\nscaling under multiple SLOs. It features a multi-SLO-aware scheduler that\nleverages budget estimation and request prioritization to ensure proactive SLO\ncompliance for both new and ongoing requests. The system supports prefill- and\ndecode-stage multi-SLO scheduling for P/D-disaggregated architectures and KV\ncache transfers. It also enables cost-effective scaling decisions,\nprefill-decode instance linking during scaling, and rapid P/D role transitions.\nTo accelerate scaling and reduce cold-start latency, a device-to-device (D2D)\nweight transfer mechanism is proposed that lowers weight loading overhead by up\nto \\textbf{19.39$\\times$}. These optimizations allow the system to achieve up\nto \\textbf{4.44$\\times$} higher SLO attainment, \\textbf{65.82\\%} lower request\nlatency, and cost parity with state-of-the-art baselines. The code will be\nreleased soon."}
{"id": "2508.16308", "categories": ["cs.DC", "cs.CC", "F.2.2; G.2.2"], "pdf": "https://arxiv.org/pdf/2508.16308", "abs": "https://arxiv.org/abs/2508.16308", "authors": ["Jan Bok", "Avinandan Das", "Anna Gujgiczer", "Nikola Jedličková"], "title": "Generalizing Brooks' theorem via Partial Coloring is Hard Classically and Locally", "comment": null, "summary": "We investigate the classical and distributed complexity of \\emph{$k$-partial\n$c$-coloring} where $c=k$, a natural generalization of Brooks' theorem where\neach vertex should be colored from the palette $\\{1,\\ldots,c\\} =\n\\{1,\\ldots,k\\}$ such that it must have at least $\\min\\{k, \\deg(v)\\}$ neighbors\ncolored differently. Das, Fraigniaud, and Ros{\\'{e}}n~[OPODIS 2023] showed that\nthe problem of $k$-partial $(k+1)$-coloring admits efficient centralized and\ndistributed algorithms and posed an open problem about the status of the\ndistributed complexity of $k$-partial $k$-coloring. We show that the problem\nbecomes significantly harder when the number of colors is reduced from $k+1$ to\n$k$ for every constant $k\\geq 3$.\n  In the classical setting, we prove that deciding whether a graph admits a\n$k$-partial $k$-coloring is NP-complete for every constant $k \\geq 3$,\nrevealing a sharp contrast with the linear-time solvable $(k+1)$-color case.\nFor the distributed LOCAL model, we establish an $\\Omega(n)$-round lower bound\nfor computing $k$-partial $k$-colorings, even when the graph is guaranteed to\nbe $k$-partial $k$-colorable. This demonstrates an exponential separation from\nthe $O(\\log^2 k \\cdot \\log n)$-round algorithms known for $(k+1)$-colorings.\n  Our results leverage novel structural characterizations of ``hard instances''\nwhere partial coloring reduces to proper coloring, and we construct intricate\ngraph gadgets to prove lower bounds via indistinguishability arguments."}
{"id": "2508.16522", "categories": ["cs.PL", "cs.DC"], "pdf": "https://arxiv.org/pdf/2508.16522", "abs": "https://arxiv.org/abs/2508.16522", "authors": ["Rohan Yadav", "Joseph Guman", "Sean Treichler", "Michael Garland", "Alex Aiken", "Fredrik Kjolstad", "Michael Bauer"], "title": "On the Duality of Task and Actor Programming Models", "comment": null, "summary": "Programming models for distributed and heterogeneous machines are rapidly\ngrowing in popularity to meet the demands of modern workloads. Task and actor\nmodels are common choices that offer different trade-offs between development\nproductivity and achieved performance. Task-based models offer better\nproductivity and composition of software, whereas actor-based models routinely\ndeliver better peak performance due to lower overheads. While task-based and\nactor-based models appear to be different superficially, we demonstrate these\nprogramming models are duals of each other. Importantly, we show that this\nduality extends beyond functionality to performance, and elucidate techniques\nthat let task-based systems deliver performance competitive with actor-based\nsystems without compromising productivity. We apply these techniques to both\nRealm, an explicitly parallel task-based runtime, as well as Legion, an\nimplicitly parallel task-based runtime. We show these techniques reduce Realm's\noverheads by between 1.7-5.3x, coming within a factor of two of the overheads\nimposed by heavily optimized actor-based systems like Charm++ and MPI. We\nfurther show that our techniques enable between 1.3-5.0x improved strong\nscaling of unmodified Legion applications."}
{"id": "2508.15866", "categories": ["cs.PL", "cs.LG", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15866", "abs": "https://arxiv.org/abs/2508.15866", "authors": ["Lingxiao Li", "Salar Rahili", "Yiwei Zhao"], "title": "Correctness-Guaranteed Code Generation via Constrained Decoding", "comment": "Published at COLM 2025", "summary": "Language Models (LMs) are increasingly being used for code generation, but\nensuring the correctness of generated programs remains a significant challenge.\nAlthough imperfect code may be acceptable during software development with\nhuman oversight, domains such as video games and robotics require one-shot\ncorrectness for runtime-critical components. We present a constrained decoding\nalgorithm for generating semantically correct programs that incorporates a\ncontext-sensitive parser, which, at each step, outputs a regular expression\nthat satisfies a critical non-extensible property to guide the generation of\nthe next token sequence that can continue to a correct program. To build such a\ncontext-sensitive parser, we propose a framework of a dynamic tree of parsers\n(ToP) during parsing, where each parser corresponds to a modular context-free\ngrammar enriched with contextual information such as variable scopes and type\nconstraints, with tree branches representing ambiguity in the future code\nsegment. We demonstrate our approach through sLua, a strongly typed variant of\nLua, showing that our method can generate semantically correct programs\nconforming to any prescribed scripting API. We further show that, with careful\ndesign, our semantic guarantees extend to runtime correctness, as validated in\nthe application of generating game mechanics for a roguelike video game."}
{"id": "2508.15940", "categories": ["cs.AR", "cs.AI", "cs.CL", "cs.DC", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.15940", "abs": "https://arxiv.org/abs/2508.15940", "authors": ["Ahmed Allam", "Youssef Mansour", "Mohamed Shalan"], "title": "ASIC-Agent: An Autonomous Multi-Agent System for ASIC Design with Benchmark Evaluation", "comment": "2025 IEEE International Conference on LLM-Aided Design (ICLAD)", "summary": "Large Language Models (LLMs) have demonstrated remarkable capabilities in\nRegister Transfer Level (RTL) design, enabling high-quality code generation\nfrom natural language descriptions. However, LLMs alone face significant\nlimitations in real-world hardware design workflows, including the inability to\nexecute code, lack of debugging capabilities, and absence of long-term memory.\nTo address these challenges, we present ASIC-Agent, an autonomous system\ndesigned specifically for digital ASIC design tasks. ASIC-Agent enhances base\nLLMs with a multi-agent architecture incorporating specialized sub-agents for\nRTL generation, verification, OpenLane hardening, and Caravel chip integration,\nall operating within a comprehensive sandbox environment with access to\nessential hardware design tools. The system leverages a vector database\ncontaining documentation, API references, error knowledge, and curated insights\nfrom the open-source silicon community. To evaluate ASIC-Agent's performance,\nwe introduce ASIC-Agent-Bench, the first benchmark specifically designed to\nassess agentic systems in hardware design tasks. We evaluate ASIC-Agent with\nvarious base LLMs, providing quantitative comparisons and qualitative insights\ninto agent behavior across different design scenarios. Our results demonstrate\nthat ASIC-Agent, when powered by Claude 4 Sonnet, successfully automates a\nbroad range of ASIC design tasks spanning varying levels of complexity, showing\nthe potential of significantly accelerating the ASIC design workflow."}
{"id": "2508.15898", "categories": ["cs.PL", "cs.CR"], "pdf": "https://arxiv.org/pdf/2508.15898", "abs": "https://arxiv.org/abs/2508.15898", "authors": ["Matthew Sotoudeh", "Zachary Yedidia"], "title": "Automated Formal Verification of a Software Fault Isolation System", "comment": "Short paper to appear at FMCAD 2025, https://fmcad.org/", "summary": "Software fault isolation (SFI) is a popular way to sandbox untrusted\nsoftware. A key component of SFI is the verifier that checks the untrusted code\nis written in a subset of the machine language that guarantees it never reads\nor writes outside of a region of memory dedicated to the sandbox. Soundness\nbugs in the SFI verifier would break the SFI security model and allow the\nsupposedly sandboxed code to read protected memory. In this paper, we address\nthe concern of SFI verifier bugs by performing an automated formal verification\nof a recent SFI system called Lightweight Fault Isolation (LFI). In particular,\nwe formally verify that programs accepted by the LFI verifier never read or\nwrite to memory outside of a designated sandbox region."}
{"id": "2508.16095", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.16095", "abs": "https://arxiv.org/abs/2508.16095", "authors": ["Vineet Kumar", "Ajay Kumar M", "Yike Li", "Shreejith Shanker", "Deepu John"], "title": "Bare-Metal RISC-V + NVDLA SoC for Efficient Deep Learning Inference", "comment": "Accepted paper in 2025 IEEE 38th International System-on-Chip\n  Conference (SOCC)", "summary": "This paper presents a novel System-on-Chip (SoC) architecture for\naccelerating complex deep learning models for edge computing applications\nthrough a combination of hardware and software optimisations. The hardware\narchitecture tightly couples the open-source NVIDIA Deep Learning Accelerator\n(NVDLA) to a 32-bit, 4-stage pipelined RISC-V core from Codasip called uRISC_V.\nTo offload the model acceleration in software, our toolflow generates\nbare-metal application code (in assembly), overcoming complex OS overheads of\nprevious works that have explored similar architectures. This tightly coupled\narchitecture and bare-metal flow leads to improvements in execution speed and\nstorage efficiency, making it suitable for edge computing solutions. We\nevaluate the architecture on AMD's ZCU102 FPGA board using NVDLA-small\nconfiguration and test the flow using LeNet-5, ResNet-18 and ResNet-50 models.\nOur results show that these models can perform inference in 4.8 ms, 16.2 ms and\n1.1 s respectively, at a system clock frequency of 100 MHz."}
{"id": "2508.16063", "categories": ["cs.PL", "cs.FL"], "pdf": "https://arxiv.org/pdf/2508.16063", "abs": "https://arxiv.org/abs/2508.16063", "authors": ["Paul Krogmeier", "P. Madhusudan"], "title": "Synthesizing DSLs for Few-Shot Learning", "comment": null, "summary": "We study the problem of synthesizing domain-specific languages (DSLs) for\nfew-shot learning in symbolic domains. Given a base language and instances of\nfew-shot learning problems, where each instance is split into training and\ntesting samples, the DSL synthesis problem asks for a grammar over the base\nlanguage that guarantees that small expressions solving training samples also\nsolve corresponding testing samples. We prove that the problem is decidable for\na class of languages whose semantics over fixed structures can be evaluated by\ntree automata and when expression size corresponds to parse tree depth in the\ngrammar, and, furthermore, the grammars solving the problem correspond to a\nregular set of trees. We also prove decidability results for variants of the\nproblem where DSLs are only required to express solutions for input learning\nproblems and where DSLs are defined using macro grammars."}
{"id": "2508.16151", "categories": ["cs.AR", "cs.CL"], "pdf": "https://arxiv.org/pdf/2508.16151", "abs": "https://arxiv.org/abs/2508.16151", "authors": ["Yang Liu", "Yi Chen", "Yongwei Zhao", "Yifan Hao", "Zifu Zheng", "Weihao Kong", "Zhangmai Li", "Dongchen Jiang", "Ruiyang Xia", "Zhihong Ma", "Zisheng Liu", "Zhaoyong Wan", "Yunqi Lu", "Ximing Liu", "Hongrui Guo", "Zhihao Yang", "Zhe Wang", "Tianrui Ma", "Mo Zou", "Rui Zhang", "Ling Li", "Xing Hu", "Zidong Du", "Zhiwei Xu", "Qi Guo", "Tianshi Chen", "Yunji Chen"], "title": "Hardwired-Neurons Language Processing Units as General-Purpose Cognitive Substrates", "comment": null, "summary": "The rapid advancement of Large Language Models (LLMs) has established\nlanguage as a core general-purpose cognitive substrate, driving the demand for\nspecialized Language Processing Units (LPUs) tailored for LLM inference. To\novercome the growing energy consumption of LLM inference systems, this paper\nproposes a Hardwired-Neurons Language Processing Unit (HNLPU), which physically\nhardwires LLM weight parameters into the computational fabric, achieving\nseveral orders of magnitude computational efficiency improvement by extreme\nspecialization. However, a significant challenge still lies in the scale of\nmodern LLMs. An ideal estimation on hardwiring gpt-oss 120 B requires\nfabricating at least 6 billion dollars of photomask sets, rendering the\nstraightforward solution economically impractical. Addressing this challenge,\nwe propose the novel Metal-Embedding methodology. Instead of embedding weights\nin a 2D grid of silicon device cells, Metal-Embedding embeds weight parameters\ninto the 3D topology of metal wires. This brings two benefits: (1) a 15x\nincrease in density, and (2) 60 out of 70 layers of photomasks are made\nhomogeneous across chips, including all EUV photomasks. In total,\nMetal-Embedding reduced the photomask cost by 112x, bringing the Non-Recurring\nEngineering (NRE) cost of HNLPU into an economically viable range. Experimental\nresults show that HNLPU achieved 249,960 tokens/s (5,555x/85x of GPU/WSE), 36\ntokens/J (1,047x/283x of GPU/WSE), 13,232 mm2 total die area (29% inscribed\nrectangular area in a 300 mm wafer), \\$184M estimated NRE at 5 nm technology.\nAnalysis shows that HNLPU achieved 8.57x cost-effectiveness and 230x carbon\nfootprint reduction compared to H100 clusters, under an annual weight updating\nassumption."}
{"id": "2508.16125", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.16125", "abs": "https://arxiv.org/abs/2508.16125", "authors": ["Zhenyang Xu", "Hongxu Xu", "Yongqiang Tian", "Xintong Zhou", "Chengnian Sun"], "title": "Leveraging Large Language Models to Detect Missed Peephole Optimizations", "comment": null, "summary": "By replacing small, suboptimal instruction sequences within programs with a\nmore efficient equivalent, peephole optimization can not only directly optimize\ncode size and performance, but also potentially enables further transformations\nin the subsequent optimization pipeline. Although peephole optimization is a\ncritical class of compiler optimizations, discovering new and effective\npeephole optimizations is challenging as the instruction sets can be extremely\ncomplex and diverse. Previous methods either do not scale well or can only\ncapture a limited subset of peephole optimizations. In this work, we leverage\nLarge Language Models (LLMs) to detect missed peephole optimizations. We\npropose Lampo, a novel automated framework that synergistically combines the\ncreative but unreliable code optimization ability of LLMs with rigorous\ncorrectness verification performed by translation validation tools, integrated\nin a feedback-driven iterative process. Through a comprehensive evaluation\nwithin LLVM ecosystems, we show that Lampo can successfully detect up to 17 out\nof 25 previously reported missed optimizations in LLVM on average, and that 22\nout of 25 can potentially be found by Lampo with different LLMs. For\ncomparison, the state-of-the-art superoptimizer for LLVM, Souper, identified 15\nof them. Moreover, within seven months of development and intermittent\nexperiments, Lampo found 26 missed peephole optimizations, 15 of which have\nbeen confirmed and 6 already fixed. These results demonstrate Lampo's strong\npotential in continuously detecting missed peephole optimizations."}
{"id": "2508.16376", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.16376", "abs": "https://arxiv.org/abs/2508.16376", "authors": ["Jiaping Tang", "Jianan Mu", "Zizhen Liu", "Ge Yu", "Tenghui Hua", "Bin Sun", "Silin Liu", "Jing Ye", "Huawei Li"], "title": "RIROS: A Parallel RTL Fault SImulation FRamework with TwO-Dimensional Parallelism and Unified Schedule", "comment": "Accepted by ICCAD 2025", "summary": "With the rapid development of safety-critical applications such as autonomous\ndriving and embodied intelligence, the functional safety of the corresponding\nelectronic chips becomes more critical. Ensuring chip functional safety\nrequires performing a large number of time-consuming RTL fault simulations\nduring the design phase, significantly increasing the verification cycle. To\nmeet time-to-market demands while ensuring thorough chip verification, parallel\nacceleration of RTL fault simulation is necessary. Due to the dynamic nature of\nfault propagation paths and varying fault propagation capabilities, task loads\nin RTL fault simulation are highly imbalanced, making traditional\nsingledimension parallel methods, such as structural-level parallelism,\nineffective. Through an analysis of fault propagation paths and task loads, we\nidentify two types of tasks in RTL fault simulation: tasks that are few in\nnumber but high in load, and tasks that are numerous but low in load. Based on\nthis insight, we propose a two-dimensional parallel approach that combines\nstructurallevel and fault-level parallelism to minimize bubbles in RTL fault\nsimulation. Structural-level parallelism combining with workstealing mechanism\nis used to handle the numerous low-load tasks, while fault-level parallelism is\napplied to split the high-load tasks. Besides, we deviate from the traditional\nserial execution model of computation and global synchronization in RTL\nsimulation by proposing a unified computation/global synchronization scheduling\napproach, which further eliminates bubbles. Finally, we implemented a parallel\nRTL fault simulation framework, RIROS. Experimental results show a performance\nimprovement of 7.0 times and 11.0 times compared to the state-of-the-art RTL\nfault simulation and a commercial tool."}
{"id": "2508.16522", "categories": ["cs.PL", "cs.DC"], "pdf": "https://arxiv.org/pdf/2508.16522", "abs": "https://arxiv.org/abs/2508.16522", "authors": ["Rohan Yadav", "Joseph Guman", "Sean Treichler", "Michael Garland", "Alex Aiken", "Fredrik Kjolstad", "Michael Bauer"], "title": "On the Duality of Task and Actor Programming Models", "comment": null, "summary": "Programming models for distributed and heterogeneous machines are rapidly\ngrowing in popularity to meet the demands of modern workloads. Task and actor\nmodels are common choices that offer different trade-offs between development\nproductivity and achieved performance. Task-based models offer better\nproductivity and composition of software, whereas actor-based models routinely\ndeliver better peak performance due to lower overheads. While task-based and\nactor-based models appear to be different superficially, we demonstrate these\nprogramming models are duals of each other. Importantly, we show that this\nduality extends beyond functionality to performance, and elucidate techniques\nthat let task-based systems deliver performance competitive with actor-based\nsystems without compromising productivity. We apply these techniques to both\nRealm, an explicitly parallel task-based runtime, as well as Legion, an\nimplicitly parallel task-based runtime. We show these techniques reduce Realm's\noverheads by between 1.7-5.3x, coming within a factor of two of the overheads\nimposed by heavily optimized actor-based systems like Charm++ and MPI. We\nfurther show that our techniques enable between 1.3-5.0x improved strong\nscaling of unmodified Legion applications."}
