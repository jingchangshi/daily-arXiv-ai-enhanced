{"id": "2508.20304", "categories": ["cs.AR", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2508.20304", "abs": "https://arxiv.org/abs/2508.20304", "authors": ["Siyuan Lu", "Kangwei Xu", "Peng Xie", "Rui Wang", "Yuanqing Cheng"], "title": "Testing and Fault Tolerance Techniques for Carbon Nanotube-Based FPGAs", "comment": "Accepted by Integration, VLSI Journal", "summary": "As the semiconductor manufacturing process technology node shrinks into the\nnanometer-scale, the CMOS-based Field Programmable Gate Arrays (FPGAs) face big\nchallenges in scalability of performance and power consumption. Multi-walled\nCarbon Nanotube (MWCNT) serves as a promising candidate for Cu interconnects\nthanks to the superior conductivity. Moreover, Carbon Nanotube Field Transistor\n(CNFET) also emerges as a prospective alternative to the conventional CMOS\ndevice because of high power efficiency and large noise margin. The combination\nof MWCNT and CNFET enables the promising CNT-based FPGAs. However, the MWCNT\ninterconnects exhibit significant process variations due to immature\nfabrication process, leading to delay faults. Also, the non-ideal CNFET\nfabrication process may generate a few metallic CNTs (m-CNTs), rendering\ncorrelated faulty blocks. In this article, we propose a ring oscillator (RO)\nbased testing technique to detect delay faults due to the process variation of\nMWCNT interconnects. Furthermore, we propose an effective testing technique for\nthe carry chains in CLBs, and an improved circuit design based on the lookup\ntable (LUT) is applied to speed up the fault testing of CNT-based FPGAs. In\naddition, we propose a testing algorithm to detect m-CNTs in CLBs. Finally, we\npropose a redundant spare row sharing architecture to improve the yield of\nCNT-based FPGA further. Experimental results show that the test time for a\n6-input LUT can be reduced by 35.49% compared with conventional testing, and\nthe proposed algorithm can achieve a high test coverage with little overhead.\nThe proposed redundant architecture can repair the faulty segment effectively\nand efficiently."}
{"id": "2508.20425", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.20425", "abs": "https://arxiv.org/abs/2508.20425", "authors": ["Shuhan Liu", "Samuel Dayo", "Peijing Li", "Philip Levis", "Subhasish Mitra", "Thierry Tambe", "David Tennenhouse", "H. -S. Philip Wong"], "title": "The Future of Memory: Limits and Opportunities", "comment": "3 Pages, 2 Figures, 1 Table, Accepted to SOSP 25 BigMem Workshop", "summary": "Memory latency, bandwidth, capacity, and energy increasingly limit\nperformance. In this paper, we reconsider proposed system architectures that\nconsist of huge (many-terabyte to petabyte scale) memories shared among large\nnumbers of CPUs. We argue two practical engineering challenges, scaling and\nsignaling, limit such designs. We propose the opposite approach. Rather than\ncreate large, shared, homogenous memories, systems explicitly break memory up\ninto smaller slices more tightly coupled with compute elements. Leveraging\nadvances in 2.5D/3D integration, this compute-memory node provisions private\nlocal memory, enabling accesses of node-exclusive data through micrometer-scale\ndistances, and dramatically reduced access cost. In-package memory elements\nsupport shared state within a processor, providing far better bandwidth and\nenergy-efficiency than DRAM, which is used as main memory for large working\nsets and cold data. Hardware making memory capacities and distances explicit\nallows software to efficiently compose this hierarchy, managing data placement\nand movement."}
{"id": "2508.20653", "categories": ["cs.AR", "cs.CR", "cs.NI"], "pdf": "https://arxiv.org/pdf/2508.20653", "abs": "https://arxiv.org/abs/2508.20653", "authors": ["Alperen Bolat", "Sakir Sezer", "Kieran McLaughlin", "Henry Hui"], "title": "Microarchitecture Design and Benchmarking of Custom SHA-3 Instruction for RISC-V", "comment": "Extended version of IEEE ISVLSI Conference Paper", "summary": "Integrating cryptographic accelerators into modern CPU architectures presents\nunique microarchitectural challenges, particularly when extending instruction\nsets with complex and multistage operations. Hardware-assisted cryptographic\ninstructions, such as Intel's AES-NI and ARM's custom instructions for\nencryption workloads, have demonstrated substantial performance improvements.\nHowever, efficient SHA-3 acceleration remains an open problem due to its\ndistinct permutation-based structure and memory access patterns. Existing\nsolutions primarily rely on standalone coprocessors or software optimizations,\noften avoiding the complexities of direct microarchitectural integration. This\nstudy investigates the architectural challenges of embedding a SHA-3\npermutation operation as a custom instruction within a general-purpose\nprocessor, focusing on pipelined simultaneous execution, storage utilization,\nand hardware cost. In this paper, we investigated and prototyped a SHA-3 custom\ninstruction for the RISC-V CPU architecture. Using cycle-accurate GEM5\nsimulations and FPGA prototyping, our results demonstrate performance\nimprovements of up to 8.02x for RISC-V optimized SHA-3 software workloads and\nup to 46.31x for Keccak-specific software workloads, with only a 15.09%\nincrease in registers and a 11.51% increase in LUT utilization. These findings\nprovide critical insights into the feasibility and impact of SHA-3 acceleration\nat the microarchitectural level, highlighting practical design considerations\nfor future cryptographic instruction set extensions."}
{"id": "2508.20253", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2508.20253", "abs": "https://arxiv.org/abs/2508.20253", "authors": ["Ruihao Li", "Qinzhe Wu", "Krishna Kavi", "Gayatri Mehta", "Jonathan C. Beard", "Neeraja J. Yadwadkar", "Lizy K. John"], "title": "SpeedMalloc: Improving Multi-threaded Applications via a Lightweight Core for Memory Allocation", "comment": null, "summary": "Memory allocation, though constituting only a small portion of the executed\ncode, can have a \"butterfly effect\" on overall program performance, leading to\nsignificant and far-reaching impacts. Despite accounting for just approximately\n5% of total instructions, memory allocation can result in up to a 2.7x\nperformance variation depending on the allocator used. This effect arises from\nthe complexity of memory allocation in modern multi-threaded multi-core\nsystems, where allocator metadata becomes intertwined with user data, leading\nto cache pollution or increased cross-thread synchronization overhead.\nOffloading memory allocators to accelerators, e.g., Mallacc and Memento, is a\npotential direction to improve the allocator performance and mitigate cache\npollution. However, these accelerators currently have limited support for\nmulti-threaded applications, and synchronization between cores and accelerators\nremains a significant challenge.\n  We present SpeedMalloc, using a lightweight support-core to process memory\nallocation tasks in multi-threaded applications. The support-core is a\nlightweight programmable processor with efficient cross-core data\nsynchronization and houses all allocator metadata in its own caches. This\ndesign minimizes cache conflicts with user data and eliminates the need for\ncross-core metadata synchronization. In addition, using a general-purpose core\ninstead of domain-specific accelerators makes SpeedMalloc capable of adopting\nnew allocator designs. We compare SpeedMalloc with state-of-the-art software\nand hardware allocators, including Jemalloc, TCMalloc, Mimalloc, Mallacc, and\nMemento. SpeedMalloc achieves 1.75x, 1.18x, 1.15x, 1.23x, and 1.18x speedups on\nmultithreaded workloads over these five allocators, respectively."}
{"id": "2508.20253", "categories": ["cs.DC", "cs.AR"], "pdf": "https://arxiv.org/pdf/2508.20253", "abs": "https://arxiv.org/abs/2508.20253", "authors": ["Ruihao Li", "Qinzhe Wu", "Krishna Kavi", "Gayatri Mehta", "Jonathan C. Beard", "Neeraja J. Yadwadkar", "Lizy K. John"], "title": "SpeedMalloc: Improving Multi-threaded Applications via a Lightweight Core for Memory Allocation", "comment": null, "summary": "Memory allocation, though constituting only a small portion of the executed\ncode, can have a \"butterfly effect\" on overall program performance, leading to\nsignificant and far-reaching impacts. Despite accounting for just approximately\n5% of total instructions, memory allocation can result in up to a 2.7x\nperformance variation depending on the allocator used. This effect arises from\nthe complexity of memory allocation in modern multi-threaded multi-core\nsystems, where allocator metadata becomes intertwined with user data, leading\nto cache pollution or increased cross-thread synchronization overhead.\nOffloading memory allocators to accelerators, e.g., Mallacc and Memento, is a\npotential direction to improve the allocator performance and mitigate cache\npollution. However, these accelerators currently have limited support for\nmulti-threaded applications, and synchronization between cores and accelerators\nremains a significant challenge.\n  We present SpeedMalloc, using a lightweight support-core to process memory\nallocation tasks in multi-threaded applications. The support-core is a\nlightweight programmable processor with efficient cross-core data\nsynchronization and houses all allocator metadata in its own caches. This\ndesign minimizes cache conflicts with user data and eliminates the need for\ncross-core metadata synchronization. In addition, using a general-purpose core\ninstead of domain-specific accelerators makes SpeedMalloc capable of adopting\nnew allocator designs. We compare SpeedMalloc with state-of-the-art software\nand hardware allocators, including Jemalloc, TCMalloc, Mimalloc, Mallacc, and\nMemento. SpeedMalloc achieves 1.75x, 1.18x, 1.15x, 1.23x, and 1.18x speedups on\nmultithreaded workloads over these five allocators, respectively."}
{"id": "2508.20365", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.20365", "abs": "https://arxiv.org/abs/2508.20365", "authors": ["Naoki Kobayashi", "Ryosuke Sato", "Ayumi Shinohara", "Ryo Yoshinaka"], "title": "Solvable Tuple Patterns and Their Applications to Program Verification", "comment": null, "summary": "Despite the recent progress of automated program verification techniques,\nfully automated verification of programs manipulating recursive data structures\nremains a challenge. We introduce the notion of solvable tuple patterns (STPs)\nto express invariants between list-like recursive data structures. A\ndistinguishing feature of STPs is that they can be efficiently inferred from\nonly a small number of positive samples; no negative samples are required. An\nSMT solver that supports the sequence theory can be used to check that an\ninferred STP is indeed an inductive invariant. After presenting basic\nproperties of STPs and an STP inference algorithm, we show how to incorporate\nthe STP inference into a CHC (Constrained Horn Clauses) solver supporting\nlist-like data structures, which serves as a uniform backend for automated\nprogram verification tools. A CHC solver incorporating the STP inference has\nwon the ADT-LIN category of CHC-COMP 2025 by a big margin."}
{"id": "2508.20258", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.20258", "abs": "https://arxiv.org/abs/2508.20258", "authors": ["Arya Tschand", "Muhammad Awad", "Ryan Swann", "Kesavan Ramakrishnan", "Jeffrey Ma", "Keith Lowery", "Ganesh Dasika", "Vijay Janapa Reddi"], "title": "SwizzlePerf: Hardware-Aware LLMs for GPU Kernel Performance Optimization", "comment": null, "summary": "Large language models (LLMs) have shown progress in GPU kernel performance\nengineering using inefficient search-based methods that optimize around\nruntime. Any existing approach lacks a key characteristic that human\nperformance engineers rely on for near-optimal utilization --\nhardware-awareness. By leveraging the workload's specific memory access\npatterns, architecture specifications, filtered profiling logs, and reflections\non historical performance, we can make software-level optimizations that are\ntailored to the underlying hardware. SwizzlePerf automatically generates\nspatial optimizations for GPU kernels on disaggregated architectures by giving\nLLMs explicit hardware-awareness.\n  For a GEMM kernel, SwizzlePerf takes less than 5 minutes to generate the same\nhardware-specific optimal swizzling pattern that took expert performance\nengineers 2 weeks to find. On a suite of 10 diverse ML and Science kernels,\nSwizzlePerf can generate swizzling patterns for 9 of the kernels that achieve\nup to a 2.06x speedup and 70% improvement in L2 hit rate. This work is the\nfirst of many steps toward systematically creating hardware-aware LLM\nperformance engineering agents."}
{"id": "2508.20922", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.20922", "abs": "https://arxiv.org/abs/2508.20922", "authors": ["Markus Böck", "Jürgen Cito"], "title": "Static Factorisation of Probabilistic Programs With User-Labelled Sample Statements and While Loops", "comment": null, "summary": "It is commonly known that any Bayesian network can be implemented as a\nprobabilistic program, but the reverse direction is not so clear. In this work,\nwe address the open question to what extent a probabilistic program with\nuser-labelled sample statements and while loops - features found in languages\nlike Gen, Turing, and Pyro - can be represented graphically. To this end, we\nextend existing operational semantics to support these language features. By\ntranslating a program to its control-flow graph, we define a sound static\nanalysis that approximates the dependency structure of the random variables in\nthe program. As a result, we obtain a static factorisation of the implicitly\ndefined program density, which is equivalent to the known Bayesian network\nfactorisation for programs without loops and constant labels, but constitutes a\nnovel graphical representation for programs that define an unbounded number of\nrandom variables via loops or dynamic labels. We further develop a sound\nprogram slicing technique to leverage this structure to statically enable three\nwell-known optimisations for the considered program class: we reduce the\nvariance of gradient estimates in variational inference and we speed up both\nsingle-site Metropolis Hastings and sequential Monte Carlo. These optimisations\nare proven correct and empirically shown to match or outperform existing\ntechniques."}
{"id": "2508.20274", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.20274", "abs": "https://arxiv.org/abs/2508.20274", "authors": ["Erfan Darzi", "Shreeanant Bharadwaj", "Sree Bhargavi Balija"], "title": "Predictable LLM Serving on GPU Clusters", "comment": null, "summary": "Latency-sensitive inference on shared A100 clusters often suffers\nnoisy-neighbor interference on the PCIe fabric, inflating tail latency and SLO\nviolations. We present a fabric-agnostic, VM-deployable host-level controller\nthat combines dynamic Multi-Instance GPU (MIG) reconfiguration, PCIe-aware\nplacement, and lightweight guardrails (MPS quotas, cgroup I/O). It samples\nper-tenant tails and system signals, uses topology hints to avoid PCIe hot\nspots, and gates actions with dwell/cool-down to avoid thrash. On a single host\nand a 2-node (16-GPU) cluster, SLO miss-rate is reduced by \\(\\approx\\)32\\%\n(\\(\\approx\\)1.5) and p99 latency improves \\(\\approx\\)15\\% with \\(\\leq\\)5\\%\nthroughput cost versus static MIG and naive placement; ablations show MIG and\nplacement contribute comparably. We also evaluate LLM serving with vLLM on OLMo\n2 7B Instruct: TTFT p99 improves \\(\\approx\\)10--15\\% at \\(\\leq\\)5\\% cost\nwithout changing the controller."}
{"id": "2508.20375", "categories": ["cs.DC", "cs.LG", "cs.PF"], "pdf": "https://arxiv.org/pdf/2508.20375", "abs": "https://arxiv.org/abs/2508.20375", "authors": ["Guanyu Xu", "Zhiwei Hao", "Li Shen", "Yong Luo", "Fuhui Sun", "Xiaoyan Wang", "Han Hu", "Yonggang Wen"], "title": "CoFormer: Collaborating with Heterogeneous Edge Devices for Scalable Transformer Inference", "comment": "Accepted by IEEE Transactions on Computers", "summary": "The impressive performance of transformer models has sparked the deployment\nof intelligent applications on resource-constrained edge devices. However,\nensuring high-quality service for real-time edge systems is a significant\nchallenge due to the considerable computational demands and resource\nrequirements of these models. Existing strategies typically either offload\ntransformer computations to other devices or directly deploy compressed models\non individual edge devices. These strategies, however, result in either\nconsiderable communication overhead or suboptimal trade-offs between accuracy\nand efficiency. To tackle these challenges, we propose a collaborative\ninference system for general transformer models, termed CoFormer. The central\nidea behind CoFormer is to exploit the divisibility and integrability of\ntransformer. An off-the-shelf large transformer can be decomposed into multiple\nsmaller models for distributed inference, and their intermediate results are\naggregated to generate the final output. We formulate an optimization problem\nto minimize both inference latency and accuracy degradation under heterogeneous\nhardware constraints. DeBo algorithm is proposed to first solve the\noptimization problem to derive the decomposition policy, and then progressively\ncalibrate decomposed models to restore performance. We demonstrate the\ncapability to support a wide range of transformer models on heterogeneous edge\ndevices, achieving up to 3.1$\\times$ inference speedup with large transformer\nmodels. Notably, CoFormer enables the efficient inference of GPT2-XL with 1.6\nbillion parameters on edge devices, reducing memory requirements by 76.3\\%.\nCoFormer can also reduce energy consumption by approximately 40\\% while\nmaintaining satisfactory inference performance."}
{"id": "2508.20403", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.20403", "abs": "https://arxiv.org/abs/2508.20403", "authors": ["Tiancheng Zhao", "Zekun Yin", "Huihai An", "Xiaoyu Yang", "Zhou Jin", "Jiasi Shen", "Helen Xu"], "title": "pdGRASS: A Fast Parallel Density-Aware Algorithm for Graph Spectral Sparsification", "comment": null, "summary": "Graph Spectral Sparsification (GSS) identifies an ultra-sparse subgraph, or\nsparsifier, whose Laplacian matrix closely approximates the spectral properties\nof the original graph, enabling substantial reductions in computational\ncomplexity for computationally intensive problems in scientific computing. The\nstate-of-the-art method for efficient GSS is feGRASS, consisting of two steps:\n1) spanning tree generation and 2) off-tree edge recovery. However, feGRASS\nsuffers from two main issues: 1) difficulties in parallelizing the recovery\nstep for strict data dependencies, and 2) performance degradation on skewed\ninputs, often requiring multiple passes to recover sufficient edges. To address\nthese challenges, we propose parallel density-aware Graph Spectral\nSparsification (pdGRASS), a parallel algorithm that organizes edges into\ndisjoint subtasks without data dependencies between them, enabling efficient\nparallelization and sufficient edge recovery in a single pass. We empirically\nevaluate feGRASS and pdGRASS based on 1) off-tree edge-recovery runtime and 2)\nsparsifier quality, measured by the iteration count required for convergence in\na preconditioned conjugate gradient (PCG) application. The evaluation\ndemonstrates that, depending on the number of edges recovered, pdGRASS achieves\naverage speedups ranging from 3.9x to 8.8x. The resulting sparsifiers also show\nbetween 1.2x higher and 1.8x lower PCG iteration counts, with further\nimprovements as more edges are recovered. Additionally, pdGRASS mitigates the\nworst-case runtimes of feGRASS with over 1000x speedup. These results highlight\npdGRASS's significant improvements in scalability and performance for the graph\nspectral sparsification problem."}
{"id": "2508.20508", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.20508", "abs": "https://arxiv.org/abs/2508.20508", "authors": ["Yilin Li", "Song Han", "Sibo Wang", "Ming Wang", "Renzi Meng"], "title": "Collaborative Evolution of Intelligent Agents in Large-Scale Microservice Systems", "comment": null, "summary": "This paper proposes an intelligent service optimization method based on a\nmulti-agent collaborative evolution mechanism to address governance challenges\nin large-scale microservice architectures. These challenges include complex\nservice dependencies, dynamic topology structures, and fluctuating workloads.\nThe method models each service as an agent and introduces graph representation\nlearning to construct a service dependency graph. This enables agents to\nperceive and embed structural changes within the system. Each agent learns its\npolicy based on a Markov Decision Process. A centralized training and\ndecentralized execution framework is used to integrate local autonomy with\nglobal coordination. To enhance overall system performance and adaptability, a\ngame-driven policy optimization mechanism is designed. Through a\nselection-mutation process, agent strategy distributions are dynamically\nadjusted. This supports adaptive collaboration and behavioral evolution among\nservices. Under this mechanism, the system can quickly respond and achieve\nstable policy convergence when facing scenarios such as sudden workload spikes,\ntopology reconfigurations, or resource conflicts. To evaluate the effectiveness\nof the proposed method, experiments are conducted on a representative\nmicroservice simulation platform. Comparative analyses are performed against\nseveral advanced approaches, focusing on coordination efficiency, adaptability,\nand policy convergence performance. Experimental results show that the proposed\nmethod outperforms others in several key metrics. It significantly improves\ngovernance efficiency and operational stability in large-scale microservice\nsystems. The method demonstrates strong practical value and engineering\nfeasibility."}
