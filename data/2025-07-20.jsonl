{"id": "2507.12792", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2507.12792", "abs": "https://arxiv.org/abs/2507.12792", "authors": ["Yiliang Wan", "Nitin Shivaraman", "Akshaye Shenoi", "Xiang Liu", "Tao Luo", "Jialin Li"], "title": "Building State Machine Replication Using Practical Network Synchrony", "comment": "12 pages, 10 figures", "summary": "Distributed systems, such as state machine replication, are critical\ninfrastructures for modern applications. Practical distributed protocols make\nminimum assumptions about the underlying network: They typically assume a\npartially synchronous or fully asynchronous network model. In this work, we\nargue that modern data center systems can be designed to provide strong\nsynchrony properties in the common case, where servers move in synchronous\nlock-step rounds. We prove this hypothesis by engineering a practical design\nthat uses a combination of kernel-bypass network, multithreaded architecture,\nand loosened round length, achieving a tight round bound under 2us. Leveraging\nour engineered networks with strong synchrony, we co-design a new replication\nprotocol, Chora. Chora exploits the network synchrony property to efficiently\npipeline multiple replication instances, while allowing all replicas to propose\nin parallel without extra coordination. Through experiments, we show that Chora\nachieves 255% and 109% improvement in throughput over state-of-the-art\nsingle-leader and multi-leader protocols, respectively."}
{"id": "2507.12879", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.12879", "abs": "https://arxiv.org/abs/2507.12879", "authors": ["Yujun Zou", "Nia Qi", "Yingnan Deng", "Zhihao Xue", "Ming Gong", "Wuyang Zhang"], "title": "Autonomous Resource Management in Microservice Systems via Reinforcement Learning", "comment": null, "summary": "This paper proposes a reinforcement learning-based method for microservice\nresource scheduling and optimization, aiming to address issues such as uneven\nresource allocation, high latency, and insufficient throughput in traditional\nmicroservice architectures. In microservice systems, as the number of services\nand the load increase, efficiently scheduling and allocating resources such as\ncomputing power, memory, and storage becomes a critical research challenge. To\naddress this, the paper employs an intelligent scheduling algorithm based on\nreinforcement learning. Through the interaction between the agent and the\nenvironment, the resource allocation strategy is continuously optimized. In the\nexperiments, the paper considers different resource conditions and load\nscenarios, evaluating the proposed method across multiple dimensions, including\nresponse time, throughput, resource utilization, and cost efficiency. The\nexperimental results show that the reinforcement learning-based scheduling\nmethod significantly improves system response speed and throughput under low\nload and high concurrency conditions, while also optimizing resource\nutilization and reducing energy consumption. Under multi-dimensional resource\nconditions, the proposed method can consider multiple objectives and achieve\noptimized resource scheduling. Compared to traditional static resource\nallocation methods, the reinforcement learning model demonstrates stronger\nadaptability and optimization capability. It can adjust resource allocation\nstrategies in real time, thereby maintaining good system performance in\ndynamically changing load and resource environments."}
{"id": "2507.12471", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2507.12471", "abs": "https://arxiv.org/abs/2507.12471", "authors": ["Petr Kourzanov", "Anmol"], "title": "Modular SAIL: dream or reality?", "comment": null, "summary": "In order to truly benefit from RISC-V ISA modularity, the community has to\naddress the issue of compositionality, going beyond modules at the\nspecification level covering larger subsets of the RISC-V development flow\nincluding emulation, simulation and verification. In this paper we introduce\nmodular SAIL, an experiment to inject compositionality into the SAIL-RISCV\ngolden model. We show that it is, in principle, not difficult to adapt the\nSAIL-RISCV flow (and ideally the SAIL compiler itself) to support modules at\nthe emulator level. We back our findings by a comparative study of the\nresulting pluggable emulator's performance using both static and dynamic\nbinding, which both exhibit same functional behavior as the original monolithic\nemulator (aka RISC-V ISS)."}
{"id": "2507.12640", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.12640", "abs": "https://arxiv.org/abs/2507.12640", "authors": ["Tom Smeding", "Mikołaj Konarski", "Simon Peyton Jones", "Andrew Fitzgibbon"], "title": "Dual-Numbers Reverse AD for Functional Array Languages", "comment": null, "summary": "The standard dual-numbers construction works well for forward-mode automatic\ndifferentiation (AD) and is attractive due to its simplicity; recently, it also\nhas been adapted to reverse-mode AD, but practical performance, especially on\narray programs, leaves a lot to be desired. In this paper we introduce\nfirst-class support for multidimensional arrays in dual-numbers reverse-mode AD\nwith little to no performance overhead. The algorithm consists of three\nloosely-coupled components: a semantics-preserving vectorisation code\ntransformation (the bulk-operation transform or BOT), a fairly straightforward\nlifting of the basic dual-numbers reverse AD algorithm to a mostly first-order\narray language, and symbolic interpretation to achieve an end-to-end\ncompilation pipeline. Unfortunately, we lose some of the nice generalisable\naspects of dual-numbers AD in the process, most importantly support for\nhigher-order code.\n  We do support some higher-order array combinators, but only a\ncarefully-chosen set: 'build' (elementwise array construction), 'gather' and\n'scatter'. In return, the BOT can eliminate the essential (for AD)\nhigher-orderness of the input program, meaning that AD gets essentially\npresented with a first-order program. This allows the naive trick of lifting\ndual numbers to \"dual arrays\" to work without much modification."}
{"id": "2507.12904", "categories": ["cs.AR", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.12904", "abs": "https://arxiv.org/abs/2507.12904", "authors": ["Rohit Prasad"], "title": "An ultra-low-power CGRA for accelerating Transformers at the edge", "comment": null, "summary": "Transformers have revolutionized deep learning with applications in natural\nlanguage processing, computer vision, and beyond. However, their computational\ndemands make it challenging to deploy them on low-power edge devices. This\npaper introduces an ultra-low-power, Coarse-Grained Reconfigurable Array (CGRA)\narchitecture specifically designed to accelerate General Matrix Multiplication\n(GEMM) operations in transformer models tailored for the energy and resource\nconstraints of edge applications. The proposed architecture integrates a 4 x 4\narray of Processing Elements (PEs) for efficient parallel computation and\ndedicated 4 x 2 Memory Operation Blocks (MOBs) for optimized LOAD/STORE\noperations, reducing memory bandwidth demands and enhancing data reuse. A\nswitchless mesh torus interconnect network further minimizes power and latency\nby enabling direct communication between PEs and MOBs, eliminating the need for\ncentralized switching. Through its heterogeneous array design and efficient\ndataflow, this CGRA architecture addresses the unique computational needs of\ntransformers, offering a scalable pathway to deploy sophisticated machine\nlearning models on edge devices."}
{"id": "2507.13091", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.13091", "abs": "https://arxiv.org/abs/2507.13091", "authors": ["Aurèle Barrière", "Victor Deng", "Clément Pit-Claudel"], "title": "Formal Verification for JavaScript Regular Expressions: a Proven Semantics and its Applications", "comment": "25 pages, 3 pages of references, 6 pages of appendix", "summary": "We present the first mechanized, succinct, practical, complete, and\nproven-faithful semantics for a modern regular expression language with\nbacktracking semantics. We ensure its faithfulness by proving it equivalent to\na preexisting line-by-line embedding of the official ECMAScript specification\nof JavaScript regular expressions. We demonstrate its practicality by\npresenting two real-world applications. First, a new notion of contextual\nequivalence for modern regular expressions, which we use to prove or disprove\nrewrites drawn from previous work. Second, the first formal proof of the PikeVM\nalgorithm used in many real-world engines. In contrast with the specification\nand other formalization work, our semantics captures not only the top-priority\nmatch, but a full backtracking tree recording all possible matches and their\nrespective priority. All our definitions and results have been mechanized in\nthe Rocq proof assistant."}
{"id": "2507.13281", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2507.13281", "abs": "https://arxiv.org/abs/2507.13281", "authors": ["Haniye Mehraban", "Saad Azmeen-ur-Rahman", "John Hu"], "title": "WIP: Turning Fake Chips into Learning Opportunities", "comment": "This is the accepted version of a paper accepted for presentation at\n  the 2025 IEEE Frontiers in Education Conference (FIE). The final version will\n  be available via IEEE Xplore at:https://ieeexplore.ieee.org/Xplore/home.jsp", "summary": "This work-in-progress paper presents a case study in which counterfeit TL074\noperational amplifiers, discovered in a junior level electronics course, became\nthe basis for a hands on learning experience. Counterfeit integrated circuits\n(IC) are increasingly common, posing a significant threat to the integrity of\nundergraduate electronics laboratories. Instead of simply replacing the\ncounterfeit components, we turned the issue into a teaching moment. Students\nengaged in hands-on diagnostics measuring current, analyzing waveforms, and\ntroubleshooting. By working with fake chip components, they gained deeper\ninsight into analog circuits, supply chain security, and practical engineering."}
{"id": "2507.13290", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.13290", "abs": "https://arxiv.org/abs/2507.13290", "authors": ["Aaron Councilman", "David Fu", "Aryan Gupta", "Chengxiao Wang", "David Grove", "Yu-Xiong Wang", "Vikram Adve"], "title": "Towards Formal Verification of LLM-Generated Code from Natural Language Prompts", "comment": "31 pages, 9 figures", "summary": "In the past few years LLMs have emerged as a tool that can aid programmers by\ntaking natural language descriptions and generating code based on it. However,\nLLMs often generate incorrect code that users need to fix and the literature\nsuggests users often struggle to detect these errors. In this work we seek to\noffer formal guarantees of correctness to LLM generated code; such guarantees\ncould improve the experience of using AI Code Assistants and potentially enable\nnatural language programming for users with little or no programming knowledge.\nTo address this challenge we propose to incorporate a formal query language\nthat can represent a user's intent in a formally defined but natural\nlanguage-like manner that a user can confirm matches their intent. Then, using\nsuch a query we propose to verify LLM generated code to ensure it matches the\nuser's intent. We implement these ideas in our system, Astrogator, for the\nAnsible programming language which includes such a formal query language, a\ncalculus for representing the behavior of Ansible programs, and a symbolic\ninterpreter which is used for the verification. On a benchmark suite of 21\ncode-generation tasks, our verifier is able to verify correct code in 83% of\ncases and identify incorrect code in 92%."}
