{"id": "2508.02857", "categories": ["cs.PL", "quant-ph"], "pdf": "https://arxiv.org/pdf/2508.02857", "abs": "https://arxiv.org/abs/2508.02857", "authors": ["Mikhail Mints", "Finn Voichick", "Leonidas Lampropoulos", "Robert Rand"], "title": "Compositional Quantum Control Flow with Efficient Compilation in Qunity", "comment": "88 pages, 30 figures", "summary": "Most existing quantum programming languages are based on the quantum circuit\nmodel of computation, as higher-level abstractions are particularly challenging\nto implement - especially ones relating to quantum control flow. The Qunity\nlanguage, proposed by Voichick et al., offered such an abstraction in the form\nof a quantum control construct, with great care taken to ensure that the\nresulting language is still realizable. However, Qunity lacked a working\nimplementation, and the originally proposed compilation procedure was very\ninefficient, with even simple quantum algorithms compiling to unreasonably\nlarge circuits.\n  In this work, we focus on the efficient compilation of high-level quantum\ncontrol flow constructs, using Qunity as our starting point. We introduce a\nwider range of abstractions on top of Qunity's core language that offer\ncompelling trade-offs compared to its existing control construct. We create a\ncomplete implementation of a Qunity compiler, which converts high-level Qunity\ncode into the quantum assembly language OpenQASM 3. We develop optimization\ntechniques for multiple stages of the Qunity compilation procedure, including\nboth low-level circuit optimizations as well as methods that consider the\nhigh-level structure of a Qunity program, greatly reducing the number of qubits\nand gates used by the compiler."}
{"id": "2508.03558", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.03558", "abs": "https://arxiv.org/abs/2508.03558", "authors": ["M Zafir Sadik Khan", "Nowfel Mashnoor", "Mohammad Akyash", "Kimia Azar", "Hadi Kamali"], "title": "SAGE-HLS: Syntax-Aware AST-Guided LLM for High-Level Synthesis Code Generation", "comment": "Accepted to the IEEE International Conference on Computer Design\n  (ICCD 2025)", "summary": "In today's rapidly evolving field of electronic design automation (EDA), the\ncomplexity of hardware designs is increasing, necessitating more sophisticated\nautomation solutions. High-level synthesis (HLS), as a pivotal solution,\nautomates hardware designs from high-level abstractions (e.g., C/C++). However,\nit faces significant challenges, particularly in design space exploration and\noptimization. While large language models (LLMs) have shown notable\ncapabilities in code generation, their application to HLS has been limited due\nto the scarcity of (publicly) available HLS code datasets. Hence, research in\nthis domain has primarily focused on techniques such as prompt engineering and\nretrieval-augmented generation (RAG). To overcome this limitation, this paper\nintroduces SAGE-HLS, the first-of-its-kind fine-tuned LLM specifically for HLS\ncode generation. Our method includes three key advancements: (i) We implement\nVerilog-to-C/C++ porting, converting verified and synthesizable Verilog codes\ninto corresponding C, creating a dataset of 16.7K HLS codes; (ii) We implement\na fine-tuning strategy, which is based on instruction prompting to code\ngeneration guided by abstract syntax tree (AST); (iii) We develop a\nsemi-automated evaluation framework using VerilogEval to assess the\nfunctionality of the generated HLS code. Our experiments show that SAGE-HLS,\nfined-tuned on the QwenCoder (2.5) 7B model, achieves a near 100% success rate\nin code synthesizability and a 75% success rate in functional correctness."}
{"id": "2508.03640", "categories": ["cs.PL", "D.3.2;D.3.4;K.3.1"], "pdf": "https://arxiv.org/pdf/2508.03640", "abs": "https://arxiv.org/abs/2508.03640", "authors": ["Pedro Vasconcelos"], "title": "Teaching Introductory Functional Programming Using Haskelite", "comment": "In Proceedings TFPiE 2025, arXiv:2508.02305", "summary": "Learning functional programming requires learning a substitution-based\ncomputational model. While substitution should be a familiar concept from\nhigh-school algebra, students often have difficulty applying it to new\nsettings, such as recursive definitions, algebraic data types and higher-order\nfunctions. Step-by-step interpreters have been shown to help beginners by\nclarifying misconceptions and improving understanding.\n  This paper reports on the experience of using a step-by-step tracing\ninterpreter for a subset of Haskell while teaching an introductory functional\nprogramming course at the University of Porto. We describe the use of the\ninterpreter, present some feedback obtained from students, reflect on the\nlessons learned and point directions for further work."}
{"id": "2508.02705", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.02705", "abs": "https://arxiv.org/abs/2508.02705", "authors": ["Wei Li", "Limei Hu", "Feng Chen", "Ye Yao"], "title": "Low-Communication Resilient Distributed Estimation Algorithm Based on Memory Mechanism", "comment": null, "summary": "In multi-task adversarial networks, the accurate estimation of unknown\nparameters in a distributed algorithm is hindered by attacked nodes or links.\nTo tackle this challenge, this brief proposes a low-communication resilient\ndistributed estimation algorithm. First, a node selection strategy based on\nreputation is introduced that allows nodes to communicate with more reliable\nsubset of neighbors. Subsequently, to discern trustworthy intermediate\nestimates, the Weighted Support Vector Data Description (W-SVDD) model is\nemployed to train the memory data. This trained model contributes to reinforce\nthe resilience of the distributed estimation process against the impact of\nattacked nodes or links. Additionally, an event-triggered mechanism is\nintroduced to minimize ineffective updates to the W-SVDD model, and a suitable\nthreshold is derived based on assumptions. The convergence of the algorithm is\nanalyzed. Finally, simulation results demonstrate that the proposed algorithm\nachieves superior performance with less communication cost compared to other\nalgorithms."}
{"id": "2508.02977", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.02977", "abs": "https://arxiv.org/abs/2508.02977", "authors": ["Dongho Yoon", "Gungyu Lee", "Jaewon Chang", "Yunjae Lee", "Dongjae Lee", "Minsoo Rhu"], "title": "Mamba-X: An End-to-End Vision Mamba Accelerator for Edge Computing Devices", "comment": "Accepted for publication at the 44th International Conference on\n  Computer-Aided Design (ICCAD), 2025", "summary": "Transformers have proven effective in language modeling but are limited by\nhigh computational and memory demands that grow quadratically with input\nsequence length. State space models (SSMs) offer a promising alternative by\nreducing attention complexity from $O(L^2)$ to $O(L)$ while also lowering\noverall memory consumption. Vision Mamba adapts the SSM approach for computer\nvision tasks, achieving lower latency and memory consumption than traditional\ntransformer models. However, deploying Vision Mamba on edge devices is\nchallenging due to its sequential scan operations, which hinder GPU efficiency.\nWe propose Mamba-X, an end-to-end Vision Mamba accelerator that includes a\nsystolic scan array to maximize parallelism and minimize memory traffic, along\nwith a hybrid, hardware-friendly quantization technique to reduce memory usage\nand improve hardware efficiency without sacrificing accuracy."}
{"id": "2508.02708", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.02708", "abs": "https://arxiv.org/abs/2508.02708", "authors": ["Mario Scrocca", "Marco Grassi", "Alessio Carenini", "Jean-Paul Calbimonte", "Darko Anicic", "Irene Celino"], "title": "A DataOps Toolbox Enabling Continuous Semantic Integration of Devices for Edge-Cloud AI Applications", "comment": "This preprint has not undergone peer review or any post-submission\n  improvements or corrections. The Version of Record of this contribution will\n  be published in The Semantic Web - ISWC 2025", "summary": "The implementation of AI-based applications in complex environments often\nrequires the collaboration of several devices spanning from edge to cloud.\nIdentifying the required devices and configuring them to collaborate is a\nchallenge relevant to different scenarios, like industrial shopfloors, road\ninfrastructures, and healthcare therapies. We discuss the design and\nimplementation of a DataOps toolbox leveraging Semantic Web technologies and a\nlow-code mechanism to address heterogeneous data interoperability requirements\nin the development of such applications. The toolbox supports a continuous\nsemantic integration approach to tackle various types of devices, data formats,\nand semantics, as well as different communication interfaces. The paper\npresents the application of the toolbox to three use cases from different\ndomains, the DataOps pipelines implemented, and how they guarantee\ninteroperability of static nodes' information and runtime data exchanges.\nFinally, we discuss the results from the piloting activities in the use cases\nand the lessons learned."}
{"id": "2508.02992", "categories": ["cs.AR", "cs.ET"], "pdf": "https://arxiv.org/pdf/2508.02992", "abs": "https://arxiv.org/abs/2508.02992", "authors": ["Peijing Li", "Muhammad Shahir Abdurraman", "Rachel Cleaveland", "Sergey Legtchenko", "Philip Levis", "Ioan Stefanovici", "Thierry Tambe", "David Tennenhouse", "Caroline Trippel"], "title": "Towards Memory Specialization: A Case for Long-Term and Short-Term RAM", "comment": "9 pages, 3 figures", "summary": "Both SRAM and DRAM have stopped scaling: there is no technical roadmap to\nreduce their cost (per byte/GB). As a result, memory now dominates system cost.\nThis paper argues for a paradigm shift from today's simple memory hierarchy\ntoward specialized memory architectures that exploit application-specific\naccess patterns. Rather than relying solely on traditional off-chip DRAM and\non-chip SRAM, we envisage memory systems equipped with additional types of\nmemory whose performance trade-offs benefit workloads through non-hierarchical\noptimization. We propose two new memory classes deserving explicit OS support:\nlong-term RAM (LtRAM) optimized for read-intensive data with long lifetimes,\nand short-term RAM (StRAM) designed for transient, frequently-accessed data\nwith short lifetimes. We explore underlying device technologies that could\nimplement these classes, including their evolution and their potential\nintegration into current system designs given emerging workload requirements.\nWe identify critical research challenges to realize what we believe is a\nnecessary evolution toward more efficient and scalable computing systems\ncapable of meeting future demands."}
{"id": "2508.02866", "categories": ["cs.DC", "cs.DB", "68T42, 68T30, 68P20, 68Q85, 68M14,", "D.2.12; H.2.4; I.2.11; C.2.4; H.3.4"], "pdf": "https://arxiv.org/pdf/2508.02866", "abs": "https://arxiv.org/abs/2508.02866", "authors": ["Renan Souza", "Amal Gueroudji", "Stephen DeWitt", "Daniel Rosendo", "Tirthankar Ghosal", "Robert Ross", "Prasanna Balaprakash", "Rafael Ferreira da Silva"], "title": "PROV-AGENT: Unified Provenance for Tracking AI Agent Interactions in Agentic Workflows", "comment": "Paper under peer-reviewed evaluation", "summary": "Foundation models, such as Large Language Models (LLMs), are increasingly\nused as core components of AI agents in complex, large-scale workflows across\nfederated and heterogeneous environments. In agentic workflows, autonomous\nagents plan tasks, interact with humans and peers, and shape scientific\noutcomes. This makes transparency, traceability, reproducibility, and\nreliability essential. However, AI-based agents can hallucinate or reason\nincorrectly, and their decisions may propagate errors through the workflow,\nespecially when one agent's output feeds into another's input. Therefore,\nfine-grained provenance is essential to link agent decisions, their end-to-end\ncontext, and downstream impacts. While provenance techniques have long\nsupported reproducibility and workflow data understanding, they fail to capture\nand relate agent-centric metadata (prompts, responses, and decisions) with the\nrest of the workflow. In this paper, we introduce PROV-AGENT, a provenance\nmodel that extends W3C PROV and leverages the Model Context Protocol (MCP) to\nintegrate agent interactions into end-to-end workflow provenance. Our\ncontributions include: (1) a provenance model tailored for agentic workflows,\n(2) a near real-time, open-source system for capturing agentic provenance, and\n(3) a cross-facility evaluation spanning edge, cloud, and HPC environments,\ndemonstrating support for critical provenance queries and agent reliability\nanalysis."}
{"id": "2508.03418", "categories": ["cs.DC", "cs.LO", "68W15, 03B42, 03B70, 68Q60, 68Q85, 68M15"], "pdf": "https://arxiv.org/pdf/2508.03418", "abs": "https://arxiv.org/abs/2508.03418", "authors": ["Ron van der Meyden"], "title": "Optimal Simultaneous Byzantine Agreement, Common Knowledge and Limited Information Exchange", "comment": null, "summary": "In order to develop solutions that perform actions as early as possible,\nanalysis of distributed algorithms using epistemic logic has generally\nconcentrated on ``full information protocols'', which may be inefficient with\nrespect to space and computation time. The paper reconsiders the epistemic\nanalysis of the problem of Simultaneous Byzantine Agreement with respect to\nweaker, but more practical, exchanges of information. The paper first clarifies\nsome issues concerning both the specification of this problem and the knowledge\nbased program characterizing its solution, concerning the distinction between\nthe notions of ``nonfaulty'' and ``not yet failed'', on which there are\nvariances in the literature. It is then shown that, when implemented relative\nto a given failure model and an information exchange protocol satisfying\ncertain conditions, this knowledge based program yields a protocol that is\noptimal relative to solutions using the same information exchange. Conditions\nare also identified under which this implementation is also an optimum, but an\nexample is provided that shows this does not hold in general."}
{"id": "2508.03513", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.03513", "abs": "https://arxiv.org/abs/2508.03513", "authors": ["Zhu Zhu", "Yu Sun", "Dhatri Parakal", "Bo Fang", "Steven Farrell", "Gregory H. Bauer", "Brett Bode", "Ian T. Foster", "Michael E. Papka", "William Gropp", "Zhao Zhang", "Lishan Yang"], "title": "Understanding the Landscape of Ampere GPU Memory Errors", "comment": null, "summary": "Graphics Processing Units (GPUs) have become a de facto solution for\naccelerating high-performance computing (HPC) applications. Understanding their\nmemory error behavior is an essential step toward achieving efficient and\nreliable HPC systems. In this work, we present a large-scale\ncross-supercomputer study to characterize GPU memory reliability, covering\nthree supercomputers - Delta, Polaris, and Perlmutter - all equipped with\nNVIDIA A100 GPUs. We examine error logs spanning 67.77 million GPU device-hours\nacross 10,693 GPUs. We compare error rates and mean-time-between-errors (MTBE)\nand highlight both shared and distinct error characteristics among these three\nsystems. Based on these observations and analyses, we discuss the implications\nand lessons learned, focusing on the reliable operation of supercomputers, the\nchoice of checkpointing interval, and the comparison of reliability\ncharacteristics with those of previous-generation GPUs. Our characterization\nstudy provides valuable insights into fault-tolerant HPC system design and\noperation, enabling more efficient execution of HPC applications."}
{"id": "2508.03567", "categories": ["cs.DC", "cs.CE"], "pdf": "https://arxiv.org/pdf/2508.03567", "abs": "https://arxiv.org/abs/2508.03567", "authors": ["Oscar Ferraz", "Vitor Silva", "Gabriel Falcao"], "title": "In-Memory Non-Binary LDPC Decoding", "comment": "23 pages, 10 figures, and 4 tables", "summary": "Low-density parity-check (LDPC) codes are an important feature of several\ncommunication and storage applications, offering a flexible and effective\nmethod for error correction. These codes are computationally complex and\nrequire the exploitation of parallel processing to meet real-time constraints.\nAs advancements in arithmetic and logic unit technology allowed for higher\nperformance of computing systems, memory technology has not kept the same pace\nof development, creating a data movement bottleneck and affecting parallel\nprocessing systems more dramatically. To alleviate the severity of this\nbottleneck, several solutions have been proposed, namely the processing\nin-memory (PiM) paradigm that involves the design of compute units to where (or\nnear) the data is stored, utilizing thousands of low-complexity processing\nunits to perform out bit-wise and simple arithmetic operations. This paper\npresents a novel efficient solution for near-memory non-binary LDPC decoders in\nthe UPMEM system, for the best of our knowledge the first real hardware\nPiM-based non-binary LDPC decoder that is benchmarked against low-power GPU\nparallel solutions highly optimized for throughput performance. PiM-based\nnon-binary LDPC decoders can achieve 76 Mbit/s of decoding throughput, which is\neven competitive when compared against implementations running in edge GPUs."}
{"id": "2508.03611", "categories": ["cs.DC", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.03611", "abs": "https://arxiv.org/abs/2508.03611", "authors": ["Wei Da", "Evangelia Kalyvianaki"], "title": "Block: Balancing Load in LLM Serving with Context, Knowledge and Predictive Scheduling", "comment": "12 pages, 8 figures excluding appendix", "summary": "This paper presents Block, a distributed scheduling framework designed to\noptimize load balancing and auto-provisioning across instances in large\nlanguage model serving frameworks by leveraging contextual information from\nincoming requests. Unlike popular model serving systems that rely on monolithic\nand heuristic task schedulers, Block operates as a fully distributed,\nstateless, and predictive scheduling system to achieve low overhead,\nreliability, and scalability. It leverages the deterministic and predictable\ncharacteristics of LLM inferences, such as host configurations, response\nlengths, and hardware performance, to make scheduling decisions based on\naccurately predicted metrics. Evaluation on a 12 GPUs cluster shows that Block\nsignificantly outperforms heuristic schedulers, boosting serving capacity by up\nto 16.7\\% and reducing P99 tail latency by up to 49.5\\%. These performance\ngains remain consistent across diverse models, workloads and configurations.\nCode and data are open-sourced."}
