{"id": "2508.06978", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.06978", "abs": "https://arxiv.org/abs/2508.06978", "authors": ["Kwanhee Kyung", "Sungmin Yun", "Jung Ho Ahn"], "title": "SSD Offloading for LLM Mixture-of-Experts Weights Considered Harmful in Energy Efficiency", "comment": "4 pages, 6 figures, accepted at IEEE Computer Architecture Letters", "summary": "Large Language Models (LLMs) applying Mixture-of-Experts (MoE) scale to\ntrillions of parameters but require vast memory, motivating a line of research\nto offload expert weights from fast-but-small DRAM (HBM) to denser Flash SSDs.\nWhile SSDs provide cost-effective capacity, their read energy per bit is\nsubstantially higher than that of DRAM. This paper quantitatively analyzes the\nenergy implications of offloading MoE expert weights to SSDs during the\ncritical decode stage of LLM inference. Our analysis, comparing SSD, CPU memory\n(DDR), and HBM storage scenarios for models like DeepSeek-R1, reveals that\noffloading MoE weights to current SSDs drastically increases\nper-token-generation energy consumption (e.g., by up to ~12x compared to the\nHBM baseline), dominating the total inference energy budget. Although\ntechniques like prefetching effectively hide access latency, they cannot\nmitigate this fundamental energy penalty. We further explore future\ntechnological scaling, finding that the inherent sparsity of MoE models could\npotentially make SSDs energy-viable if Flash read energy improves\nsignificantly, roughly by an order of magnitude."}
{"id": "2508.07110", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.07110", "abs": "https://arxiv.org/abs/2508.07110", "authors": ["Lorenzo Ruotolo", "Lara Orlandic", "Pengbo Yu", "Moritz Brunion", "Daniele Jahier Pagliari", "Dwaipayan Biswas", "Giovanni Ansaloni", "David Atienza", "Julien Ryckaert", "Francky Catthoor", "Yukai Chen"], "title": "Physical Design Exploration of a Wire-Friendly Domain-Specific Processor for Angstrom-Era Nodes", "comment": null, "summary": "This paper presents the physical design exploration of a domain-specific\nprocessor (DSIP) architecture targeted at machine learning (ML), addressing the\nchallenges of interconnect efficiency in advanced Angstrom-era technologies.\nThe design emphasizes reduced wire length and high core density by utilizing\nspecialized memory structures and SIMD (Single Instruction, Multiple Data)\nunits. Five configurations are synthesized and evaluated using the IMEC A10\nnanosheet node PDK. Key physical design metrics are compared across\nconfigurations and against VWR2A, a state-of-the-art (SoA) DSIP baseline.\nResults show that our architecture achieves over 2x lower normalized wire\nlength and more than 3x higher density than the SoA, with low variability in\nthe metrics across all configurations, making it a promising solution for\nnext-generation DSIP designs. These improvements are achieved with minimal\nmanual layout intervention, demonstrating the architecture's intrinsic physical\nefficiency and potential for low-cost wire-friendly implementation."}
{"id": "2508.07227", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.07227", "abs": "https://arxiv.org/abs/2508.07227", "authors": ["Siyuan He", "Zhantong Zhu", "Yandong He", "Tianyu Jia"], "title": "LP-Spec: Leveraging LPDDR PIM for Efficient LLM Mobile Speculative Inference with Architecture-Dataflow Co-Optimization", "comment": "Accepted by ICCAD'2025", "summary": "LLM inference on mobile devices faces extraneous challenges due to limited\nmemory bandwidth and computational resources. To address these issues,\nspeculative inference and processing-in-memory (PIM) techniques have been\nexplored at the algorithmic and hardware levels. However, speculative inference\nresults in more compute-intensive GEMM operations, creating new design\ntrade-offs for existing GEMV-accelerated PIM architectures. Furthermore, there\nexists a significant amount of redundant draft tokens in tree-based speculative\ninference, necessitating efficient token management schemes to minimize energy\nconsumption. In this work, we present LP-Spec, an architecture-dataflow\nco-design leveraging hybrid LPDDR5 performance-enhanced PIM architecture with\ndraft token pruning and dynamic workload scheduling to accelerate LLM\nspeculative inference. A near-data memory controller is proposed to enable data\nreallocation between DRAM and PIM banks. Furthermore, a data allocation unit\nbased on the hardware-aware draft token pruner is developed to minimize energy\nconsumption and fully exploit parallel execution opportunities. Compared to\nend-to-end LLM inference on other mobile solutions such as mobile NPUs or\nGEMV-accelerated PIMs, our LP-Spec achieves 13.21x, 7.56x, and 99.87x\nimprovements in performance, energy efficiency, and energy-delay-product (EDP).\nCompared with prior AttAcc PIM and RTX 3090 GPU, LP-Spec can obtain 12.83x and\n415.31x EDP reduction benefits."}
{"id": "2508.07252", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.07252", "abs": "https://arxiv.org/abs/2508.07252", "authors": ["Siyuan He", "Peiran Yan", "Yandong He", "Youwei Zhuo", "Tianyu Jia"], "title": "Tasa: Thermal-aware 3D-Stacked Architecture Design with Bandwidth Sharing for LLM Inference", "comment": "Accepted by ICCAD'2025", "summary": "The autoregressive decoding in LLMs is the major inference bottleneck due to\nthe memory-intensive operations and limited hardware bandwidth. 3D-stacked\narchitecture is a promising solution with significantly improved memory\nbandwidth, which vertically stacked multi DRAM dies on top of logic die.\nHowever, our experiments also show the 3D-stacked architecture faces severer\nthermal issues compared to 2D architecture, in terms of thermal temperature,\ngradient and scalability. To better exploit the potential of 3D-stacked\narchitecture, we present Tasa, a heterogeneous architecture with cross-stack\nthermal optimizations to balance the temperature distribution and maximize the\nperformance under the thermal constraints. High-performance core is designed\nfor compute-intensive operations, while high-efficiency core is used for\nmemory-intensive operators, e.g. attention layers. Furthermore, we propose a\nbandwidth sharing scheduling to improve the bandwidth utilization in such\nheterogeneous architecture. Extensive thermal experiments show that our Tasa\narchitecture demonstrates greater scalability compared with the homogeneous\n3D-stacked architecture, i.e. up to 5.55 $\\tccentigrade$, 9.37 $\\tccentigrade$,\nand 7.91 $\\tccentigrade$ peak temperature reduction for 48, 60, and 72 core\nconfigurations. Our experimental for Llama-65B and GPT-3 66B inferences also\ndemonstrate 2.85x and 2.21x speedup are obtained over the GPU baselines and\nstate-of-the-art heterogeneous PIM-based LLM accelerator"}
{"id": "2508.06526", "categories": ["cs.DC", "cs.AI", "cs.AR"], "pdf": "https://arxiv.org/pdf/2508.06526", "abs": "https://arxiv.org/abs/2508.06526", "authors": ["Dong Liu", "Yanxuan Yu", "Ben Lengerich", "Ying Nian Wu", "Xuhong Wang"], "title": "PiKV: KV Cache Management System for Mixture of Experts", "comment": "Accepted to ICML ES-MoFo III WorkShop Paper Link:\n  https://openreview.net/pdf?id=hHoK1kBPd9 Github Link:\n  https://github.com/NoakLiu/PiKV", "summary": "As large language models continue to scale up in both size and context\nlength, the memory and communication cost of key-value (KV) cache storage has\nbecome a major bottleneck in multi-GPU and multi-node inference. While\nMoE-based architectures sparsify computation across experts, the corresponding\nKV caches remain dense and globally synchronized, resulting in significant\noverhead.\n  We introduce \\textbf{PiKV}, a parallel and distributed KV cache serving\nframework tailored for MoE architecture. PiKV leverages \\textit{expert-sharded\nKV storage} to partition caches across GPUs, \\textit{PiKV routing} to reduce\ntoken-to-KV access, and a \\textit{PiKV Scheduling} to adaptively retain\nquery-relevant entries. To further reduce memory usage, PiKV integrates\n\\textit{PiKV Compression} modules the caching pipeline for acceleration.\n  PiKV is recently publicly available as an open-source software library:\n\\href{https://github.com/NoakLiu/PiKV}{https://github.com/NoakLiu/PiKV}.\nExperiments details is recorded at:\n\\href{https://github.com/NoakLiu/PiKV/blob/main/downstream_tasks/README.md}{https://github.com/NoakLiu/PiKV/Experimental\\_Results}.\nWe also have PiKV integrated with Nvidia kvpress for acceleration, details see\n\\href{https://github.com/NoakLiu/PiKVpress}{https://github.com/NoakLiu/PiKVpress}.\nPiKV is still a living project, aiming to become a comprehesive KV Cache\nmanagement system for MoE Architectures."}
{"id": "2508.07855", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.07855", "abs": "https://arxiv.org/abs/2508.07855", "authors": ["Parosh Aziz Abdulla", "Mohamed Faouzi Atig", "R. Govind", "Samuel Grahn", "Ramanathan S. Thinniyam"], "title": "Checking Consistency of Event-driven Traces", "comment": null, "summary": "Event-driven programming is a popular paradigm where the flow of execution is\ncontrolled by two features: (1) shared memory and (2) sending and receiving of\nmessages between multiple handler threads (just called handler). Each handler\nhas a mailbox (modelled as a queue) for receiving messages, with the constraint\nthat the handler processes its messages sequentially. Executions of messages by\ndifferent handlers may be interleaved. A central problem in this setting is\nchecking whether a candidate execution is consistent with the semantics of\nevent-driven programs. In this paper, we propose an axiomatic semantics for\neventdriven programs based on the standard notion of traces (also known as\nexecution graphs). We prove the equivalence of axiomatic and operational\nsemantics. This allows us to rephrase the consistency problem axiomatically,\nresulting in the event-driven consistency problem: checking whether a given\ntrace is consistent. We analyze the computational complexity of this problem\nand show that it is NP-complete, even when the number of handler threads is\nbounded. We then identify a tractable fragment: in the absence of nested\nposting, where handlers do not post new messages while processing a message,\nconsistency checking can be performed in polynomial time. Finally, we implement\nour approach in a prototype tool and report on experimental results on a wide\nrange of benchmarks."}
{"id": "2508.07457", "categories": ["cs.AR", "A.1; C.1.1; G.3; I.6.1; I.6.8"], "pdf": "https://arxiv.org/pdf/2508.07457", "abs": "https://arxiv.org/abs/2508.07457", "authors": ["Janith Petangoda", "Chatura Samarakoon", "James Meech", "Divya Thekke Kanapram", "Hamid Toshani", "Nathaniel Tye", "Vasileios Tsoutsouras", "Phillip Stanley-Marbell"], "title": "The Monte Carlo Method and New Device and Architectural Techniques for Accelerating It", "comment": "15 pages, 4 figures (17 subfigures)", "summary": "Computing systems interacting with real-world processes must safely and\nreliably process uncertain data. The Monte Carlo method is a popular approach\nfor computing with such uncertain values. This article introduces a framework\nfor describing the Monte Carlo method and highlights two advances in the domain\nof physics-based non-uniform random variate generators (PPRVGs) to overcome\ncommon limitations of traditional Monte Carlo sampling. This article also\nhighlights recent advances in architectural techniques that eliminate the need\nto use the Monte Carlo method by leveraging distributional microarchitectural\nstate to natively compute on probability distributions. Unlike Monte Carlo\nmethods, uncertainty-tracking processor architectures can be said to be\nconvergence-oblivious."}
{"id": "2508.06948", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.06948", "abs": "https://arxiv.org/abs/2508.06948", "authors": ["Jinyuan Chen", "Jiuchen Shi", "Quan Chen", "Minyi Guo"], "title": "Kairos: Low-latency Multi-Agent Serving with Shared LLMs and Excessive Loads in the Public Cloud", "comment": null, "summary": "Multi-agent applications utilize the advanced capabilities of large language\nmodels (LLMs) for intricate task completion through agent collaboration in a\nworkflow. Under this situation, requests from different agents usually access\nthe same shared LLM to perform different kinds of tasks, forcing the shared LLM\nto suffer excessive loads. However, existing works have low serving performance\nfor these multi-agent applications, mainly due to the ignorance of inter-agent\nlatency and resource differences for request scheduling. We therefore propose\nKairos, a multi-agent orchestration system that optimizes end-to-end latency\nfor multi-agent applications. Kairos consists of a workflow orchestrator, a\nworkflow-aware priority scheduler, and a memory-aware dispatcher. The\norchestrator collects agent-specific information for online workflow analysis.\nThe scheduler decides the serving priority of the requests based on their\nlatency characteristics to reduce the overall queuing. The dispatcher\ndispatches the requests to different LLM instances based on their memory\ndemands to avoid GPU overloading. Experimental results show that Kairos reduces\nend-to-end latency by 17.8% to 28.4% compared to state-of-the-art works."}
{"id": "2508.07541", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.07541", "abs": "https://arxiv.org/abs/2508.07541", "authors": ["Kittiphon Phalakarn", "Athasit Surarerks"], "title": "A Matrix Decomposition Method for Odd-Type Gaussian Normal Basis Multiplication", "comment": null, "summary": "Normal basis is used in many applications because of the efficiency of the\nimplementation. However, most space complexity reduction techniques for binary\nfield multiplier are applicable for only optimal normal basis or Gaussian\nnormal basis of even type. There are 187 binary fields GF(2^k) for k from 2 to\n1,000 that use odd-type Gaussian normal basis. This paper presents a method to\nreduce the space complexity of odd-type Gaussian normal basis multipliers over\nbinary field GF(2^k). The idea is adapted from the matrix decomposition method\nfor optimal normal basis. The result shows that our space complexity reduction\nmethod can reduce the number of XOR gates used in the implementation comparing\nto previous works with a small trade-off in critical path delay."}
{"id": "2508.06949", "categories": ["cs.DC", "cs.DM"], "pdf": "https://arxiv.org/pdf/2508.06949", "abs": "https://arxiv.org/abs/2508.06949", "authors": ["Arya Tanmay Gupta"], "title": "Convergence Sans Synchronization", "comment": "PhD thesis", "summary": "We currently see a steady rise in the usage and size of multiprocessor\nsystems, and so the community is evermore interested in developing fast\nparallel processing algorithms. However, most algorithms require a\nsynchronization mechanism, which is costly in terms of computational resources\nand time. If an algorithm can be executed in asynchrony, then it can use all\nthe available computation power, and the nodes can execute without being\nscheduled or locked. However, to show that an algorithm guarantees convergence\nin asynchrony, we need to generate the entire global state transition graph and\ncheck for the absence of cycles. This takes time exponential in the size of the\nglobal state space. In this dissertation, we present a theory that explains the\nnecessary and sufficient properties of a multiprocessor algorithm that\nguarantees convergence even without synchronization. We develop algorithms for\nvarious problems that do not require synchronization. Additionally, we show for\nseveral existing algorithms that they can be executed without any\nsynchronization mechanism. A significant theoretical benefit of our work is in\nproving that an algorithm can converge even in asynchrony. Our theory implies\nthat we can make such conclusions about an algorithm, by only showing that the\nlocal state transition graph of a computing node forms a partial order, rather\nthan generating the entire global state space and determining the absence of\ncycles in it. Thus, the complexity of rendering such proofs, formal or social,\nis phenomenally reduced. Experiments show a significant reduction in time taken\nto converge, when we compare the execution time of algorithms in the literature\nversus the algorithms that we design. We get similar results when we run an\nalgorithm, that guarantees convergence in asynchrony, under a scheduler versus\nin asynchrony."}
{"id": "2508.07725", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.07725", "abs": "https://arxiv.org/abs/2508.07725", "authors": ["Andreas Hager-Clukas", "Philipp van Kempen", "Stefan Wallentowitz"], "title": "ARISE: Automating RISC-V Instruction Set Extension", "comment": null, "summary": "RISC-V is an extendable Instruction Set Architecture, growing in popularity\nfor embedded systems. However, optimizing it to specific requirements, imposes\na great deal of manual effort. To bridge the gap between software and ISA, the\ntool ARISE is presented. It automates the generation of RISC-V instructions\nbased on assembly patterns, which are selected by an extendable set of metrics.\nThese metrics implement the optimization goals of code size and instruction\ncount reduction, both statically and dynamically. The instruction set\nextensions are generated using the ISA description language CoreDSL. Allowing\nseamless embedding in advanced tools such as the retargeting compiler Seal5 or\nthe instruction set simulator ETISS. ARISE improves the static code size by\n1.48% and the dynamic code size by 3.84%, as well as the number of instructions\nto be executed by 7.39% on average for Embench-Iot."}
{"id": "2508.07071", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.07071", "abs": "https://arxiv.org/abs/2508.07071", "authors": ["Oscar Amoros", "Albert Andaluz", "Johnny Nunez", "Antonio J. Pena"], "title": "The Fused Kernel Library: A C++ API to Develop Highly-Efficient GPU Libraries", "comment": "16 pages", "summary": "Existing GPU libraries often struggle to fully exploit the parallel resources\nand on-chip memory (SRAM) of GPUs when chaining multiple GPU functions as\nindividual kernels. While Kernel Fusion (KF) techniques like Horizontal Fusion\n(HF) and Vertical Fusion (VF) can mitigate this, current library\nimplementations often require library developers to manually create fused\nkernels. Hence, library users rely on limited sets of pre-compiled or\ntemplate-based fused kernels. This limits the use cases that can benefit from\nHF and VF and increases development costs. In order to solve these issues, we\npresent a novel methodology for building GPU libraries that enables automatic\non-demand HF and VF for arbitrary combinations of GPU library functions. Our\nmethodology defines reusable, fusionable components that users combine via\nhigh-level programming interfaces. Leveraging C++17 metaprogramming features\navailable in compilers like nvcc, our methodology generates a single and\noptimized fused kernel tailored to the user's specific sequence of operations\nat compile time, without needing a custom compiler or manual development and\npre-compilation of kernel combinations. This approach abstracts low-level GPU\ncomplexities while maximizing GPU resource utilization and keeping intermediate\ndata in SRAM. We provide an open-source implementation demonstrating\nsignificant speedups compared to traditional libraries in various benchmarks,\nvalidating the effectiveness of this methodology for improving GPU performance\nin the range of 2x to more than 1000x, while preserving high-level\nprogrammability."}
{"id": "2508.07796", "categories": ["cs.AR"], "pdf": "https://arxiv.org/pdf/2508.07796", "abs": "https://arxiv.org/abs/2508.07796", "authors": ["Dengke Han", "Duo Wang", "Mingyu Yan", "Xiaochun Ye", "Dongrui Fan"], "title": "TLV-HGNN: Thinking Like a Vertex for Memory-efficient HGNN Inference", "comment": "8 pages, 9 figures, accepted by ICCD 2025", "summary": "Heterogeneous graph neural networks (HGNNs) excel at processing heterogeneous\ngraph data and are widely applied in critical domains. In HGNN inference, the\nneighbor aggregation stage is the primary performance determinant, yet it\nsuffers from two major sources of memory inefficiency. First, the commonly\nadopted per-semantic execution paradigm stores intermediate aggregation results\nfor each semantic prior to semantic fusion, causing substantial memory\nexpansion. Second, the aggregation process incurs extensive redundant memory\naccesses, including repeated loading of target vertex features across semantics\nand repeated accesses to shared neighbors due to cross-semantic neighborhood\noverlap. These inefficiencies severely limit scalability and reduce HGNN\ninference performance.\n  In this work, we first propose a semantics-complete execution paradigm from a\nvertex perspective that eliminates per-semantic intermediate storage and\nredundant target vertex accesses. Building on this paradigm, we design\nTVL-HGNN, a reconfigurable hardware accelerator optimized for efficient\naggregation. In addition, we introduce a vertex grouping technique based on\ncross-semantic neighborhood overlap, with hardware implementation, to reduce\nredundant accesses to shared neighbors. Experimental results demonstrate that\nTVL-HGNN achieves average speedups of 7.85x and 1.41x over the NVIDIA A100 GPU\nand the state-of-the-art HGNN accelerator HiHGNN, respectively, while reducing\nenergy consumption by 98.79% and 32.61%."}
{"id": "2508.07124", "categories": ["cs.DC", "cs.DB"], "pdf": "https://arxiv.org/pdf/2508.07124", "abs": "https://arxiv.org/abs/2508.07124", "authors": ["Shashwat Jaiswal", "Suman Raj", "Subhajit Sidhanta", "Yogesh Simmhan"], "title": "AerialDB: A Federated Peer-to-Peer Spatio-temporal Edge Datastore for Drone Fleets", "comment": null, "summary": "Recent years have seen an unprecedented growth in research that leverages the\nnewest computing paradigm of Internet of Drones, comprising a fleet of\nconnected Unmanned Aerial Vehicles (UAVs) used for a wide range of tasks such\nas monitoring and analytics in highly mobile and changing environments\ncharacteristic of disaster regions. Given that the typical data (i.e., videos\nand images) collected by the fleet of UAVs deployed in such scenarios can be\nconsiderably larger than what the onboard computers can process, the UAVs need\nto offload their data in real-time to the edge and the cloud for further\nprocessing. To that end, we present the design of AerialDB - a lightweight\ndecentralized data storage and query system that can store and process time\nseries data on a multi-UAV system comprising: A) a fleet of hundreds of UAVs\nfitted with onboard computers, and B) ground-based edge servers connected\nthrough a cellular link. Leveraging lightweight techniques for content-based\nreplica placement and indexing of shards, AerialDB has been optimized for\nefficient processing of different possible combinations of typical spatial and\ntemporal queries performed by real-world disaster management applications.\nUsing containerized deployment spanning up to 400 drones and 80 edges, we\ndemonstrate that AerialDB is able to scale efficiently while providing near\nreal-time performance with different realistic workloads. Further, AerialDB\ncomprises a decentralized and locality-aware distributed execution engine which\nprovides graceful degradation of performance upon edge failures with relatively\nlow latency while processing large spatio-temporal data. AerialDB exhibits\ncomparable insertion performance and 100 times improvement in query performance\nagainst state-of-the-art baseline. Moreover, it exhibits a 10 times and 100\ntimes improvement with insertion and query workloads respectively over the\ncloud baseline."}
{"id": "2508.06526", "categories": ["cs.DC", "cs.AI", "cs.AR"], "pdf": "https://arxiv.org/pdf/2508.06526", "abs": "https://arxiv.org/abs/2508.06526", "authors": ["Dong Liu", "Yanxuan Yu", "Ben Lengerich", "Ying Nian Wu", "Xuhong Wang"], "title": "PiKV: KV Cache Management System for Mixture of Experts", "comment": "Accepted to ICML ES-MoFo III WorkShop Paper Link:\n  https://openreview.net/pdf?id=hHoK1kBPd9 Github Link:\n  https://github.com/NoakLiu/PiKV", "summary": "As large language models continue to scale up in both size and context\nlength, the memory and communication cost of key-value (KV) cache storage has\nbecome a major bottleneck in multi-GPU and multi-node inference. While\nMoE-based architectures sparsify computation across experts, the corresponding\nKV caches remain dense and globally synchronized, resulting in significant\noverhead.\n  We introduce \\textbf{PiKV}, a parallel and distributed KV cache serving\nframework tailored for MoE architecture. PiKV leverages \\textit{expert-sharded\nKV storage} to partition caches across GPUs, \\textit{PiKV routing} to reduce\ntoken-to-KV access, and a \\textit{PiKV Scheduling} to adaptively retain\nquery-relevant entries. To further reduce memory usage, PiKV integrates\n\\textit{PiKV Compression} modules the caching pipeline for acceleration.\n  PiKV is recently publicly available as an open-source software library:\n\\href{https://github.com/NoakLiu/PiKV}{https://github.com/NoakLiu/PiKV}.\nExperiments details is recorded at:\n\\href{https://github.com/NoakLiu/PiKV/blob/main/downstream_tasks/README.md}{https://github.com/NoakLiu/PiKV/Experimental\\_Results}.\nWe also have PiKV integrated with Nvidia kvpress for acceleration, details see\n\\href{https://github.com/NoakLiu/PiKVpress}{https://github.com/NoakLiu/PiKVpress}.\nPiKV is still a living project, aiming to become a comprehesive KV Cache\nmanagement system for MoE Architectures."}
{"id": "2508.07193", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.07193", "abs": "https://arxiv.org/abs/2508.07193", "authors": ["Haoyuan Zhang", "Yaqian Gao", "Xinxin Zhang", "Jialin Li", "Runfeng Jin", "Yidong Chen", "Feng Zhang", "Wu Yuan", "Wenpeng Ma", "Shan Liang", "Jian Zhang", "Zhonghua Lu"], "title": "FlashMP: Fast Discrete Transform-Based Solver for Preconditioning Maxwell's Equations on GPUs", "comment": null, "summary": "Efficiently solving large-scale linear systems is a critical challenge in\nelectromagnetic simulations, particularly when using the Crank-Nicolson\nFinite-Difference Time-Domain (CN-FDTD) method. Existing iterative solvers are\ncommonly employed to handle the resulting sparse systems but suffer from slow\nconvergence due to the ill-conditioned nature of the double-curl operator.\nApproximate preconditioners, like Successive Over-Relaxation (SOR) and\nIncomplete LU decomposition (ILU), provide insufficient convergence, while\ndirect solvers are impractical due to excessive memory requirements. To address\nthis, we propose FlashMP, a novel preconditioning system that designs a\nsubdomain exact solver based on discrete transforms. FlashMP provides an\nefficient GPU implementation that achieves multi-GPU scalability through domain\ndecomposition. Evaluations on AMD MI60 GPU clusters (up to 1000 GPUs) show that\nFlashMP reduces iteration counts by up to 16x and achieves speedups of 2.5x to\n4.9x compared to baseline implementations in state-of-the-art libraries such as\nHypre. Weak scalability tests show parallel efficiencies up to 84.1%."}
{"id": "2508.07317", "categories": ["cs.DC", "eess.SP"], "pdf": "https://arxiv.org/pdf/2508.07317", "abs": "https://arxiv.org/abs/2508.07317", "authors": ["Pedro Carrinho", "Hamid Moghadaspour", "Oscar Ferraz", "João Dinis Ferreira", "Yann Falevoz", "Vitor Silva", "Gabriel Falcao"], "title": "An Experimental Exploration of In-Memory Computing for Multi-Layer Perceptrons", "comment": "19 pages, 1 figures, and 2 tables", "summary": "In modern computer architectures, the performance of many memory-bound\nworkloads (e.g., machine learning, graph processing, databases) is limited by\nthe data movement bottleneck that emerges when transferring large amounts of\ndata between the main memory and the central processing unit (CPU).\nProcessing-in-memory is an emerging computing paradigm that aims to alleviate\nthis data movement bottleneck by performing computation close to or within the\nmemory units, where data resides. One example of a prevalent workload whose\nperformance is bound by the data movement bottleneck is the training and\ninference process of artificial neural networks. In this work, we analyze the\npotential of modern general-purpose PiM architectures to accelerate neural\nnetworks. To this end, we selected the UPMEM PiM system, the first commercially\navailable real-world general-purpose PiM architecture. We compared the\nimplementation of multilayer perceptrons (MLPs) in PiM with a sequential\nbaseline running on an Intel Xeon CPU. The UPMEM implementation achieves up to\n$259\\times$ better performance for inference of large batch sizes when compared\nagainst the CPU that exploits the size of the available PiM memory.\nAdditionally, two smaller MLPs were implemented using UPMEM's working SRAM\n(WRAM), a scratchpad memory, to evaluate their performance against a low-power\nNvidia Jetson graphics processing unit (GPU), providing further insights into\nthe efficiency of UPMEM's PiM for neural network inference. Results show that\nusing WRAM achieves kernel execution times for MLP inference of under $3$ ms,\nwhich is within the same order of magnitude as low-power GPUs."}
{"id": "2508.07472", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.07472", "abs": "https://arxiv.org/abs/2508.07472", "authors": ["Ramesh Adhikari", "Costas Busch", "Miroslav Popovic"], "title": "On the Efficiency of Dynamic Transaction Scheduling in Blockchain Sharding", "comment": "15 pages, 2 figures, accepted as a regular paper at 39th\n  International Symposium on Distributed Computing (DISC 2025)", "summary": "Sharding is a technique to speed up transaction processing in blockchains,\nwhere the $n$ processing nodes in the blockchain are divided into $s$ disjoint\ngroups (shards) that can process transactions in parallel. We study dynamic\nscheduling problems on a shard graph $G_s$ where transactions arrive online\nover time and are not known in advance. Each transaction may access at most $k$\nshards, and we denote by $d$ the worst distance between a transaction and its\naccessing (destination) shards (the parameter $d$ is unknown to the shards). To\nhandle different values of $d$, we assume a locality sensitive decomposition of\n$G_s$ into clusters of shards, where every cluster has a leader shard that\nschedules transactions for the cluster. We first examine the simpler case of\nthe stateless model, where leaders are not aware of the current state of the\ntransaction accounts, and we prove a $O(d \\log^2 s \\cdot \\min\\{k, \\sqrt{s}\\})$\ncompetitive ratio for latency. We then consider the stateful model, where\nleader shards gather the current state of accounts, and we prove a $O(\\log\ns\\cdot \\min\\{k, \\sqrt{s}\\}+\\log^2 s)$ competitive ratio for latency. Each\nleader calculates the schedule in polynomial time for each transaction that it\nprocesses. We show that for any $\\epsilon > 0$, approximating the optimal\nschedule within a $(\\min\\{k, \\sqrt{s}\\})^{1 -\\epsilon}$ factor is NP-hard.\nHence, our bound for the stateful model is within a poly-log factor from the\nbest possibly achievable. To the best of our knowledge, this is the first work\nto establish provably efficient dynamic scheduling algorithms for blockchain\nsharding systems."}
{"id": "2508.07605", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.07605", "abs": "https://arxiv.org/abs/2508.07605", "authors": ["Zhong Zheng", "Michael E. Papka", "Zhiling Lan"], "title": "Coordinated Power Management on Heterogeneous Systems", "comment": null, "summary": "Performance prediction is essential for energy-efficient computing in\nheterogeneous computing systems that integrate CPUs and GPUs. However,\ntraditional performance modeling methods often rely on exhaustive offline\nprofiling, which becomes impractical due to the large setting space and the\nhigh cost of profiling large-scale applications. In this paper, we present\nOPEN, a framework consists of offline and online phases. The offline phase\ninvolves building a performance predictor and constructing an initial dense\nmatrix. In the online phase, OPEN performs lightweight online profiling, and\nleverages the performance predictor with collaborative filtering to make\nperformance prediction. We evaluate OPEN on multiple heterogeneous systems,\nincluding those equipped with A100 and A30 GPUs. Results show that OPEN\nachieves prediction accuracy up to 98.29\\%. This demonstrates that OPEN\neffectively reduces profiling cost while maintaining high accuracy, making it\npractical for power-aware performance modeling in modern HPC environments.\nOverall, OPEN provides a lightweight solution for performance prediction under\npower constraints, enabling better runtime decisions in power-aware computing\nenvironments."}
{"id": "2508.07640", "categories": ["cs.DC", "cs.PF"], "pdf": "https://arxiv.org/pdf/2508.07640", "abs": "https://arxiv.org/abs/2508.07640", "authors": ["Chanh Nguyen", "Monowar Bhuyan", "Erik Elmroth"], "title": "Taming Cold Starts: Proactive Serverless Scheduling with Model Predictive Control", "comment": "8 pages, 8 figures, preprint accepted at MASCOTS 2025", "summary": "Serverless computing has transformed cloud application deployment by\nintroducing a fine-grained, event-driven execution model that abstracts away\ninfrastructure management. Its on-demand nature makes it especially appealing\nfor latency-sensitive and bursty workloads. However, the cold start problem,\ni.e., where the platform incurs significant delay when provisioning new\ncontainers, remains the Achilles' heel of such platforms.\n  This paper presents a predictive serverless scheduling framework based on\nModel Predictive Control to proactively mitigate cold starts, thereby improving\nend-to-end response time. By forecasting future invocations, the controller\njointly optimizes container prewarming and request dispatching, improving\nlatency while minimizing resource overhead.\n  We implement our approach on Apache OpenWhisk, deployed on a Kubernetes-based\ntestbed. Experimental results using real-world function traces and synthetic\nworkloads demonstrate that our method significantly outperforms\nstate-of-the-art baselines, achieving up to 85% lower tail latency and a 34%\nreduction in resource usage."}
{"id": "2508.07703", "categories": ["cs.DC", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.07703", "abs": "https://arxiv.org/abs/2508.07703", "authors": ["Adri Bhattacharya", "Pritam Goswami", "Evangelos Bampas", "Partha Sarathi Mandal"], "title": "Perpetual exploration in anonymous synchronous networks with a Byzantine black hole", "comment": "This paper has been accepted at DISC 2025", "summary": "In this paper, we investigate: ``How can a group of initially co-located\nmobile agents perpetually explore an unknown graph, when one stationary node\noccasionally behaves maliciously, under an adversary's control?'' We call this\nnode a ``Byzantine black hole (BBH)'' and at any given round it may choose to\ndestroy all visiting agents, or none. This subtle power can drastically\nundermine classical exploration strategies designed for an always active black\nhole. We study this perpetual exploration problem in the presence of at most\none BBH, without initial knowledge of the network size. Since the underlying\ngraph may be 1-connected, perpetual exploration of the entire graph may be\ninfeasible. We thus define two variants: \\pbmPerpExpl\\ and \\pbmPerpExplHome. In\nthe former, the agents are tasked to perform perpetual exploration of at least\none component, obtained after the exclusion of the BBH. In the latter, the\nagents are tasked to perform perpetual exploration of the component which\ncontains the \\emph{home} node, where agents are initially co-located.\nNaturally, \\pbmPerpExplHome\\ is a special case of \\pbmPerpExpl. Agents operate\nunder a synchronous scheduler and communicate in a face-to-face model. Our goal\nis to determine the minimum number of agents necessary and sufficient to solve\nthese problems. In acyclic networks, we obtain optimal algorithms that solve\n\\pbmPerpExpl\\ with $4$ agents, and \\pbmPerpExplHome\\ with $6$ agents in trees.\nThe lower bounds hold even in path graphs. In general graphs, we give a\nnon-trivial lower bound of $2\\Delta-1$ agents for \\pbmPerpExpl, and an upper\nbound of $3\\Delta+3$ agents for \\pbmPerpExplHome. To our knowledge, this is the\nfirst study of a black-hole variant in arbitrary networks without initial\ntopological knowledge."}
{"id": "2508.07744", "categories": ["cs.DC", "cs.NI", "eess.SP"], "pdf": "https://arxiv.org/pdf/2508.07744", "abs": "https://arxiv.org/abs/2508.07744", "authors": ["Ingo Friese", "Jochen Klaffer", "Mandy Galkow-Schneider", "Sergiy Melnyk", "Qiuheng Zhou", "Hans Dieter Schotten"], "title": "Over-the-Top Resource Broker System for Split Computing: An Approach to Distribute Cloud Computing Infrastructure", "comment": null, "summary": "6G network architectures will usher in a wave of innovative services and\ncapabilities, introducing concepts like split computing and dynamic processing\nnodes. This implicates a paradigm where accessing resources seamlessly aligns\nwith diverse processing node characteristics, ensuring a uniform interface. In\nthis landscape, the identity of the operator becomes inconsequential, paving\nthe way for a collaborative ecosystem where multiple providers contribute to a\nshared pool of resources. At the core of this vision is the guarantee of\nspecific performance parameters, precisely tailored to the location and service\nrequirements. A consistent layer, as the abstraction of the complexities of\ndifferent infrastructure providers, is needed to simplify service deployment.\nOne promising approach is the introduction of an over-the-top broker for\nresource allocation, which streamlines the integration of these services into\nthe network and cloud infrastructure of the future. This paper explores the\nrole of the broker in two split computing scenarios. By abstracting the\ncomplexities of various infrastructures, the broker proves to be a versatile\nsolution applicable not only to cloud environments but also to networks and\nbeyond. Additionally, a detailed discussion of a proof-of-concept\nimplementation provides insights into the broker's actual architectural\nframework."}
{"id": "2508.07756", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.07756", "abs": "https://arxiv.org/abs/2508.07756", "authors": ["Hanze Zhang", "Rong Chen", "Haibo Chen"], "title": "Towards Lock Modularization for Heterogeneous Environments", "comment": null, "summary": "Modern hardware environments are becoming increasingly heterogeneous, leading\nto the emergence of applications specifically designed to exploit this\nheterogeneity. Efficiently adopting locks in these applications poses distinct\nchallenges. The uneven distribution of resources in such environments can\ncreate bottlenecks for lock operations, severely hindering application\nperformance. Existing solutions are often tailored to specific types of\nhardware, which underutilizes resources on other components within\nheterogeneous environments.\n  This paper introduces a new design principle: decomposing locks across\nhardware components to fully utilize unevenly distributed resources in\nheterogeneous environments. Following this principle, we propose lock\nmodularization, a systematic approach that decomposes a lock into independent\nmodules and assigns them to appropriate hardware components. This approach\naligns the resource requirements of lock modules with the attributes of\nspecific hardware components, maximizing strengths while minimizing weaknesses."}
{"id": "2508.07934", "categories": ["cs.DC", "cs.NI"], "pdf": "https://arxiv.org/pdf/2508.07934", "abs": "https://arxiv.org/abs/2508.07934", "authors": ["Lorenzo La Corte", "Syed Aftab Rashid", "Andrei-Marian Dan"], "title": "Performance Evaluation of Brokerless Messaging Libraries", "comment": "11 pages, 9 figures", "summary": "Messaging systems are essential for efficiently transferring large volumes of\ndata, ensuring rapid response times and high-throughput communication. The\nstate-of-the-art on messaging systems mainly focuses on the performance\nevaluation of brokered messaging systems, which use an intermediate broker to\nguarantee reliability and quality of service. However, over the past decade,\nbrokerless messaging systems have emerged, eliminating the single point of\nfailure and trading off reliability guarantees for higher performance. Still,\nthe state-of-the-art on evaluating the performance of brokerless systems is\nscarce. In this work, we solely focus on brokerless messaging systems. First,\nwe perform a qualitative analysis of several possible candidates, to find the\nmost promising ones. We then design and implement an extensive open-source\nbenchmarking suite to systematically and fairly evaluate the performance of the\nchosen libraries, namely, ZeroMQ, NanoMsg, and NanoMsg-Next-Generation (NNG).\nWe evaluate these libraries considering different metrics and workload\nconditions, and provide useful insights into their limitations. Our analysis\nenables practitioners to select the most suitable library for their\nrequirements."}
{"id": "2508.08022", "categories": ["cs.DC", "cs.LG"], "pdf": "https://arxiv.org/pdf/2508.08022", "abs": "https://arxiv.org/abs/2508.08022", "authors": ["Roopkatha Banerjee", "Sampath Koti", "Gyanendra Singh", "Anirban Chakraborty", "Gurunath Gurrala", "Bhushan Jagyasi", "Yogesh Simmhan"], "title": "Optimizing Federated Learning for Scalable Power-demand Forecasting in Microgrids", "comment": null, "summary": "Real-time monitoring of power consumption in cities and micro-grids through\nthe Internet of Things (IoT) can help forecast future demand and optimize grid\noperations. But moving all consumer-level usage data to the cloud for\npredictions and analysis at fine time scales can expose activity patterns.\nFederated Learning~(FL) is a privacy-sensitive collaborative DNN training\napproach that retains data on edge devices, trains the models on private data\nlocally, and aggregates the local models in the cloud. But key challenges\nexist: (i) clients can have non-independently identically distributed~(non-IID)\ndata, and (ii) the learning should be computationally cheap while scaling to\n1000s of (unseen) clients. In this paper, we develop and evaluate several\noptimizations to FL training across edge and cloud for time-series demand\nforecasting in micro-grids and city-scale utilities using DNNs to achieve a\nhigh prediction accuracy while minimizing the training cost. We showcase the\nbenefit of using exponentially weighted loss while training and show that it\nfurther improves the prediction of the final model. Finally, we evaluate these\nstrategies by validating over 1000s of clients for three states in the US from\nthe OpenEIA corpus, and performing FL both in a pseudo-distributed setting and\na Pi edge cluster. The results highlight the benefits of the proposed methods\nover baselines like ARIMA and DNNs trained for individual consumers, which are\nnot scalable."}
{"id": "2508.08064", "categories": ["cs.DC"], "pdf": "https://arxiv.org/pdf/2508.08064", "abs": "https://arxiv.org/abs/2508.08064", "authors": ["Marco Bernardo", "Federico Calandra", "Andrea Esposito", "Francesco Fabris"], "title": "On the Operational Resilience of CBDC: Threats and Prospects of Formal Validation for Offline Payments", "comment": null, "summary": "Information and communication technologies are by now employed in most\nactivities, including economics and finance. Despite the extraordinary power of\nmodern computers and the vast amount of memory, some results of theoretical\ncomputer science imply the impossibility of certifying software quality in\ngeneral. With the exception of safety-critical systems, this has primarily\nconcerned the information processed by confined systems, with limited\nsocio-economic consequences. In the emerging era of technologies for exchanging\ndigital money and tokenized assets over the Internet - such as central bank\ndigital currencies (CBDCs) - even a minor bug could trigger a financial\ncollapse. Although the aforementioned impossibility results cannot be overcome\nin an absolute sense, there exist formal methods that can provide assertions of\ncomputing systems correctness. We advocate their use to validate the\noperational resilience of software infrastructures enabling CBDCs, with special\nemphasis on offline payments as they constitute a very critical issue."}
