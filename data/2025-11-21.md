<div id=toc></div>

# Table of Contents

- [cs.PL](#cs.PL) [Total: 4]
- [cs.DC](#cs.DC) [Total: 8]
- [cs.AR](#cs.AR) [Total: 2]


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [1] [Filling the Gaps of Polarity: Implementing Dependent Data and Codata Types with Implicit Arguments](https://arxiv.org/abs/2511.15819)
*Bohdan Liesnikov,David Binder,Tim Süberkrüb*

Main category: cs.PL

TL;DR: 本文提出了Polarity语言的算法类型系统和隐式参数推理算法，该语言对称处理归纳类型和余归纳类型，解决了表达式问题中的两种扩展性权衡。


<details>
  <summary>Details</summary>
Motivation: 大多数依赖类型语言通过归纳类型支持基于模式匹配的扩展，但通过余归纳类型支持基于接口实现的扩展通常较差。Polarity语言虽然对称处理两种类型，但缺乏隐式参数等现代依赖类型语言特性。

Method: 提供了Polarity语言的完整算法类型系统描述和统一的推理算法，涵盖任意归纳和余归纳类型的统一算法，包括归约语义、转换检查和模式匹配的统一规则。

Result: 开发了正在进行中的算法实现，提供了统一的完整描述和设计决策，可作为其他对称支持归纳和余归纳类型的依赖类型语言的蓝图。

Conclusion: 本文为Polarity语言提供了支持核心对称性的隐式参数算法类型系统和推理算法，填补了该语言在现代依赖类型语言特性方面的空白。

Abstract: The expression problem describes a fundamental tradeoff between two types of extensibility: extending a type with new operations, such as by pattern matching on an algebraic data type in functional programming, and extending a type with new constructors, such as by adding a new object implementing an interface in object-oriented programming. Most dependently typed languages have good support for the former style through inductive types, but support for the latter style through coinductive types is usually much poorer. Polarity is a language that treats both kinds of types symmetrically and allows the developer to switch between type representations.However, it currently lacks several features expected of a state-of-the-art dependently typed language, such as implicit arguments. The central aim of this paper is to provide an algorithmic type system and inference algorithm for implicit arguments that respect the core symmetry of the language. Our work provides two key contributions: a complete algorithmic description of the type system backing Polarity, and a comprehensive description of a unification algorithm that covers arbitrary inductive and coinductive types. We give rules for reduction semantics, conversion checking, and a unification algorithm for pattern-matching, which are essential for a usable implementation. A work-in-progress implementation of the algorithms in this paper is available at https://polarity-lang.github.io/. We expect that the comprehensive account of the unification algorithm and our design decisions can serve as a blueprint for other dependently typed languages that support inductive and coinductive types symmetrically.

</details>


### [2] [Chorex: Restartable, Language-Integrated Choreographies](https://arxiv.org/abs/2511.15820)
*Ashton Wiersdorf,Ben Greenman*

Main category: cs.PL

TL;DR: Chorex是一个将编排编程引入Elixir的语言，通过元编程实现完整的编排功能，支持故障容忍和状态恢复，为构建鲁棒的分布式应用提供新路径。


<details>
  <summary>Details</summary>
Motivation: 构建能够容忍参与者故障的分布式应用，提供自动恢复机制，同时实现与宿主语言的紧密集成。

Method: 通过元编程在Elixir中实现编排编程，支持参与者故障时的自动重启、状态检查点恢复和网络配置更新。投影策略输出无状态函数集合。

Result: 成功实现了故障容忍的编排语言，能够静态检测编排要求与参与者实现的不匹配，并在多个案例中验证了可行性。检查点机制带来一定开销。

Conclusion: Chorex证明了通过元编程实现完整编排功能的可行性，其投影策略为其他语言支持可重启参与者提供了可行方案。

Abstract: We built Chorex, a language that brings choreographic programming to Elixir as a path toward robust distributed applications. Chorex is unique among choreographic languages because it tolerates failure among actors: when an actor crashes, Chorex spawns a new process, restores state using a checkpoint, and updates the network configuration for all actors. Chorex also proves that full-featured choreographies can be implemented via metaprogramming, and that doing so achieves tight integration with the host language. For example, mismatches between choreography requirements and an actor implementation are reported statically and in terms of source code rather than macro-expanded code. This paper illustrates Chorex on several examples, ranging from a higher-order bookseller to a secure remote password protocol, details its implementation, and measures the overhead of checkpointing. We conjecture that Chorex's projection strategy, which outputs sets of stateless functions, is a viable approach for other languages to support restartable actors.

</details>


### [3] [BlueScript: A Disaggregated Virtual Machine for Microcontrollers](https://arxiv.org/abs/2511.15821)
*Fumika Mochizuki,Tetsuro Yamazaki,Shigeru Chiba*

Main category: cs.PL

TL;DR: 提出了一种分解式虚拟机，将尽可能多的组件卸载到主机上，为内存受限的微控制器提供丰富的功能特性


<details>
  <summary>Details</summary>
Motivation: 微控制器虚拟机由于内存限制功能有限，现有虚拟机缺乏交互响应性和高执行速度，需要解决这一限制

Method: 设计并实现了BlueScript VM，使用影子机器数据结构在主机上镜像微控制器的执行状态，以减少通信开销

Result: 卸载组件不会严重损害预期收益，卸载的增量编译器比MicroPython和Espruino执行速度更快，同时保持与MicroPython相当的交互性

Conclusion: 证明了即使在内存受限的微控制器虚拟机上也能提供丰富功能的可行性

Abstract: Virtual machines (VMs) are highly beneficial for microcontroller development. 
In particular, interactive programming environments greatly facilitate iterative development processes, 
and higher execution speeds expand the range of applications that can be developed. 
However, due to their limited memory size, microcontroller VMs provide a limited set of features. 
Widely used VMs for microcontrollers often lack interactive responsiveness and/or high execution speed. 
While researchers have investigated offloading certain VM components to other machines,the types of components that can be offloaded are still restricted. 
In this paper, we propose a disaggregated VM that offloads as many components as possible to a host machine. 
This makes it possible to exploit the abundant memory of the host machine and its powerful processing capability to provide rich features through the VM. 
As an instance of a disaggregated VM, we design and implement a BlueScript VM. 
The BlueScript VM is a virtual machine for microcontrollers that provides an interactive development environment. 
We offload most of the components of the BlueScript VM to a host machine. 
To reduce communication overhead between the host machine and the microcontroller,  
we employed a data structure called a shadow machine on the host machine, 
which mirrors the execution state of the microcontroller. 
Through our experiments, we confirmed that offloading components does not seriously compromise their expected benefits.  
We assess that an offloaded incremental compiler results in faster execution speed than MicroPython and Espruino,  
while keeping interactivity comparable with MicroPython.  
In addition, our experiments observe that the offloaded dynamic compiler improves VM performance. 
Through this investigation, we demonstrate the feasibility of providing rich features even on VMs for memory-limited microcontrollers.

</details>


### [4] [Operon: Incremental Construction of Ragged Data via Named Dimensions](https://arxiv.org/abs/2511.16080)
*Sungbin Moon,Jiho Park,Suyoung Hwang,Donghyun Koh,Seunghyun Moon,Minhyeong Lee*

Main category: cs.PL

TL;DR: Operon是一个基于Rust的工作流引擎，专门处理不规则数据，通过命名维度和显式依赖关系提供静态验证和动态调度，显著提升大规模数据处理性能。


<details>
  <summary>Details</summary>
Motivation: 现代数据处理工作流经常遇到不规则数据，现有工作流引擎缺乏原生支持，用户需要手动管理复杂的索引和依赖关系。

Method: 提出命名维度的形式化方法，提供领域特定语言进行静态验证，运行时系统根据数据形状动态调度任务，采用每任务多队列架构实现高效并行。

Result: 相比现有工作流引擎，Operon实现了14.94倍的基线开销减少，在扩展工作负载时保持接近线性的端到端输出率。

Conclusion: Operon特别适用于机器学习应用中的大规模数据生成管道，通过显式建模部分已知状态实现鲁棒持久化和恢复机制。

Abstract: Modern data processing workflows frequently encounter ragged data: collections with variable-length elements that arise naturally in domains like natural language processing, scientific measurements, and autonomous AI agents. Existing workflow engines lack native support for tracking the shapes and dependencies inherent to ragged data, forcing users to manage complex indexing and dependency bookkeeping manually. We present Operon, a Rust-based workflow engine that addresses these challenges through a novel formalism of named dimensions with explicit dependency relations. Operon provides a domain-specific language where users declare pipelines with dimension annotations that are statically verified for correctness, while the runtime system dynamically schedules tasks as data shapes are incrementally discovered during execution. We formalize the mathematical foundation for reasoning about partial shapes and prove that Operon's incremental construction algorithm guarantees deterministic and confluent execution in parallel settings. The system's explicit modeling of partially-known states enables robust persistence and recovery mechanisms, while its per-task multi-queue architecture achieves efficient parallelism across heterogeneous task types. Empirical evaluation demonstrates that Operon outperforms an existing workflow engine with 14.94x baseline overhead reduction while maintaining near-linear end-to-end output rates as workloads scale, making it particularly suitable for large-scale data generation pipelines in machine learning applications.

</details>


<div id='cs.DC'></div>

# cs.DC [[Back]](#toc)

### [5] [A Scalable NorthPole System with End-to-End Vertical Integration for Low-Latency and Energy-Efficient LLM Inference](https://arxiv.org/abs/2511.15950)
*Michael V. DeBole,Rathinakumar Appuswamy,Neil McGlohon,Brian Taba,Steven K. Esser,Filipp Akopyan,John V. Arthur,Arnon Amir,Alexander Andreopoulos,Peter J. Carlson,Andrew S. Cassidy,Pallab Datta,Myron D. Flickner,Rajamohan Gandhasri,Guillaume J. Garreau,Megumi Ito,Jennifer L. Klamo,Jeffrey A. Kusnitz,Nathaniel J. McClatchey,Jeffrey L. McKinstry,Tapan K. Nayak,Carlos Ortega Otero,Hartmut Penner,William P. Risk,Jun Sawada,Jay Sivagnaname,Daniel F. Smith,Rafael Sousa,Ignacio Terrizzano,Takanori Ueda,Trent Gray-Donald,David Cox,Dharmendra S. Modha*

Main category: cs.DC

TL;DR: 一个端到端的垂直集成研究原型系统，结合288个NorthPole神经推理加速卡，提供可扩展高效的云推理服务，支持多种模型规模和上下文长度。


<details>
  <summary>Details</summary>
Motivation: 为企业在现有数据中心环境中部署AI应用提供可扩展、模块化和可重构的推理服务系统。

Method: 采用288个NorthPole神经推理加速卡，结合离线训练算法、高性能运行时堆栈和容器化推理管道构建端到端系统。

Result: 系统在42U机架空间内提供115 peta-ops计算能力、3.7 PB/s内存带宽，功耗仅30kW，可同时运行3个80亿参数模型实例，支持28个用户，每个用户令牌延迟2.8ms。

Conclusion: 该系统是部署企业AI应用代理工作流程的理想选择，支持从30亿到700亿参数的各种模型规模。

Abstract: A vertically integrated, end-to-end, research prototype system combines 288 NorthPole neural inference accelerator cards, offline training algorithms, a high-performance runtime stack, and a containerized inference pipeline to deliver a scalable and efficient cloud inference service. The system delivers 115 peta-ops at 4-bit integer precision and 3.7 PB/s of memory bandwidth across 18 2U servers, while consuming only 30 kW of power and weighing 730 kg in a 0.67 m^2 42U rack footprint. The system can run 3 simultaneous instances of the 8-billion-parameter open-source IBM Granite-3.3-8b-instruct model at 2,048 context length with 28 simultaneous users and a per-user inter-token latency of 2.8 ms. The system is scalable, modular, and reconfigurable, supporting various model sizes and context lengths, and is ideal for deploying agentic workflows for enterprise AI applications in existing data center (cloud, on-prem) environments. For example, the system can support 18 instances of a 3-billion-parameter model or a single instance of a 70-billion-parameter model.

</details>


### [6] [Can Asymmetric Tile Buffering Be Beneficial?](https://arxiv.org/abs/2511.16041)
*Chengyue Wang,Wesley Pang,Xinrui Wu,Gregory Jun,Luis Romero,Endri Taka,Diana Marculescu,Tony Nowatzki,Pranathi Vasireddy,Joseph Melber,Deming Chen,Jason Cong*

Main category: cs.DC

TL;DR: 提出了一种称为非对称瓦片缓冲（ATB）的新技术，通过解耦输入和输出操作数的缓冲瓦片维度，显著提升了GEMM计算性能，在AMD XDNA2 AIE上实现了4.54倍加速。


<details>
  <summary>Details</summary>
Motivation: 传统对称瓦片缓冲方法中，输入A沿维度M的缓冲瓦片大小与输出C的瓦片大小匹配，限制了计算效率。ATB旨在打破这种对称性约束，提升算术强度。

Method: 开发了非对称瓦片缓冲技术，解耦输入和输出操作数的缓冲瓦片维度，并建立了包含ATB收益（更高算术强度）和开销（更高内核切换成本）的性能模型来指导瓦片因子选择。

Result: 在AMD XDNA2 AIE上应用ATB，混合精度BFP16-BF16 GEMM性能从4.8 TFLOPS提升至24.6 TFLOPS，达到4.54倍加速，创造了XDNA2 AIE的新性能记录。

Conclusion: ATB是一种简单但强大的技术，首次证明非对称瓦片缓冲既实用又高效，为GEMM计算提供了新的优化方向。

Abstract: General matrix multiplication (GEMM) is the computational backbone of modern AI workloads, and its efficiency is critically dependent on effective tiling strategies. Conventional approaches employ symmetric tile buffering, where the buffered tile size of the input $A$ along the dimension $M$ matches the output tile size of $C$.
  In this paper, we introduce asymmetric tile buffering (ATB), a simple but powerful technique that decouples the buffered tile dimensions of the input and output operands. We show, for the first time, that ATB is both practical and highly beneficial. To explain this effect, we develop a performance model that incorporates both the benefits of ATB (higher arithmetic intensity) and its overheads (higher kernel switching costs), providing insight into how to select effective ATB tiling factors. As a case study, we apply ATB to AMD's latest XDNA2 AI Engine (AIE), achieving up to a 4.54x speedup, from 4.8 to 24.6 TFLOPS on mixed-precision BFP16--BF16 GEMM, establishing a new performance record for XDNA2 AIE.

</details>


### [7] [Mitigating Shared Storage Congestion Using Control Theory](https://arxiv.org/abs/2511.16177)
*Thomas Collignon,Kouds Halitim,Raphaël Bleuse,Sophie Cerf,Bogdan Robu,Éric Rutten,Lionel Seinturier,Alexandre van Kempen*

Main category: cs.DC

TL;DR: 提出基于控制理论的自适应方法，动态调节客户端I/O速率以解决HPC系统中的I/O拥塞问题，减少总运行时间达20%并降低尾延迟。


<details>
  <summary>Details</summary>
Motivation: 传统I/O栈优化方法通常针对特定工作负载且需要专业知识，难以通用化。在共享HPC环境中，资源拥塞会导致性能不可预测，造成减速和超时。

Method: 基于控制理论的自适应方法，利用少量运行时系统负载指标动态调节客户端I/O速率，减少拥塞并提高性能稳定性。

Result: 在多节点集群上实现控制器并在真实测试平台上评估，实验结果显示能有效缓解I/O拥塞，总运行时间最多减少20%，尾延迟降低，同时保持稳定性能。

Conclusion: 基于控制理论的自适应I/O速率调节方法能有效解决HPC系统中的I/O拥塞问题，提高性能稳定性和效率。

Abstract: Efficient data access in High-Performance Computing (HPC) systems is essential to the performance of intensive computing tasks. Traditional optimizations of the I/O stack aim to improve peak performance but are often workload specific and require deep expertise, making them difficult to generalize or re-use. In shared HPC environments, resource congestion can lead to unpredictable performance, causing slowdowns and timeouts. To address these challenges, we propose a self-adaptive approach based on Control Theory to dynamically regulate client-side I/O rates. Our approach leverages a small set of runtime system load metrics to reduce congestion and enhance performance stability. We implement a controller in a multi-node cluster and evaluate it on a real testbed under a representative workload. Experimental results demonstrate that our method effectively mitigates I/O congestion, reducing total runtime by up to 20% and lowering tail latency, while maintaining stable performance.

</details>


### [8] [Optimizing Communication in Byzantine Agreement Protocols with Slim-HBBFT](https://arxiv.org/abs/2511.15957)
*Nasit S Sony,Xianzhong Ding*

Main category: cs.DC

TL;DR: Slim-HBBFT是一种原子广播协议，通过仅考虑部分节点的请求来降低通信复杂度，相比传统异步拜占庭协议提升O(n)倍效率。


<details>
  <summary>Details</summary>
Motivation: 传统异步拜占庭协议需要广播所有节点的请求，当请求重复时这种昂贵协议不划算。需要设计更高效的原子广播协议。

Method: 使用优先可证明广播(P-PB)协议，仅为选定的节点生成广播证明，基于此构建Slim-HBBFT原子广播协议。

Result: Slim-HBBFT将通信复杂度降低了O(n)倍，同时满足异步公共子集协议的安全属性。

Conclusion: Slim-HBBFT在保持安全性的同时显著提升了异步网络中的原子广播效率，特别适用于请求重复的场景。

Abstract: Byzantine agreement protocols in asynchronous networks have received renewed interest because they do not rely on network behavior to achieve termination. Conventional asynchronous Byzantine agreement protocols require every party to broadcast its requests (e.g., transactions), and at the end of the protocol, parties agree on one party's request. If parties agree on one party's requests while exchanging every party's request, the protocol becomes expensive. These protocols are used to design an atomic broadcast (ABC) protocol where parties agree on $\langle n-f \rangle$ parties' requests (assuming $n=3f+1$, where $n$ is the total number of parties, and $f$ is the number of Byzantine parties). Although the parties agree on a subset of requests in the ABC protocol, if the requests do not vary (are duplicated), investing in a costly protocol is not justified. We propose Slim-HBBFT, an atomic broadcast protocol that considers requests from a fraction of $n$ parties and improves communication complexity by a factor of $O(n)$. At the core of our design is a prioritized provable-broadcast (P-PB) protocol that generates proof of broadcast only for selected parties. We use the P-PB protocol to design the Slim-HBBFT atomic broadcast protocol. Additionally, we conduct a comprehensive security analysis to demonstrate that Slim-HBBFT satisfies the properties of the Asynchronous Common Subset protocol, ensuring robust security and reliability.

</details>


### [9] [Efficient Chromosome Parallelization for Precision Medicine Genomic Workflows](https://arxiv.org/abs/2511.15977)
*Daniel Mas Montserrat,Ray Verma,Míriam Barrabés,Francisco M. de la Vega,Carlos D. Bustamante,Alexander G. Ioannidis*

Main category: cs.DC

TL;DR: 提出了多种自适应内存优化机制来并行化染色体级生物信息学工作流，包括符号回归模型预测内存使用、动态调度器优化任务打包、静态调度器优化处理顺序，以减少内存溢出并提高执行效率。


<details>
  <summary>Details</summary>
Motivation: 大规模基因组工作流处理数十到数百GB数据时出现高内存峰值、磁盘I/O密集和内存不足错误，静态资源分配方法无法处理染色体间RAM需求变化，导致资源利用率低和运行时间长。

Method: 1) 开发符号回归模型估计每染色体内存消耗并引入插值偏置保守最小化过度分配；2) 动态调度器使用多项式回归预测RAM使用，将任务打包视为背包问题优化批处理；3) 静态调度器优化染色体处理顺序以最小化峰值内存。

Result: 在模拟和真实基因组流程评估中，提出的方法减少了内存溢出，平衡了线程间负载，实现了更快的端到端执行。

Conclusion: 这些方法展示了优化大规模基因组工作流的潜力，通过自适应内存管理提高了资源利用率和执行效率。

Abstract: Large-scale genomic workflows used in precision medicine can process datasets spanning tens to hundreds of gigabytes per sample, leading to high memory spikes, intensive disk I/O, and task failures due to out-of-memory errors. Simple static resource allocation methods struggle to handle the variability in per-chromosome RAM demands, resulting in poor resource utilization and long runtimes. In this work, we propose multiple mechanisms for adaptive, RAM-efficient parallelization of chromosome-level bioinformatics workflows. First, we develop a symbolic regression model that estimates per-chromosome memory consumption for a given task and introduces an interpolating bias to conservatively minimize over-allocation. Second, we present a dynamic scheduler that adaptively predicts RAM usage with a polynomial regression model, treating task packing as a Knapsack problem to optimally batch jobs based on predicted memory requirements. Additionally, we present a static scheduler that optimizes chromosome processing order to minimize peak memory while preserving throughput. Our proposed methods, evaluated on simulations and real-world genomic pipelines, provide new mechanisms to reduce memory overruns and balance load across threads. We thereby achieve faster end-to-end execution, showcasing the potential to optimize large-scale genomic workflows.

</details>


### [10] [Fast LLM Post-training via Decoupled and Best-of-N Speculation](https://arxiv.org/abs/2511.16193)
*Rongxin Cheng,Kai Zhou,Xingda Wei,Siyuan Liu,Mingcong Han,Mingjing Ai,Yeju Zhou,Baoquan Zhong,Wencong Xiao,Xin Liu,Rong Chen,Haibo Chen*

Main category: cs.DC

TL;DR: SpecActor通过动态解耦推测和动态Best-of-N推测方法，在LLM后训练中实现了1.3-1.7倍的加速效果


<details>
  <summary>Details</summary>
Motivation: 解决大语言模型后训练中rollout阶段耗时长的问题，特别是在大批量配置下推测执行效率低下的挑战

Method: 使用动态解耦推测执行方法最大化GPU计算效率，以及动态Best-of-N推测方法根据rollout进度选择和组合不同的草稿生成方法

Result: 相比常见后训练基线快1.3-1.7倍，相比直接采用推测解码快1.3-1.5倍

Conclusion: SpecActor有效解决了推测rollout中的关键挑战，显著提升了LLM后训练的效率

Abstract: Rollout dominates the training time in large language model (LLM) post-training, where the trained model is used to generate tokens given a batch of prompts. SpecActor achieves fast rollout with speculative decoding that deploys a fast path (e.g., a smaller model) to accelerate the unparallelizable generation, while the correctness is guaranteed by fast parallel verification of the outputs with the original model. SpecActor addresses two foundational challenges in speculative rollout by (1) a \emph{dynamic decoupled speculation} execution method that maximizes the GPU computational efficiency to realize speedup for large-batch execution -- a configuration common in training but unfriendly to speculative execution and (2) a \emph{dynamic Best-of-N speculation} method that selects and combines different drafting methods according to the rollout progress. It substantially improves the speculation accuracy even when the best drafting method is unknown a priori, meanwhile without requiring adding extra computation resources. {\sys} is {1.3--1.7}\,$\times$ faster than common post-training baselines, and is {1.3--1.5}\,$\times$ faster compared to naively adopting speculative decoding for rollout.

</details>


### [11] [Optimizing Federated Learning in the Era of LLMs: Message Quantization and Streaming](https://arxiv.org/abs/2511.16450)
*Ziyue Xu,Zhihong Zhang,Holger R. Roth,Chester Chen,Yan Cheng,Andrew Feng*

Main category: cs.DC

TL;DR: 该论文提出了针对大型语言模型联邦学习的通信优化方案，通过量化和流式传输技术解决模型参数传输的内存和通信瓶颈问题。


<details>
  <summary>Details</summary>
Motivation: 联邦学习在保护数据隐私的同时面临大型语言模型带来的通信开销和本地资源限制挑战，需要高效的传输和处理方案。

Method: 基于NVIDIA FLARE SDK，采用消息量化和容器/文件流式传输两种关键技术，减少消息大小并优化内存管理。

Result: 这些技术显著提升了联邦学习在大型语言模型场景下的鲁棒性和效率，改善了实际部署性能。

Conclusion: 通过量化和流式传输技术，成功解决了联邦学习在大型语言模型应用中的通信和内存约束问题，为实际部署提供了可行方案。

Abstract: Federated Learning (FL) offers a promising solution for training machine learning models across distributed data sources while preserving data privacy. However, FL faces critical challenges related to communication overhead and local resource constraints, especially in the era of Large Language Models (LLMs) with billions of parameters. The sheer size of these models exacerbates both memory and communication constraints, making efficient transmission and processing essential for practical deployment. NVIDIA FLARE, an open-source SDK for federated learning, addresses these challenges by introducing advanced communication capabilities. Building upon existing solutions for large object streaming, we enhance FL workflows for LLMs through two key techniques: message quantization and container/file streaming. Quantization reduces message size, while streaming enables efficient memory management, improving scalability and integration with existing workflows. These advancements significantly enhance the robustness and efficiency of FL with LLMs, ensuring better performance in real-world federated learning scenarios.

</details>


### [12] [Distributed MIS Algorithms for Rational Agents using Games](https://arxiv.org/abs/2511.16533)
*Nithin Salevemula,Shreyas Pai*

Main category: cs.DC

TL;DR: 该论文研究在分布式网络中计算最大独立集的问题，其中节点是理性代理，其收益取决于是否加入MIS。提出了两种基于效用模型的算法，通过邻居节点间的成对交互生成随机性，确保在理性行为下仍能打破对称性。


<details>
  <summary>Details</summary>
Motivation: 传统分布式算法假设节点遵循协议，但在理性设置下，节点可能为了增加期望效用而偏离协议。标准MIS算法依赖诚实随机性或唯一标识符，但理性代理可能操纵随机性，仅依赖标识符可能导致不公平，使某些节点加入MIS的概率为零，从而缺乏参与动机。

Method: 提出两种基于效用模型的算法，其中随机性通过邻居节点间的成对交互生成，这种交互被视为简单游戏，没有单个节点能单方面影响结果。这允许在保持与理性行为兼容的同时打破对称性。

Result: 证明在算法执行的每个阶段，给定任何历史，假设其他节点遵循算法，没有代理能通过单边偏离增加其期望效用。当所有节点遵循协议时，每个节点都有正概率加入MIS，最终输出正确的MIS。在温和附加假设下，两种算法都以高概率在O(log n)轮内终止。

Conclusion: 所提出的算法在理性分布式设置中提供了强于颤抖手完美均衡的保证，确保了公平性和正确性，同时保持了高效的时间复杂度。

Abstract: We study the problem of computing a Maximal Independent Set (MIS) in distributed networks where each node is a rational agent whose payoff depends on whether it joins the MIS. Classical distributed algorithms assume that nodes follow the prescribed protocol, but this assumption fails when nodes are strategic and may deviate if doing so increases their expected utility.
  Standard MIS algorithms rely on honest randomness or unique identifiers to break symmetry. In rational settings, however, agents may manipulate randomness, and relying solely on identifiers can create unfairness, giving some nodes zero probability of joining the MIS and thus no incentive to participate. To address these issues, we propose two algorithms based on a utility model in which agents seek locally correct solutions while also having preferences over which solution is chosen. Randomness in our algorithms is generated through pairwise interactions between neighboring nodes, viewed as simple games in which no single node can unilaterally affect the outcome. This allows symmetry breaking while remaining compatible with rational behavior.
  For both algorithms, we prove that at every stage of the execution, given any history, no agent can increase its expected utility through a unilateral deviation, assuming others follow the algorithm. This gives a stronger guarantee than Trembling-Hand Perfect Equilibrium. When all nodes follow the protocol, every node has a positive probability of joining the MIS, and the final output is a correct MIS. Under mild additional assumptions, both algorithms terminate in $O(\log n)$ rounds with high probability.

</details>


<div id='cs.AR'></div>

# cs.AR [[Back]](#toc)

### [13] [CIMinus: Empowering Sparse DNN Workloads Modeling and Exploration on SRAM-based CIM Architectures](https://arxiv.org/abs/2511.16368)
*Yingjie Qi,Jianlei Yang,Rubing Yang,Cenlin Duan,Xiaolin He,Ziyan He,Weitao Pan,Weisheng Zhao*

Main category: cs.AR

TL;DR: 提出了CIMinus框架，用于对CIM架构上稀疏DNN工作负载进行成本建模，包括能耗分析和延迟评估，并通过两个用例验证了其有效性。


<details>
  <summary>Details</summary>
Motivation: CIM系统在利用稀疏性方面面临挑战，缺乏对多样化稀疏DNN工作负载的统一系统化视图和建模方法。

Method: 开发了CIMinus框架，提供组件级能耗分析和整体工作负载延迟评估，并在当代CIM架构上进行验证。

Result: 验证了CIMinus在当代CIM架构上的适用性，通过两个用例展示了稀疏模式影响和映射策略有效性。

Conclusion: CIMinus框架填补了理论设计与实际实现之间的空白，为稀疏DNN在CIM系统中的优化提供了系统化建模方法。

Abstract: Compute-in-memory (CIM) has emerged as a pivotal direction for accelerating workloads in the field of machine learning, such as Deep Neural Networks (DNNs). However, the effective exploitation of sparsity in CIM systems presents numerous challenges, due to the inherent limitations in their rigid array structures. Designing sparse DNN dataflows and developing efficient mapping strategies also become more complex when accounting for diverse sparsity patterns and the flexibility of a multi-macro CIM structure. Despite these complexities, there is still an absence of a unified systematic view and modeling approach for diverse sparse DNN workloads in CIM systems. In this paper, we propose CIMinus, a framework dedicated to cost modeling for sparse DNN workloads on CIM architectures. It provides an in-depth energy consumption analysis at the level of individual components and an assessment of the overall workload latency. We validate CIMinus against contemporary CIM architectures and demonstrate its applicability in two use-cases. These cases provide valuable insights into both the impact of sparsity patterns and the effectiveness of mapping strategies, bridging the gap between theoretical design and practical implementation.

</details>


### [14] [Unsupervised Graph Neural Network Framework for Balanced Multipatterning in Advanced Electronic Design Automation Layouts](https://arxiv.org/abs/2511.16374)
*Abdelrahman Helaly,Nourhan Sakr,Kareem Madkour,Ilhami Torunoglu*

Main category: cs.AR

TL;DR: 提出了一种混合工作流程，将多模式分解建模为带约束的图着色问题，主要目标是减少特征冲突，次要目标是平衡各掩模上的特征数量。


<details>
  <summary>Details</summary>
Motivation: 传统的启发式回溯和SAT求解器在处理复杂约束和次要目标时存在困难，需要一种能同时处理这两方面的方法。

Method: 结合两个主要组件：(1) 无监督训练的GNN代理生成初始颜色预测；(2) 使用GNN启发式和模拟退火进行精炼，提升解质量和平衡性。

Result: 在专有和开源数据集上的实验表明，实现了无冲突分解和一致的色彩平衡。

Conclusion: 该框架为EDA工作流程中的可扩展布局分解提供了可重现、数据高效且可部署的基线。

Abstract: Multipatterning is an essential decomposition strategy in electronic design automation (EDA) that overcomes lithographic limitations when printing dense circuit layouts. Although heuristic-based backtracking and SAT solvers can address these challenges, they often struggle to simultaneously handle both complex constraints and secondary objectives. In this study, we present a hybrid workflow that casts multipatterning as a variant of a constrained graph coloring problem with the primary objective of minimizing feature violations and a secondary objective of balancing the number of features on each mask. Our pipeline integrates two main components: (1) A GNN-based agent, trained in an unsupervised manner to generate initial color predictions, which are refined by (2) refinement strategies (a GNN-based heuristic and simulated annealing) that together enhance solution quality and balance. Experimental evaluation in both proprietary data sets and publicly available open source layouts demonstrate complete conflict-free decomposition and consistent color balancing. The proposed framework provides a reproducible, data-efficient and deployable baseline for scalable layout decomposition in EDA workflows.

</details>
